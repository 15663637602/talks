#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Industry-strength join calculus: Declarative concurrent programming with
 
\family typewriter
Chymyst
\end_layout

\begin_layout Author
Sergei Winitzki
\end_layout

\begin_layout Abstract
Join calculus (JC) is a declarative message-passing concurrency formalism
 that has been ignored by the software engineering community, despite its
 significant promise as a means of solving the problems of concurrent programmin
g.
 I introduce 
\family typewriter
Chymyst
\family default
, a new open-source framework that aims to bring industry-strength JC programmin
g to Scala practitioners.
 Taking advantage of its embedding into the Scala language, 
\family typewriter
Chymyst
\family default
 enhances JC with features such as arbitrary non-linear join patterns with
 guard conditions, synchronous rendezvous, time-outs, and incremental constructi
on of join definitions.
 The current implementation also performs static analysis of user code,
 early error detection, and automatic performance optimizations.
 To ease the learning curve for engineers unfamiliar with the concepts of
 JC, I develop a pedagogical presentation of JC as an evolution of the well-know
n Actor model whereby actors are made type-safe, immutable, and are automaticall
y managed.
 After a comparison of 
\family typewriter
Chymyst
\family default
 with the popular 
\family typewriter
Akka
\family default
 library, I identify a comprehensive set of additional features necessary
 to make JC an industry-ready concurrency paradigm.
 These features include APIs for unit testing, performance monitoring, and
 fault tolerance, and are next steps on the 
\family typewriter
Chymyst
\family default
 project's development roadmap.
\end_layout

\begin_layout Section
Introduction and summary
\end_layout

\begin_layout Standard
Advanced programming models developed by the theoretical computer science
 community are often ignored by software practitioners.
 One such case is join calculus (JC)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "FouGon1996"

\end_inset

, which can be seen as a DSL (domain-specific language) for high-level,
 declarative, functional concurrent programming.
 Given the high importance of concurrent programming and a growing adoption
 of functional languages, one would expect that software practitioners would
 take advantage of this high-level and type-safe concurrency paradigm.
 Nevertheless, there appears to be no practical adoption of JC by the software
 industry.
\begin_inset Foot
status open

\begin_layout Plain Layout
A Google search yields several academic projects but no mentions of industrial
 JC use.
\end_layout

\end_inset

 Perhaps not coincidentally, there are very few open-source implementations
 of JC available for download and use.
 The only fully maintained implementation of JC is the JoCaml language
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "FouEA2003"

\end_inset

.
\end_layout

\begin_layout Standard
A significant barrier for industry adoption is the lack of suitable documentatio
n and example code.
 The existing documentation and tutorials for JC, such as the JoCaml user's
 manual
\begin_inset Foot
status open

\begin_layout Plain Layout
 See 
\begin_inset CommandInset href
LatexCommand href
name "jocaml.inria.fr/doc/index.html"
target "http://jocaml.inria.fr/doc/index.html"

\end_inset

.
\end_layout

\end_inset

, the original authors' introduction to JC
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "FouGon2000"

\end_inset

, and the lecture notes
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "FouEA2003"

\end_inset

 were intended for graduate students in computer science and are largely
 incomprehensible to software engineers.
 Effective JC programming requires a certain paradigm shift and facility
 with JC-specific design patterns, which is not readily achieved without
 working through numerous examples.
\end_layout

\begin_layout Standard
In this paper, I present a new open-source implementation of JC as a library
 called 
\family typewriter
Chymyst
\family default
,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The name is borrowed from the early treatise
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Boy1661"

\end_inset

 by Robert Boyle, who was one of the founders of the science of chemistry.
\end_layout

\end_inset

 providing an embedded Scala DSL and a light-weight runtime.
 The main design focus of 
\family typewriter
Chymyst
\family default
 is to enable high-level, declarative concurrency in idiomatic Scala, using
 the JC paradigm.
 At the same time, I aim to provide industry-strength features that are
 typically not considered by academic presentations of JC, such as performance
 tuning, fault tolerance, or unit testing APIs.
 Finally, the 
\family typewriter
Chymyst
\family default
 project offers tutorial documentation adapted to the software developer
 audience.
 In these ways, I hope to enable industry adoption of this promising concurrency
 paradigm.
\end_layout

\begin_layout Subsection
Contributions of this paper
\end_layout

\begin_layout Standard
I describe the main design decisions made in the 
\family typewriter
Chymyst
\family default
 project while implementing join calculus as an embedded DSL in Scala.
 
\end_layout

\begin_layout Standard

\family typewriter
Chymyst
\family default
 lifts several restrictions that are present in most other JC projects,
 and offers some additional features:
\end_layout

\begin_layout Itemize
separate definition of channel names and processes
\end_layout

\begin_layout Itemize
arbitrary non-linear patterns and guards in process definitions
\end_layout

\begin_layout Itemize
synchronous rendezvous
\end_layout

\begin_layout Itemize
first-class processes with arbitrary process bodies
\end_layout

\begin_layout Itemize
incremental construction of join definitions from processes
\end_layout

\begin_layout Itemize
automatic performance optimizations
\end_layout

\begin_layout Itemize
static code analysis and early error detection
\end_layout

\begin_layout Standard
I argue that certain new facilities need to be added to a JC implementation
 in order to make it viable for industry adoption.
 These facilities include:
\end_layout

\begin_layout Itemize
explicit thread pools for performance tuning
\end_layout

\begin_layout Itemize
time-outs for synchronous channels
\end_layout

\begin_layout Itemize
interoperability with 
\family typewriter
Future
\family default
s
\end_layout

\begin_layout Itemize
APIs for unit testing and debugging
\end_layout

\begin_layout Itemize
per-process fault tolerance settings
\end_layout

\begin_layout Itemize
message pipelining
\end_layout

\begin_layout Standard
I describe the current implementation of these facilities in 
\family typewriter
Chymyst
\family default
.
\end_layout

\begin_layout Standard
To better explain the concepts of JC to new software developers, I avoid
 the traditional academic terminology (message / channel / process / join
 definition).
 Instead, I show how to describe JC as an evolution of the Actor model,
 which is ideal for developers already familiar with the Akka library.
 When introducing JC from scratch, I rely on the 
\begin_inset Quotes eld
\end_inset

abstract chemical machine
\begin_inset Quotes erd
\end_inset

 metaphor and use the corresponding terminology (molecule / emitter / reaction
 / reaction site), which is more visual and intuitive.
 Synchronous channels (
\begin_inset Quotes eld
\end_inset

blocking emitters
\begin_inset Quotes erd
\end_inset

) are most easily understood by carrying out a continuation-passing code
 transformation from blocking code to code that uses only asynchronous,
 non-blocking channels.
 The syntax used by 
\family typewriter
Chymyst
\family default
 for blocking channels makes this code transformation more transparent.
\end_layout

\begin_layout Subsection
Previous work
\end_layout

\begin_layout Standard
Since its invention more than 20 years ago, join calculus has been implemented
 by a number of academic researchers, typically by creating an entirely
 new JC-based programming language or by patching an existing language.
 It is hard to assess the scope and practical use of these implementations,
 since most of them appear to be proof-of-concept projects developed to
 accompany academic publications.
 
\end_layout

\begin_layout Standard
Here I will not attempt to survey the theoretical advances made by those
 researchers.
 Since the main goal of the 
\family typewriter
Chymyst
\family default
 project is to enable industry acceptance of JC, I will focus on the practical
 availability and usability of the existing JC implementations.
\end_layout

\begin_layout Standard
JoCaml was one of the first implementations of JC
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "FouEA2003"

\end_inset

, and remains today the best-supported one.
 This implementation is a patch for the OCaml compiler, which is fully compatibl
e with the OCaml library ecosystem.
 
\end_layout

\begin_layout Standard
M.
\begin_inset space ~
\end_inset

Odersky created a new language called 
\begin_inset Quotes eld
\end_inset

Funnel
\begin_inset Quotes erd
\end_inset

, based on the JC paradigm
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Ode2000"

\end_inset

.
 The Funnel project appears to be abandoned, since M.
\begin_inset space ~
\end_inset

Odersky went on to develop Scala, which does not include any concepts or
 features of JC.
\end_layout

\begin_layout Standard
G.
\begin_inset space ~
\end_inset

S.
\begin_inset space ~
\end_inset

von Itzstein implemented JC as a patch for the early Java compiler
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Von2004"

\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

Join Java
\begin_inset Quotes erd
\end_inset

 project appears to be abandoned.
\end_layout

\begin_layout Standard
The first appearance of JC in Scala was a “Join in Scala” compiler patch
 by V.
\begin_inset space ~
\end_inset

Cremet (2003).
\begin_inset Foot
status open

\begin_layout Plain Layout
 See 
\begin_inset CommandInset href
LatexCommand href
name "lampwww.epfl.ch/~cremet/misc/join_in_scala/"
target "http://lampwww.epfl.ch/~cremet/misc/join_in_scala/index.html"

\end_inset

.
\end_layout

\end_inset

 The syntax of Scala has changed radically since 2003, rendering the project
 unusable.
\end_layout

\begin_layout Standard
T.
\begin_inset space ~
\end_inset

Rompf implemented an experimental (unnamed) language based on JC and illustrated
 its use for important application design patterns, such as 
\begin_inset Quotes eld
\end_inset

fork/join
\begin_inset Quotes erd
\end_inset

 synchronization or asynchronous continuations
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Rom2007"

\end_inset

.
 The project appears to be abandoned, as T.
\begin_inset space ~
\end_inset

Rompf moved on to research on multi-stage compilation
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Rom2012"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Joinads
\begin_inset Quotes erd
\end_inset

 is a set of compiler patches for F# and Haskell, developed by T.
\begin_inset space ~
\end_inset

Petricek
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "PetSym2011"

\end_inset

.
 The project is not maintained.
\end_layout

\begin_layout Standard
Creating a 
\emph on
new
\emph default
 programming language, either from scratch or via compiler patches, has
 been a common pattern in JC implementations.
 The reason seems to be the difficulty of accommodating join definitions
 within the syntax of existing languages.
 Short-lived projects such as Polyphonic C#
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "BenFou2002"

\end_inset

, C
\begin_inset Formula $\omega$
\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Rus2007"

\end_inset

, Join Diesel
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Ose2005"

\end_inset

, JErlang
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "PloEis2009"

\end_inset

, and Hume
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "HamEA2006"

\end_inset

 also follow that pattern.
 All these new languages have since been abandoned by their creators.
 It appears that maintaining and supporting a completely new research language
 for JC is hardly possible, even for a corporation such as Microsoft.
 Therefore, we turn our attention to implementations of JC as an embedded
 DSL in a well-established programming language.
 
\end_layout

\begin_layout Standard
C.
\begin_inset space ~
\end_inset

Russo created the 
\begin_inset Quotes eld
\end_inset

Scalable Joins
\begin_inset Quotes erd
\end_inset

 library for the .NET platform
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Rus2007"

\end_inset

.
 The library appears to be unsupported.
\begin_inset Foot
status open

\begin_layout Plain Layout
 See 
\begin_inset CommandInset href
LatexCommand href
name "github.com/JoinPatterns/ScalableJoins"
target "https://github.com/JoinPatterns/ScalableJoins"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
(This is not actually JC but CSP!) In 2009, F.
\begin_inset space ~
\end_inset

Peschanski published a JC library for the Lua language, called 
\begin_inset Quotes eld
\end_inset

LuaPi
\begin_inset Quotes erd
\end_inset

.
 The library appears to be unsupported.
\begin_inset Foot
status open

\begin_layout Plain Layout
 See 
\begin_inset CommandInset href
LatexCommand href
name "github.com/fredokun/LuaPi"
target "https://github.com/fredokun/LuaPi"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Y.
\begin_inset space ~
\end_inset

Liu implemented the basic JC primitives in 2007-2009 as part of the C++
 
\family typewriter
Boost
\family default
 library.
\begin_inset Foot
status open

\begin_layout Plain Layout
 See 
\begin_inset CommandInset href
LatexCommand href
name "channel.sourceforge.net"
target "http://channel.sourceforge.net/"

\end_inset

.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
In 2013, the present author created experimental JC prototypes for Objective-C
 on iOS and for Java on Android
\begin_inset Foot
status open

\begin_layout Plain Layout
 See 
\begin_inset CommandInset href
LatexCommand href
name "github.com/winitzki"
target "https://github.com/winitzki"

\end_inset

.
\end_layout

\end_inset

; these projects are unmaintained.
 However, the present 
\family typewriter
Chymyst
\family default
 implementation reuses some design decisions made in these earlier projects.
\end_layout

\begin_layout Standard
In 2014, S.
\begin_inset space ~
\end_inset

Yallop implemented 
\begin_inset Quotes eld
\end_inset

Join Language
\begin_inset Quotes erd
\end_inset

 as a DSL embedded in Haskell.
\begin_inset Foot
status open

\begin_layout Plain Layout
 See 
\begin_inset CommandInset href
LatexCommand href
name "github.com/syallop/Join-Language"
target "https://github.com/syallop/Join-Language"

\end_inset

.
\end_layout

\end_inset

 The implementation uses advanced features of Haskell's type system to provide
 a concise syntax for join definitions.
\end_layout

\begin_layout Standard
The first embedding of JC as a Scala DSL was P.
\begin_inset space ~
\end_inset

Haller's 
\begin_inset Quotes eld
\end_inset

Scala Joins
\begin_inset Quotes erd
\end_inset

 library
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "HalCut2008"

\end_inset

.
 Thereafter, J.
\begin_inset space ~
\end_inset

He improved upon 
\begin_inset Quotes eld
\end_inset

Scala Joins
\begin_inset Quotes erd
\end_inset

 by streamlining the syntax, removing restrictions on pattern matching,
 and implementing remote processes
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "He2014"

\end_inset

.
 
\family typewriter
Chymyst
\family default
 is a further development of P.
\begin_inset space ~
\end_inset

Haller and J.
\begin_inset space ~
\end_inset

He's syntax for embedding JC into Scala.
\end_layout

\begin_layout Standard
C.
\begin_inset space ~
\end_inset

Russo's library
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Rus2007"

\end_inset

 allowed synchronous rendezvous in join patterns as well as incremental
 construction of processes and join definitions, while T.
\begin_inset space ~
\end_inset

Rompf's language
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Rom2007"

\end_inset

 used a continuation-passing syntax for synchronous channels, instead of
 the traditional 
\begin_inset Quotes eld
\end_inset


\family typewriter
reply to
\family default

\begin_inset Quotes erd
\end_inset

 syntax.
 
\family typewriter
Chymyst
\family default
 also adopts these design choices.
\end_layout

\begin_layout Section
Programming in 
\family typewriter
Chymyst
\end_layout

\begin_layout Standard
In my experience, the absolute majority of software developers are unfamiliar
 with join calculus or its 
\begin_inset Quotes eld
\end_inset

channel
\begin_inset Quotes erd
\end_inset

 / 
\begin_inset Quotes eld
\end_inset

message
\begin_inset Quotes erd
\end_inset

 / 
\begin_inset Quotes eld
\end_inset

process
\begin_inset Quotes erd
\end_inset

 terminology, but the majority of Scala concurrency practitioners know about
 the Actor model.
 Accordingly, I would argue that introducing JC concepts to the Scala developer
 audience should build upon the existing Actor model knowledge.
 However, reasoning about JC programs is most direct and convenient when
 using the visual metaphors and the terminology of the Abstract Chemical
 Machine (
\begin_inset Quotes eld
\end_inset

emitter
\begin_inset Quotes erd
\end_inset

 / 
\begin_inset Quotes eld
\end_inset

molecule
\begin_inset Quotes erd
\end_inset

 / 
\begin_inset Quotes eld
\end_inset

reaction
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
The next subsection is a brief introduction to programming in join calculus
 using 
\family typewriter
Chymyst
\family default
.
 This introduction is suitable for readers not already familiar with either
 join calculus or the Actor model.
\end_layout

\begin_layout Subsection
The chemical metaphor for concurrency
\end_layout

\begin_layout Standard
Neither of the words 
\begin_inset Quotes eld
\end_inset

join
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

calculus
\begin_inset Quotes erd
\end_inset

 are particularly explanatory or visually suggestive.
 The 
\begin_inset Quotes eld
\end_inset

chemical machine
\begin_inset Quotes erd
\end_inset

, on the other hand, is a visually concrete execution model that can be
 directly used for designing and reasoning about a JC program.
 This subsection is a brief overview of JC as seen through the chemical
 machine metaphor, in order to establish terminology.
\end_layout

\begin_layout Standard
To begin, one imagines a 
\series bold
reaction site
\series default
, i.e.
\begin_inset space ~
\end_inset

a virtual place where many molecules are floating around and reacting with
 each other.
 Each molecule has a chemical designation (such as 
\family typewriter
a
\family default
, 
\family typewriter
b
\family default
, 
\family typewriter
c
\family default
) and also 
\emph on
carries a value
\emph default
 of a fixed type.
 Since the 
\begin_inset Quotes eld
\end_inset

chemistry
\begin_inset Quotes erd
\end_inset

 here is completely imaginary, the programmer is free to declare any number
 of chemical designations and to choose the corresponding value types.
 In 
\family typewriter
Chymyst
\family default
, these declarations have the form
\begin_inset Formula 
\begin{align*}
\text{\texttt{val c }} & \text{\texttt{= m[List[Int]]}}\\
\text{\texttt{val t }} & \text{\texttt{= m[Unit]}}
\end{align*}

\end_inset

and result in creating new 
\series bold
molecule emitters
\series default
 
\family typewriter
c
\family default
 and 
\family typewriter
t
\family default
.
 Emitters can be seen as functions that are called in order to 
\series bold
emit
\series default
 the corresponding molecules into the reaction site:
\begin_inset Formula 
\begin{align*}
 & \text{\texttt{c(List(1,2,3))}}\\
 & \text{\texttt{t()}}
\end{align*}

\end_inset

The newly emitted molecules will carry the specified values of the correct
 types since the emitters are statically typed.
\end_layout

\begin_layout Standard
Further, the programmer defines the 
\begin_inset Quotes eld
\end_inset

chemical laws
\begin_inset Quotes erd
\end_inset

 describing the permitted reactions between molecules.
 For reactions, 
\family typewriter
Chymyst
\family default
 uses the syntax of Scala partial functions with a single 
\family typewriter
case
\family default
 clause, wrapped into an auxiliary method called 
\family typewriter
go()
\family default
:
\begin_inset Formula 
\[
\text{\texttt{go \{ case t(\_) + c(x ::~xs) \ensuremath{\Rightarrow} c(xs) \}}}
\]

\end_inset

This reaction consumes two input molecules, 
\family typewriter
t
\family default
 and 
\family typewriter
c
\family default
, and evaluates the reaction body (the Scala code in the body of the 
\family typewriter
case
\family default
 clause).
 In this example, the reaction body simply emits one output molecule, 
\family typewriter
c
\family default
, with a computed new value 
\family typewriter
xs
\family default
.
 The effect of this reaction is to compute the tail of a list.
 Due to the pattern-matching requirement, this reaction will start only
 when the molecule 
\family typewriter
c
\family default
 carries a non-empty list value.
\end_layout

\begin_layout Standard
In 
\family typewriter
Chymyst
\family default
, reaction definitions can use all features of Scala partial functions,
 including arbitrary guard conditions and pattern matching on molecule values,
 and include arbitrary Scala code within the function body.
\end_layout

\begin_layout Standard
Reactions are first-class values:
\begin_inset Formula 
\[
\text{\texttt{val r1 = go \{ case t(\_) \ensuremath{\Rightarrow} ??? \}}}
\]

\end_inset

Creating the reaction value 
\family typewriter
r1
\family default
 does not actually schedule a computation; it merely defines the available
 computation declaratively.
 In order to make the chemical machine run reactions, the programmer needs
 to create a reaction site using the 
\family typewriter
site()
\family default
 call, such as 
\family typewriter
site(r1, r2)
\family default
, which activates the reactions listed in its arguments.
 A reaction site typically includes several reactions that may be declared
 inline for brevity:
\begin_inset Formula 
\begin{align*}
\text{\texttt{site(}} & \text{\texttt{go \{ case t(\_) + c(x ::~xs) \ensuremath{\Rightarrow} c(xs) \},}}\\
 & \text{\text{\texttt{go \{ case c(Nil) }}\texttt{\ensuremath{\Rightarrow} done() \} }}\\
\text{\texttt{)}}
\end{align*}

\end_inset

Once a reaction site is created, the code can emit any number of molecules,
 such as 
\family typewriter
t
\family default
 or 
\family typewriter
c
\family default
, or molecules bound to other reaction sites.
 The chemical machine will interpret the declared 
\begin_inset Quotes eld
\end_inset

chemical laws
\begin_inset Quotes erd
\end_inset

 and start reactions whenever appropriate input molecules are available
 at each reaction site.
 According to the operational semantics of JC, any number of different reactions
 may start concurrently if sufficiently many input molecules are available.
\end_layout

\begin_layout Standard
The 
\family typewriter
Chymyst
\family default
 project embraces the chemical metaphor and its visually suggestive terminology.
 In the academic literature on JC, molecule emitters are called 
\begin_inset Quotes eld
\end_inset

channels
\begin_inset Quotes erd
\end_inset

, emitting a molecule with a value is called 
\begin_inset Quotes eld
\end_inset

sending a message on a channel
\begin_inset Quotes erd
\end_inset

, blocking molecules are 
\begin_inset Quotes eld
\end_inset

synchronous messages
\begin_inset Quotes erd
\end_inset

, reactions are 
\begin_inset Quotes eld
\end_inset

processes
\begin_inset Quotes erd
\end_inset

, and reaction sites are 
\begin_inset Quotes eld
\end_inset

join definitions.
\begin_inset Quotes erd
\end_inset

 To make the reading of the present paper easier for academic researchers,
 I use the academic terminology in what follows, except when describing
 pedagogical approaches to JC.
 
\end_layout

\begin_layout Subsubsection
Synchronous channels as shorthand for continuations
\end_layout

\begin_layout Standard
In a completely asynchronous, non-blocking programming style, a continuation
 can be used in order to simulate waiting until some concurrent computations
 are finished.
 However, using asynchronous channels with continuations is a bit cumbersome:
 The continuation function must be explicitly created as a closure and passed
 as a message value.
 Manually creating a continuation results in 
\begin_inset Quotes eld
\end_inset

scope ripping,
\begin_inset Quotes erd
\end_inset

 which disrupts the normal code flow.
 
\end_layout

\begin_layout Standard
The JoCaml implementation of JC uses synchronous channels to mitigate this
 problem.
 
\family typewriter
Chymyst
\family default
 also implements synchronous channels as a language feature.
 
\family typewriter
Chymyst's
\family default
 chosen syntax for synchronous channels resembles continuation-passing style
 and looks like this:
\begin_inset Formula 
\[
\text{\texttt{go \{ case a(x) + f(y, cont) \ensuremath{\Rightarrow} cont(x+y) \}}}
\]

\end_inset

The same process is defined in JoCaml as
\begin_inset Formula 
\[
\text{\texttt{def a(x) \& f(y) = reply x+y to f}}
\]

\end_inset

The 
\begin_inset Quotes eld
\end_inset

reply
\begin_inset Quotes erd
\end_inset

 expression can be seen to resume the continuation in the process that sent
 the 
\family typewriter
f()
\family default
 message.
 The syntax of 
\family typewriter
Chymyst
\family default
 makes this semantics more explicit.
\end_layout

\begin_layout Standard
Here is a more extended example of a 
\family typewriter
Chymyst
\family default
 process with a synchronous channel:
\begin_inset Formula 
\begin{align*}
\text{} & \text{\texttt{val f = b[Int, Int]}}\\
 & \text{\texttt{site( go \{ case f(x, cont) \ensuremath{\Rightarrow}}}\\
 & \text{\text{\texttt{ val y = ... }// compute some value}}\\
 & \text{\texttt{ cont(y) }// reply, i.e.~invoke continuation}\\
 & \text{\texttt{\} )}}\\
 & \text{\texttt{val z = f(123) }// wait for reply}
\end{align*}

\end_inset

Note that the message 
\family typewriter
f(123)
\family default
 is sent without specifying the continuation argument 
\family typewriter
cont
\family default
, which is nevertheless available in the reaction body.
 The semantics of the blocking call 
\family typewriter
f(123)
\family default
 is essentially to construct the current continuation as 
\family typewriter
cont
\family default
 and to send it to the process as a message on the channel 
\family typewriter
f
\family default
, together with the ordinary payload 
\family typewriter
123
\family default
.
 
\end_layout

\begin_layout Standard
As I will show below in Sec.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Non-linear-join-patterns"

\end_inset

, the 
\family typewriter
Chymyst
\family default
 syntax yields additional flexibility in defining synchronous processes.
\end_layout

\begin_layout Subsection
The 
\family typewriter
Chymyst
\family default
 flavor of JC
\end_layout

\begin_layout Standard
In this section, I compare the implementation of JC in 
\family typewriter
Chymyst
\family default
 to that of JoCaml and motivate the relevant design choices and enhancements.
\end_layout

\begin_layout Subsubsection
\begin_inset Quotes eld
\end_inset

Chemical
\begin_inset Quotes erd
\end_inset

 syntax
\end_layout

\begin_layout Standard
The syntax 
\begin_inset Quotes eld
\end_inset


\family typewriter
a(x) + b(y)
\family default
 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...
\begin_inset Quotes erd
\end_inset

 is reminiscent of the notation for chemical reactions.
 It is somewhat easier to read than the traditional JC syntax 
\begin_inset Quotes eld
\end_inset


\family typewriter
a(x) & b(y)
\family default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Sending a message in 
\family typewriter
Chymyst
\family default
 is implemented as a function call such as 
\begin_inset Quotes eld
\end_inset


\family typewriter
a(1)
\family default

\begin_inset Quotes erd
\end_inset

 and does not require a special keyword such as JoCaml's 
\begin_inset Quotes eld
\end_inset


\family typewriter
spawn
\family default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Explicit channel definitions
\end_layout

\begin_layout Standard
JoCaml defines new channels implicitly, as soon as a new join definition
 is written.
 Unfortunately, implicit declaration of new channels is not possible in
 
\family typewriter
Chymyst
\family default
 because Scala macros do not allow us to insert a new top-level symbol declarati
on into the code.
 So, channel declarations need to be explicit (
\begin_inset Quotes eld
\end_inset


\family typewriter
val a = m[Unit]
\family default

\begin_inset Quotes erd
\end_inset

) and written separately from process definitions.
 This is a common design in embedded DSL implementations of JC.
\end_layout

\begin_layout Standard
The separation of channel definitions from process definitions brings several
 advantages.
 One is the ability to create a user-specified number of new channels and
 to define processes for them incrementally (see Sec.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:First-class-process-definitions"

\end_inset

 below), removing the requirement to specify all processes in a join definition
 at compile time.
 Another is an increased code clarity due to the explicit labeling of blocking
 vs.
\begin_inset space ~
\end_inset

non-blocking channel types, which remains implicit in JoCaml.
\end_layout

\begin_layout Standard
A drawback of this separation is that programmers may create a new channel
 but forget to define any processes waiting on that channel.
 Sending messages to such 
\begin_inset Quotes eld
\end_inset

unbound
\begin_inset Quotes erd
\end_inset

 channels is an error that can only be detected at run time because channels
 are first-class values.
 
\family typewriter
Chymyst
\family default
 throws an exception in that case.
\end_layout

\begin_layout Subsubsection
Non-linear join patterns
\begin_inset CommandInset label
LatexCommand label
name "subsec:Non-linear-join-patterns"

\end_inset


\end_layout

\begin_layout Standard
Another enhancement is the lifting of the linearity restriction for join
 patterns.
 In 
\family typewriter
Chymyst
\family default
, a process may wait on any number of repeated channels:
\begin_inset Formula 
\[
\text{\texttt{go \{ case a(x) + a(y) + a(z) \ensuremath{\Rightarrow} a(x+y+z) \}}}
\]

\end_inset

A linear-pattern JC implementation, such as JoCaml, would require cumbersome
 auxiliary definitions to implement this functionality.
\end_layout

\begin_layout Standard
Processes may also wait on repeated 
\emph on
synchronous
\emph default
 channels.
 This last feature, together with the continuation-passing syntax for those
 channels, enables a declarative implementation of 
\series bold
synchronous rendezvous
\series default
 where two distinct users of the same channel will exchange values:
\begin_inset Formula 
\begin{align*}
 & \text{\texttt{go \{ case f(p1, reply1) + f(p2, reply2) \ensuremath{\Rightarrow}}}\\
 & \text{\texttt{ ~ ~ ~ reply2(p1); reply1(p2)}}\\
 & \text{\texttt{\}}}
\end{align*}

\end_inset

The traditional JC reply syntax (
\family typewriter
reply x to f
\family default
) does not allow users to specify the copy of 
\family typewriter
f()
\family default
 to which the reply is sent.
 JoCaml can express this behavior only at the cost of using two auxiliary
 channels and an additional process with a synchronous reply.
 
\end_layout

\begin_layout Subsubsection
First-class process definitions
\begin_inset CommandInset label
LatexCommand label
name "subsec:First-class-process-definitions"

\end_inset


\end_layout

\begin_layout Standard
Since process definitions in 
\family typewriter
Chymyst
\family default
 are first-class values, join definitions can be constructed incrementally
 at run time by aggregating a dynamically defined number of process definitions.
 For example, the well-known 
\begin_inset Quotes eld
\end_inset

dining philosophers
\begin_inset Quotes erd
\end_inset

 problem has a simple declarative solution in join calculus (see e.g.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "VarAgh2013"

\end_inset

, Sec.
\begin_inset space ~
\end_inset

5.4.3) where, however, the number of philosophers needs to be defined statically.
 In 
\family typewriter
Chymyst
\family default
, this solution can be easily extended to 
\begin_inset Formula $n$
\end_inset

 philosophers by creating 
\begin_inset Formula $n$
\end_inset

 philosopher and fork channels at run time, defining an array of 
\begin_inset Formula $n$
\end_inset

 processes for these channels, and aggregating the 
\begin_inset Formula $n$
\end_inset

 processes into a join definition.
 
\end_layout

\begin_layout Standard
A run-time dependent number of channels and processes can be defined like
 this,
\begin_inset Formula 
\begin{align*}
 & \text{\texttt{val cs = (1 to n).map(\_ \ensuremath{\Rightarrow} m[Int])}}\\
 & \text{\texttt{val rs = (1 to n).map(i \ensuremath{\Rightarrow} go \{ ... \})}}\\
 & \text{\texttt{site(rs: \_*) \textnormal{//join definition}}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Despite this, processes and channels remain immutable.
 Once a join definition has been created, is impossible to modify its constituen
t processes or to add more processes waiting on the same channels.
\end_layout

\begin_layout Subsubsection
Static code analysis
\end_layout

\begin_layout Standard
Scala's macros are used extensively in 
\family typewriter
Chymyst
\family default
 for user code analysis.
 The 
\family typewriter
go()
\family default
 macro gathers detailed compile-time information about input and output
 channels of each defined process.
 For example, the process definition
\begin_inset Formula 
\[
\text{\texttt{go \{ case t(\_) + c(x ::~xs) \ensuremath{\Rightarrow} c(xs) \}}}
\]

\end_inset

internally produces a rich information structure indicating, for instance,
 that the process waits on the channels 
\family typewriter
t
\family default
 and 
\family typewriter
c
\family default
, that the channel 
\family typewriter
t
\family default
 may have arbitrary message values while 
\family typewriter
c
\family default
 requires a pattern match, and that the process will finally send a message
 on channel 
\family typewriter
c
\family default
 but not on 
\family typewriter
t
\family default
.
\end_layout

\begin_layout Standard
Using this information, 
\family typewriter
Chymyst
\family default
 can then detect many cases of unavoidable livelock, deadlock, and non-determini
sm in user code.
 An example of unavoidable livelock is the process
\begin_inset Formula 
\[
\text{\texttt{go \{ case c(x) \ensuremath{\Rightarrow} ???; c(x + 1) \}}}
\]

\end_inset

Since the process accepts messages 
\family typewriter
c(x)
\family default
 with any value 
\family typewriter
x
\family default
, the programmer has no means of stopping the infinite loop that follows
 once a single message is sent on channel 
\family typewriter
c
\family default
.
 This 
\family typewriter
Chymyst
\family default
 code generates a 
\emph on
compile-time
\emph default
 error, with a message indicating unavoidable livelock.
\end_layout

\begin_layout Standard
Deadlocks can only happen when using synchronous channels and are harder
 to detect reliably.
 A deadlock warning is given when the process sends a synchronous message
 followed by another message that is consumed together with the synchronous
 one:
\begin_inset Formula 
\[
\text{\texttt{go \{ case c(x) + f(\_, r) \ensuremath{\Rightarrow} c(f() + 1); r(x) \}}}
\]

\end_inset

This code is suspicious because the process waits for a reply to 
\family typewriter
f()
\family default
 and 
\emph on
then
\emph default
 sends 
\family typewriter
c()
\family default
, while a reply to 
\family typewriter
f()
\family default
 happens only 
\emph on
after
\emph default
 both 
\family typewriter
f()
\family default
 and 
\family typewriter
c()
\family default
 are sent.
\end_layout

\begin_layout Standard
Unavoidable nondeterminism within a join definition occurs when one process
 waits on a subset of messages that another process is also waiting on,
 for instance
\begin_inset Formula 
\begin{align*}
\text{\texttt{site( }} & \text{\texttt{go \{ case i(\_) + c(x) \ensuremath{\Rightarrow} c(x + 1) \},}}\\
 & \text{\text{\texttt{go \{ case i(\_) }}\texttt{\ensuremath{\Rightarrow} done() \} }}\\
\text{\texttt{) }}
\end{align*}

\end_inset

If both 
\family typewriter
c()
\family default
 and 
\family typewriter
i()
\family default
 messages are present, the runtime engine has a choice of whether to run
 the first or the second process.
 The programmer has no control over this choice, since there are no conditions
 on the values of the 
\family typewriter
i()
\family default
 message.
 It is unlikely that the resulting non-determinism would be useful in any
 practical application.
 
\family typewriter
Chymyst
\family default
 assumes that this is a programmer's error and throws an exception.
 The exception is thrown at 
\begin_inset Quotes eld
\end_inset

early
\begin_inset Quotes erd
\end_inset

 run time, immediately after creating the join definition and before running
 any processes.
\end_layout

\begin_layout Standard
An additional benefit of static analysis is a performance optimization for
 processes that use pattern matching or guard conditions.
 Scala macros are used to determine whether process definitions impose any
 guard conditions on input message values.
 If not, a quicker scheduling algorithm can be used.
 Additionally, complicated guard conditions such as
\begin_inset Formula 
\[
\text{\texttt{go \{ case c(x) + d(y) if x>0 \&\& y<1 \ensuremath{\Rightarrow} ...~\}}}
\]

\end_inset

are converted into the conjuctive normal form and split between molecules
 if possible.
 For instance, the example above is converted to (pseudo-code)
\begin_inset Formula 
\[
\text{\texttt{\{ case c(x if x>0) + d(y if y<1) \ensuremath{\Rightarrow} ...~\}}}
\]

\end_inset

In many cases, this transformation allows the runtime engine to select message
 values faster, without enumerating all combinations of message values in
 a search for suitable inputs for a process.
\end_layout

\begin_layout Subsubsection
Time-outs
\end_layout

\begin_layout Standard
When a synchronous message is sent, the emitting process is blocked until
 a reply is received.
 In 
\family typewriter
Chymyst
\family default
, it is possible to specify a time-out for this blocking call: 
\begin_inset Formula 
\[
\text{\texttt{f.timeout()(2 seconds)}}
\]

\end_inset

A reaction that sends the reply can also check whether the waiting process
 received the reply value or timed out.
 This is implemented as a 
\family typewriter
Boolean
\family default
 return value from the reply emitter:
\begin_inset Formula 
\[
\text{\texttt{go \{ case f(\_,r) \ensuremath{\Rightarrow} if (r("done")) ...~\}}}
\]

\end_inset

The timeout-checking functionality may be sometimes required to avoid race
 conditions when using timeouts on synchronous channels.
\end_layout

\begin_layout Subsection
What it means to be 
\begin_inset Quotes eld
\end_inset

industry ready
\begin_inset Quotes erd
\end_inset

***
\end_layout

\begin_layout Standard
The number of available concurrent execution threads is implementation-dependent.
 
\family typewriter
Chymyst
\family default
 guarantees that reactions declared at different reaction sites will be
 scheduled concurrently, on independent threads.
\end_layout

\begin_layout Subsection
Pedagogical considerations
\end_layout

\begin_layout Standard
The choice of terminology and notation is important if we aim to explain
 an unfamiliar paradigm clearly and comprehensibly to newcomers.
 Here we again encounter difficulties when it comes to learning about join
 calculus.
 
\end_layout

\begin_layout Standard
The Wikipedia page on JC
\begin_inset Foot
status open

\begin_layout Plain Layout
 See 
\begin_inset CommandInset href
LatexCommand href
name "en.wikipedia.org/wiki/Join-calculus"
target "https://en.wikipedia.org/wiki/Join-calculus"

\end_inset

, as of December 2016.
\end_layout

\end_inset

 describes it as 
\begin_inset Quotes eld
\end_inset


\emph on
an asynchronous 
\begin_inset Formula $\pi$
\end_inset

-calculus with several strong restrictions: 1) Scope restriction, reception,
 and replicated reception are syntactically merged into a single construct,
 the 
\emph default
definition
\emph on
; 2) Communication occurs only on defined names; 3) For every defined name
 there is exactly one replicated reception.
\emph default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Explanations using technical jargon such as 
\begin_inset Quotes eld
\end_inset

replicated reception
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

communication on defined names
\begin_inset Quotes erd
\end_inset

 are impenetrable for anyone not already well-versed in the concurrency
 research literature.
 Since Wikipedia (deservedly or not) is a popular go-to resource for learning
 new concepts, it is quite understandable that software practitioners today
 remain unaware of join calculus even 20+ years after its invention.
\end_layout

\begin_layout Standard
Another obstacle for comprehending JC is that academic literature typically
 uses terms such as “channel”, 
\begin_inset Quotes eld
\end_inset

message
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

process
\begin_inset Quotes erd
\end_inset

, which are inherited from 
\begin_inset Formula $\pi$
\end_inset

-calculus but are not helpful for understanding how JC works and how to
 write concurrent programs in it.
\end_layout

\begin_layout Standard
Indeed, a “channel” in JC holds an 
\emph on
unordered
\emph default
 collection of messages, rather than an ordered queue or mailbox, as the
 word “channel” suggests.
 Another meaning of “channel” is a persistent path for exchanging messages
 between fixed locations, but this is far from what a JC “channel” actually
 does.
\end_layout

\begin_layout Standard
The phrase “sending a message” usually implies that a fixed recipient will
 consume the sent messages one by one.
 But this is very different from what happens in JC, where a 
\begin_inset Quotes eld
\end_inset

process
\begin_inset Quotes erd
\end_inset

 may wait for several “messages” at once, different 
\begin_inset Quotes eld
\end_inset

processes
\begin_inset Quotes erd
\end_inset

 may contend on several “messages” they wait for, and several copies of
 a 
\begin_inset Quotes eld
\end_inset

process
\begin_inset Quotes erd
\end_inset

 may start concurrently, consuming their input 
\begin_inset Quotes eld
\end_inset

messages
\begin_inset Quotes erd
\end_inset

 in random order.
\end_layout

\begin_layout Standard
The word 
\begin_inset Quotes eld
\end_inset

process
\begin_inset Quotes erd
\end_inset

 suggests a fixed, persistent thread of computation with which we may communicat
e.
 However, JC does not have persistent threads of computation; instead, 
\begin_inset Quotes eld
\end_inset

processes
\begin_inset Quotes erd
\end_inset

 are spawned on demand as input 
\begin_inset Quotes eld
\end_inset

messages
\begin_inset Quotes erd
\end_inset

 become available.
\end_layout

\begin_layout Standard
While JoCaml remains today the only well-maintained standard implementation
 of JC, its developer documentation
\begin_inset Foot
status open

\begin_layout Plain Layout
 See 
\begin_inset CommandInset href
LatexCommand href
name "jocaml.inria.fr/doc/index.html"
target "http://jocaml.inria.fr/doc/index.html"

\end_inset

.
\end_layout

\end_inset

 is especially confusing as regards the semantics of “channels”, “messages”,
 “processes”, and 
\begin_inset Quotes eld
\end_inset

spawning
\begin_inset Quotes erd
\end_inset

.
 It is ill-suited as a pedagogical introduction either to using JoCaml or
 to join calculus.
 For example, the JoCaml manual mixes the 
\family typewriter
spawn
\family default
 keyword used for sending messages with the notion of 
\begin_inset Quotes eld
\end_inset

spawning
\begin_inset Quotes erd
\end_inset

 a new process, which has a quite different semantics in JC.
\end_layout

\begin_layout Standard
Instead of using academic JC terminology, I follow the chemical machine
 metaphor and terminology when giving tutorial presentations about 
\family typewriter
Chymyst
\family default
 programming.
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Here is a dictionary:
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Academic join calculus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Chemical machine
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Chymyst
\family default
 code example
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
message on a channel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
input molecule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
case a(123)
\family default
 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
channel or name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
molecule emitter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
val a: M[Int]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
synchronous channel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
blocking emitter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
val q: B[Unit, Int]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
process
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
reaction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
go { case a(x) + 
\family default
...

\family typewriter
 
\family default

\begin_inset Formula $\Rightarrow$
\end_inset


\family typewriter
 
\family default
...

\family typewriter
 }
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sending a message
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
emitting a molecule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
a(123)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sending a synchronous message
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
emitting a blocking molecule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
val x: Int = q()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
join definition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
reaction site
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
site(r1, r2, ...)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset

With this approach, I have had success in conveying effectively both the
 basic concepts and the subtleties of JC semantics to developers who were
 previously unfamiliar with it.
\end_layout

\begin_layout Subsection
From actors to reactions
\end_layout

\begin_layout Standard
Many Scala developers interested in concurrent programming are already familiar
 with the Actor model.
 In this subsection, I outline how the chemical machine paradigm can be
 introduced to those developers.
\end_layout

\begin_layout Standard
In the Actor model, an actor receives messages and reacts to them by running
 a computation.
 An actor-based program declares several actors, defines the computations
 for them, stores references to the actors, and starts sending messages
 to some of the actors.
 Messages are sent either synchronously or asynchronously, enabling communicatio
n between different concurrent actors.
 
\end_layout

\begin_layout Standard
The chemical machine paradigm is in certain ways similar to the Actor model.
 A chemical program also consists of concurrent processes, or 
\begin_inset Quotes eld
\end_inset

chemical actors
\begin_inset Quotes erd
\end_inset

, that communicate by sending messages.
 The chemical machine paradigm departs from the Actor model in two major
 ways: 
\end_layout

\begin_layout Enumerate
Chemical actors are automatically started and stopped; the user's code only
 sends messages and does not manipulate actor references.
\end_layout

\begin_layout Enumerate
Chemical actors may wait for a set of different messages to be received
 atomically.
\end_layout

\begin_layout Standard
If we examine these requirements and determine what should logically follow
 from them, we will arrive at the chemical machine paradigm.
\end_layout

\begin_layout Standard
The first requirement means that chemical actors are not created explicitly
 by the user's program.
 Instead, the chemical machine runtime will automatically instantiate and
 run a chemical actor whenever some process sends a relevant input message.
 A chemical actor will be automatically stopped and deleted when its computation
 is finished.
 Therefore, the user's code now does not create an instance of an actor
 but merely 
\emph on
defines the computation
\emph default
 that an auto-created actor will perform after consuming a message.
 As a consequence, chemical actors must be 
\emph on
stateless
\emph default
, and their computations must be functions of the input message values.
\end_layout

\begin_layout Standard
Implementing this functionality will allow us to write pseudo-code like
 this,
\begin_inset Formula 
\begin{align*}
\text{} & \texttt{val c1 }\text{\texttt{= go \{ x:~Int \ensuremath{\Rightarrow} ...~\}}}\\
 & \text{\texttt{c1 !~123 }}
\end{align*}

\end_inset

The computation labeled as 
\family typewriter
c1
\family default
 receives a message with an 
\family typewriter
Int
\family default
 value and performs some processing on it.
 The computation will be instantiated and run concurrently, whenever a message
 is sent.
 In this way, we made the first step towards the full chemical machine paradigm.
 
\end_layout

\begin_layout Standard
What should happen if we quickly send many messages? 
\begin_inset Formula 
\begin{align*}
\text{} & \texttt{val c1 }\text{\texttt{= go \{ x:~Int \ensuremath{\Rightarrow} ...~\}}}\\
 & \text{\texttt{(1 to 100).foreach(c1 !~\_) }}
\end{align*}

\end_inset

Since our computations are stateless, it is safe to run several instances
 of the computation 
\family typewriter
c1
\family default
 concurrently.
 The runtime engine may automatically adjust the degree of parallelism depending
 on CPU load.
\end_layout

\begin_layout Standard
Note that 
\family typewriter
c1
\family default
 is not a reference to a particular instance of a computation.
 Rather, the computation 
\family typewriter
{ x: Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...
 }
\family default
 is being defined 
\emph on
declaratively
\emph default
, as a description of what needs to be done with any message sent via 
\family typewriter
c1
\family default
.
 We could say that the value 
\family typewriter
c1
\family default
 plays the role of a 
\emph on
label
\emph default
 attached to the value 
\family typewriter
123
\family default
.
 The label implies that the value 
\family typewriter
123
\family default
 should be used as the input parameter 
\family typewriter
x
\family default
 in a particular computation.
 To express this semantics more clearly, let us change our pseudo-code notation
 to 
\begin_inset Formula 
\begin{align*}
\text{} & \text{\texttt{go \{ x:~Int \textnormal{from} c1 \ensuremath{\Rightarrow} ...~\}}}\\
 & \text{\texttt{c1 !~123 }}
\end{align*}

\end_inset

Different chemical actors are now distinguished only by their input message
 labels, for example:
\begin_inset Formula 
\begin{align*}
\text{} & \text{\texttt{go \{ x:~Int \textnormal{from} c1 \ensuremath{\Rightarrow} ...~\}}}\\
\text{} & \text{\texttt{go \{ x:~Int \textnormal{from} d1 \ensuremath{\Rightarrow} ...~\}}}\\
 & \text{\texttt{c1 !~123 }}\\
 & \text{\texttt{d1 !~456 }}
\end{align*}

\end_inset

Actor references have disappeared from the code.
 Instead, input message labels such as 
\family typewriter
c1
\family default
, 
\family typewriter
d1
\family default
 select the computation that will be started.
\end_layout

\begin_layout Standard
The second requirement means that a chemical actor should be able to wait
 for, say, two messages at once, allowing us to write pseudo-code like this,
 
\begin_inset Formula 
\begin{align*}
\text{} & \text{\texttt{go \{ x:~Int \textnormal{from} c1, y:~String \textnormal{from} c2 \ensuremath{\Rightarrow} ...~\}}}\\
 & \text{\texttt{c1 !~123}}\\
 & \text{\texttt{c2 !~"abc"}}
\end{align*}

\end_inset

The two messages are of different types and are labeled by 
\family typewriter
c1
\family default
 and 
\family typewriter
c2
\family default
 respectively.
 The computation starts only after 
\emph on
both
\emph default
 messages have been sent, and consumes both messages atomically.
\end_layout

\begin_layout Standard
It follows that messages cannot be sent to a linearly ordered queue or a
 mailbox.
 Instead, messages must be kept in an unordered bag, as they will be consumed
 in an unknown order.
\end_layout

\begin_layout Standard
It also follows from the atomicity requirement that we may define several
 computations that 
\emph on
jointly contend
\emph default
 on input messages:
\begin_inset Formula 
\begin{align*}
\text{} & \text{\texttt{go \{ x:~Int \textnormal{from} c1, y:~String \textnormal{from} c2 \ensuremath{\Rightarrow} ...~\}}}\\
 & \text{\texttt{go \{ x:~Int \textnormal{from} c1, z:~Unit \textnormal{from} e1 \ensuremath{\Rightarrow} ...~\}}}
\end{align*}

\end_inset

Messages that carry data are now completely decoupled from computations
 that consume the data.
 All computations start concurrently whenever their input messages become
 available.
 The runtime engine needs to resolve message contention by making a non-determin
istic choice of the messages that will be actually consumed.
 Among the several contending computations, only one will be actually started.
\end_layout

\begin_layout Standard
This concludes the second and final step towards the chemical machine paradigm.
 It remains to use the Scala syntax instead of pseudo-code.
\end_layout

\begin_layout Standard
In Scala, we need to declare message types explicitly and to register chemical
 computations with the runtime engine as a separate step.
 The syntax used by 
\family typewriter
Chymyst
\family default
 looks like this:
\begin_inset Formula 
\begin{align*}
\text{} & \text{\texttt{val c1 = m[Int]}}\\
 & \text{\texttt{val c2 = m[String]}}\\
 & \text{\texttt{site(go \{ case c1(x) + c2(y) \ensuremath{\Rightarrow} ...~\})}}\\
 & \text{\texttt{c1(123); }\texttt{c2("abc")}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
As we have just seen, the chemical machine paradigm is a radical departure
 from the Actor model:
\end_layout

\begin_layout Itemize
Whenever there are sufficiently many input messages available for processing,
 the runtime engine may automatically instantiate several concurrent copies
 of the same computation that will consume the input messages concurrently.
 This is the main method for achieving parallelism in the chemical paradigm.
 The runtime engine is in the best position to optimize the CPU load using
 low-level OS threads.
 The application code does not need to decide how many concurrent actors
 to instantiate at any given time.
 
\end_layout

\begin_layout Itemize
Since chemical actors are stateless and instantiated automatically on demand,
 users do not need to implement actor lifecycle management, actor supervision
 hierarchies, backup and recovery of actors' internal state, or a special
 
\begin_inset Quotes eld
\end_inset

dead letter
\begin_inset Quotes erd
\end_inset

 actor.
 This removes a significant amount of complexity from the architecture of
 concurrent applications.
\end_layout

\begin_layout Itemize
Input message contention is used in the chemical machine paradigm as a general
 mechanism for synchronization and mutual exclusion.
 (In the Actor model, these features are implemented by creating a fixed
 number of actor 
\emph on
instances
\emph default
 that alone can consume certain messages.) Since the runtime engine will
 arbitrarily decide which actor to run, input contention will result in
 nondeterminism.
 This is quite similar to the nondeterminism in the usual models of concurrent
 programming.
 For example, mutual exclusion allows the programmer to implement safe exclusive
 access to a resource for any number of concurrent processes, but the order
 of access among the contending processes remains unspecified.
\end_layout

\begin_layout Standard
In the chemical machine paradigm, 
\begin_inset Quotes eld
\end_inset

chemical actor
\begin_inset Quotes erd
\end_inset

 computations are called 
\series bold
reactions
\series default
, their input messages are 
\series bold
input molecules
\series default
, messages sent by a chemical computation are 
\series bold
output molecules
\series default
 of the reaction, while input message labels are 
\series bold
molecule emitters
\series default
.
\end_layout

\begin_layout Standard
In the academic literature, chemical computations are called 
\begin_inset Quotes eld
\end_inset

processes
\begin_inset Quotes erd
\end_inset

 and input message labels are 
\begin_inset Quotes eld
\end_inset

channels
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

channel names
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Future roadmap
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "chymyst_paper"
options "acm"

\end_inset


\end_layout

\end_body
\end_document
