%% LyX 2.0.6 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english,hyperref]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true,
 linkcolor=black,urlcolor=blue}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true,
 linkcolor=black,urlcolor=blue}
\fi

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 % this default might be overridden by plain title style
 \newcommand\makebeamertitle{\frame{\maketitle}}%
 \AtBeginDocument{
   \let\origtableofcontents=\tableofcontents
   \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
   \def\gobbletableofcontents#1{\origtableofcontents}
 }
 \long\def\lyxframe#1{\@lyxframe#1\@lyxframestop}%
 \def\@lyxframe{\@ifnextchar<{\@@lyxframe}{\@@lyxframe<*>}}%
 \def\@@lyxframe<#1>{\@ifnextchar[{\@@@lyxframe<#1>}{\@@@lyxframe<#1>[]}}
 \def\@@@lyxframe<#1>[{\@ifnextchar<{\@@@@@lyxframe<#1>[}{\@@@@lyxframe<#1>[<*>][}}
 \def\@@@@@lyxframe<#1>[#2]{\@ifnextchar[{\@@@@lyxframe<#1>[#2]}{\@@@@lyxframe<#1>[#2][]}}
 \long\def\@@@@lyxframe<#1>[#2][#3]#4\@lyxframestop#5\lyxframeend{%
   \frame<#1>[#2][#3]{\frametitle{#4}#5}}
 \def\lyxframeend{} % In case there is a superfluous frame end
 \newenvironment{lyxcode}
   {\par\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \setlength{\listparindent}{0pt}% needed for AMS classes
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \normalfont\ttfamily}%
    \def\{{\char`\{}
    \def\}{\char`\}}
    \def\textasciitilde{\char`\~}
    \item[]}
   {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Elm-style FRP]{Elm-style Functional Reactive Programming demystified}
\author{Sergei Winitzki}
\date{April 13, 2015}
\institute[Versal Group Inc.]{SF Types, Theorems, and Programming Languages}

\makeatother

\begin{document}
\frame{\titlepage}


\lyxframeend{}\lyxframe{What is ``functional reactive programming''}

FRP has little to do with...
\begin{itemize}
\item multithreading, message-passing concurrency, ``actors''
\item distributed computing on massively parallel load-balanced clusters
\item ma/reduce, the ``reactive manifesto'', (\emph{insert latest fad
here})...
\end{itemize}
FRP is...
\begin{itemize}
\item \textbf{pure functions using temporal types as primitives}

\begin{itemize}
\item (temporal type $\approx$ lazy stream of events)
\end{itemize}
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{Transformational vs. reactive programs}

\begin{center}
\begin{tabular}{|c|c|}
\hline 
\textbf{Transformational} programs & \textbf{Reactive} programs\tabularnewline
\hline 
\hline 
\textbf{example}: \texttt{\textcolor{blue}{\footnotesize{pdflatex
elm\_talk.tex}}} & \textbf{example}: any GUI program, OS\tabularnewline
\hline 
start, run, then stop & keep running indefinitely\tabularnewline
\hline 
read some input, write some output & wait for signals, send messages \tabularnewline
\hline 
\textbf{execution:} sequential, parallel & ``main run loop'' + concurrency\tabularnewline
\hline 
\textbf{difficulty:} algorithms & signal/response sequences\tabularnewline
\hline 
\textbf{specification:} classical logic? & classical temporal logic?\tabularnewline
\hline 
\textbf{verification:} proof of correctness? & model checking?\tabularnewline
\hline 
\textbf{synthesis:} extract code from proof? & temporal logic synthesis? \tabularnewline
\hline 
\textbf{type theory:} intuitionistic logic & intuitionistic \emph{temporal} logic\tabularnewline
\hline 
\end{tabular}
\par\end{center}


\lyxframeend{}


\lyxframeend{}\lyxframe{Difficulties in reactive programming}
\begin{itemize}
\item Input signals may come at unpredictable times

\begin{itemize}
\item Imperative updates are difficult to keep in the correct order
\item Flow of events becomes difficult to understand
\end{itemize}
\item Asynchronous (out-of-order) callback logic becomes opaque
\item Inverted control (``the system will call you'') obscures the flow
of data
\item Some concurrency is usually required (e.g.~background tasks)

\begin{itemize}
\item Explicit multithreaded code is hard to write and debug
\end{itemize}
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{Motivation for FRP}
\begin{itemize}
\item Reactive programs work on \textbf{infinite sequences} of input/output
values
\item Main idea: make infinite sequences implicit, as a new ``temporal''
type

\begin{itemize}
\item (Elm) \texttt{Signal} $\alpha$ --- an infinite sequence of values
of type $\alpha$
\item alternatively, a value of type $\alpha$ that ``changes with time''
\end{itemize}
\item Reactive programs are \textbf{pure functions}

\begin{itemize}
\item a GUI is a pure function of type \texttt{Signal} \texttt{Inputs} $\rightarrow$
\texttt{Signal} \texttt{View} 
\item a Web server is a pure function \texttt{Signal} \texttt{Request} $\rightarrow$
\texttt{Signal} \texttt{Response} 
\item all mutation is \textbf{implicit} in \texttt{Signal} $\alpha$; our
code is 100\% immutable

\begin{itemize}
\item instead of updating an \texttt{x:Int}, we define a value of type \texttt{Signal}
\texttt{Int}
\end{itemize}
\item asynchronous behavior is \textbf{implicit}: our code has no callbacks
\item concurrency / parallelism is \textbf{implicit}

\begin{itemize}
\item the runtime needs to provide the required scheduling of events
\end{itemize}
\end{itemize}
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{\texttt{Elm} in a nutshell}
\begin{itemize}
\item \texttt{Elm} is a pure polymorphic $\lambda$-calculus with products
and sums
\item \textbf{Temporal type} $\Sigma\alpha$ --- a time-dependent value
of \textbf{ordinary} type $\alpha$
\item Temporal primitive terms: \end{itemize}
\begin{lyxcode}
constant:~$\alpha\rightarrow\Sigma\alpha$

map2:~$(\alpha\rightarrow\beta\rightarrow\gamma)\rightarrow\Sigma\alpha\rightarrow\Sigma\beta\rightarrow\Sigma\gamma$

foldp:~\textrm{$\left(\alpha\rightarrow\beta\rightarrow\beta\right)\rightarrow\beta\rightarrow\Sigma\alpha\rightarrow\Sigma\beta$}

drop:~$(\alpha\rightarrow\mbox{Bool})\rightarrow\Sigma\alpha\rightarrow\Sigma\alpha$

async:~$\Sigma\alpha\rightarrow\Sigma\alpha$\end{lyxcode}
\begin{itemize}
\item \textbf{No nested} temporal types: \texttt{constant (constant x)}
is illegal!
\item Domain-specific primitive types: \texttt{Bool}, \texttt{Int}, \texttt{Float},
\texttt{String}, \texttt{View}
\item Standard library with data structures, HTML, HTTP, JSON, ...

\begin{itemize}
\item ... \texttt{Time.every}, \texttt{Mouse.position}, \texttt{Window.dimensions},
...
\end{itemize}
\item Try \texttt{Elm} online at \href{http://elm-lang.org/try}{http://elm-lang.org/try}
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{\texttt{Elm} type judgments}
\begin{itemize}
\item Non-temporal expressions are evaluated \textbf{eagerly} in pure$\lambda$-calculus
\item The runtime will cache all values to avoid recomputation
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{\texttt{Elm} operational semantics}
\begin{itemize}
\item Non-temporal expressions are evaluated \textbf{eagerly} in pure$\lambda$-calculus
\item The runtime will cache all values to avoid recomputation
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{``Hello, world'' in \texttt{Elm} }
\begin{itemize}
\item The value called \texttt{\textbf{main}} will be visualized by the
runtime\end{itemize}
\begin{lyxcode}
import~Graphics.Element~(..)~

import~Text~(..)~

import~Signal~(..)

~~

text~:~Element

text~=~plainText~\textquotedbl{}Hello,~World!\textquotedbl{}

~~

main~:~Signal~Element~

main~=~constant~text
\end{lyxcode}

\lyxframeend{}


\lyxframeend{}\lyxframe{Typical program structure in \texttt{Elm} }
\begin{itemize}
\item A state machine:\end{itemize}
\begin{lyxcode}
update:~Command~$\rightarrow$~State~$\rightarrow$~State\end{lyxcode}
\begin{itemize}
\item A rendering function:\end{itemize}
\begin{lyxcode}
draw:~State~$\rightarrow$~View\end{lyxcode}
\begin{itemize}
\item A manager that merges the required input signals into one:

\begin{itemize}
\item may use \texttt{Mouse}, \texttt{Keyboard}, \texttt{Time}, \texttt{HTML}
stuff, etc.
\end{itemize}
\end{itemize}
\begin{lyxcode}
merge\_inputs:~Signal~Command\end{lyxcode}
\begin{itemize}
\item Program boilerplate:\end{itemize}
\begin{lyxcode}
init\_state~:~State

main~:~Signal~View

main~=~map~draw~\$~foldp~update~init\_state~merge\_inputs~
\end{lyxcode}

\lyxframeend{}


\lyxframeend{}\lyxframe{Asynchrony and concurrency in \texttt{Elm}}
\begin{itemize}
\item Long-running computations will delay signal updates
\item Solutions: 1. Caching of all results. 2. Use \texttt{async} 
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{Some limitations of \texttt{Elm}-style FRP}
\begin{itemize}
\item No recursion of any kind
\item No higher-order signals: $\Sigma(\Sigma\alpha)$ is disallowed by
the type system
\item No distinction between continuous time and discrete time
\item The signal processing logic is fully specified statically
\item No constructors for signals
\item Impossible to implement the ``dining philosophers''!
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{\texttt{Elm} cannot do ``dining philosophers''}
\begin{itemize}
\item ``Dining philosophers'' requires to model a philosopher who thinks
for a random time and then eats for a random time
\item Can Elm construct a signal value \texttt{p} \texttt{:} \texttt{Signal}
\texttt{Unit} that updates at random times? 

\begin{itemize}
\item No! There is no way to delay the update times of a signal \textbf{at
runtime}.
\item \texttt{Time.delay:} \texttt{Int}$\rightarrow\Sigma\alpha\rightarrow\Sigma\alpha$
cannot use a time-varying delay value 
\item \texttt{Time.every:} \texttt{Int}$\rightarrow\Sigma$\texttt{Int}
also requires a fixed delay value
\item Cannot lift \texttt{Time.every} into \texttt{$\Sigma$Int}$\rightarrow\Sigma\Sigma$\texttt{Int}
to achieve variable delay
\end{itemize}
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{Limitations of the JavaScript backend for \texttt{Elm}}
\begin{itemize}
\item No implementation for \texttt{async}
\item Ordinary recursion may generate invalid JavaScript
\item The lack of recursive signals is compensated by ad hoc primitives
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{Possible extensions}
\begin{itemize}
\item Recursive definitions for signals
\item Monadic signal combinators
\item Signal constructors
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{Part 2. Temporal logic and FRP}
\begin{itemize}
\item Reminder (Curry-Howard): temporal logic expressions will be our types
\item We only need to control the order of events: no hard real-time requirements 
\item How to understand temporal logic:

\begin{itemize}
\item classical propositional logic $\approx$ Boolean arithmetic
\item intuitionistic propositional logic $\approx$ same but without \textbf{true}
/ \textbf{false} dichotomy
\item (linear-time) temporal logic $\approx$ Boolean arithmetic for \emph{infinite
sequences}
\item intuitionistic temporal logic $\approx$ same but without \textbf{true}
/ \textbf{false} dichotomy
\end{itemize}
\item In other words:

\begin{itemize}
\item a temporal type represents a \textbf{single infinite sequence} of
values
\end{itemize}
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{Boolean arithmetic: notation}
\begin{itemize}
\item Classical propositional (Boolean) logic: $T$, $F$, $a\vee b$, $a\wedge b$,
$\neg a$, $a\rightarrow b$
\item A notation better adapted to school-level arithmetic: $1$, $0$,
$a+b$, $ab$, $a'$
\item The only ``new rule'' is $1+1=1$
\item Define $a\rightarrow b=a'+b$
\item Some identities: 
\begin{align*}
0a=0,\quad1a=a, & \quad a+0=a,\quad a+1=1,\\
a+a=a,\quad aa=a, & \quad a+a'=1,\quad aa'=0,\\
\left(a+b\right)'=a'b', & \quad\left(ab\right)'=a'+b',\quad\left(a'\right)'=a\\
a\left(b+c\right)=ab+ac, & \quad\left(a+b\right)\left(a+c\right)=a+bc
\end{align*}
 
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{Boolean arithmetic: example}

\textcolor{blue}{\emph{Of the three suspects $A$, $B$, $C$, only
one is guilty of a crime. }}

\textcolor{blue}{\emph{Suspect $A$ says: ``$B$ did it''. Suspect
$B$ says: ``$C$ is innocent.''}}

\textcolor{blue}{\emph{The guilty one is lying, the innocent ones
tell the truth.}}
\[
\phi=\left(ab'c'+a'bc'+a'b'c\right)\left(a'b+ab'\right)\left(b'c'+bc\right)
\]
\textbf{Simplify}: expand the brackets, omit $aa'$, $bb'$, $cc'$,
replace $aa=a$ etc.:
\[
\phi=ab'c'+0+0=ab'c'
\]


\textcolor{blue}{The guilty one is $A$.}


\lyxframeend{}


\lyxframeend{}\lyxframe{Propositional linear-time temporal logic (LTL)}
\begin{itemize}
\item We work with\emph{ infinite boolean sequences} (``linear time'')\\
\textbf{Boolean} operations:
\begin{align*}
a & =\left[a_{0},a_{1},a_{2},...\right];\quad b=\left[b_{0},b_{1},b_{2},...\right];\\
a+b & =\left[a_{0}+b_{0},a_{1}+b_{1},...\right];\; a'=\left[a_{0}^{\prime},a_{1}^{\prime},...\right];\; ab=\left[a_{0}b_{0},a_{1}b_{1},...\right]
\end{align*}
\textbf{Temporal} operations:
\begin{align*}
\mbox{(Next)}\quad\mathbf{N}a & =\left[a_{1},a_{2},...\right]\\
\mbox{(Sometimes)}\quad\mathbf{F}a & =\left[a_{0}+a_{1}+a_{2}+...,\ a_{1}+a_{2}+...,\ ...\right]\\
\mbox{(Always)}\quad\mathbf{G}a & =\left[a_{0}a_{1}a_{2}a_{3}...,\ a_{1}a_{2}a_{3}...,\ a_{2}a_{3}...,\ ...\right]
\end{align*}
Other notation (from modal logic):
\[
\mathbf{N}a\equiv\bigcirc a;\;\mathbf{F}a\equiv\lozenge a;\;\mathbf{G}a\equiv\square a
\]

\item Weak Until: $p\mathbf{U}q$ = ``$p$ holds from now on until $q$
first becomes true''
\[
p\mathbf{U}q=q+p\mathbf{N}\left(q+p\mathbf{N}\left(q+...\right)\right)
\]

\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{Temporal logic redux}
\begin{itemize}
\item LTL as type theory: do we use $\mathbf{N}\alpha$, $\mathbf{F}\alpha$,
$\mathbf{G}\alpha$ as new types?
\item Are they to be functors, monads, ...?
\item What is the operational semantics? (I.e., how to compile this?)
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{Interpreting values typed by LTL}
\begin{itemize}
\item What does it mean to have a value $x$ of type, say, $\mathbf{G}(\alpha\rightarrow\alpha\mathbf{U}\beta)$
??

\begin{itemize}
\item $x:\mathbf{N}\alpha$ means that $x:\alpha$ will be available \emph{only}
at the \emph{next} time tick \\
($x$ is a \textbf{deferred value} of type $\alpha$)
\item $x:\mathbf{F}\alpha$ means that $x:\alpha$ will be available at
\emph{some} future tick(s)\\
($x$ is an \textbf{event} of type $\alpha$)
\item $x:\mathbf{G\alpha}$ means that a (different) value $x:\alpha$ is
available at \emph{every} tick\\
($x$ is an \textbf{infinite stream} of type $\alpha$)
\item $x:\alpha\mathbf{U}\beta$ means a \textbf{finite stream} of $\alpha$
that may end with a $\beta$ 
\end{itemize}
\item Some \emph{temporal axioms} of intuitionistic LTL:
\begin{align*}
\mbox{(deferred apply)}\quad\mathbf{N}\left(\alpha\rightarrow\beta\right) & \rightarrow\left(\mathbf{N}\alpha\rightarrow\mathbf{N}\beta\right);\\
\mathbf{\mbox{(streamed apply)}\quad G}\left(\alpha\rightarrow\beta\right) & \rightarrow\left(\mathbf{G}\alpha\rightarrow\mathbf{G}\beta\right);\\
\mbox{(generate a stream)}\quad\mathbf{G}\left(\alpha\rightarrow\mathbf{N}\alpha\right) & \rightarrow\left(\alpha\rightarrow\mathbf{G}\alpha\right);\\
\mbox{(read infinite stream)}\quad\mathbf{G}\alpha & \rightarrow\alpha\mathbf{N}(\mathbf{G}\alpha)\\
\mbox{(read finite stream)}\quad\alpha\mathbf{U}\beta & \rightarrow\beta+\alpha\mathbf{N}(\alpha\mathbf{U}\beta)
\end{align*}

\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{\texttt{Elm} as an FRP language }
\begin{itemize}
\item $\lambda$-calculus with type $\mathbf{G}\alpha$, primitives \texttt{map2},
\texttt{foldp}, \texttt{async} \end{itemize}
\begin{lyxcode}
map2~:~$\left(\alpha\rightarrow\beta\rightarrow\gamma\right)\rightarrow\mathbf{G}\alpha\rightarrow\mathbf{G}\beta\rightarrow\mathbf{G}\gamma$

foldp~:~$\left(\alpha\rightarrow\beta\rightarrow\beta\right)\rightarrow\beta\rightarrow\mathbf{G}\alpha\rightarrow\mathbf{G}\beta$

async~:~$\mathbf{G}\alpha\rightarrow\mathbf{G}\alpha$\end{lyxcode}
\begin{itemize}
\item (\texttt{map2} makes $\mathbf{G}$ an applicative functor)
\item \texttt{async} is a special \emph{scheduling} \emph{instruction}
\item Limitations:

\begin{itemize}
\item Cannot have a type $\mathbf{G}(\mathbf{G}\alpha)$, also not using
$\mathbf{N}$ or $\mathbf{F}$
\item Cannot construct temporal values by hand
\item This language is an \emph{incomplete} Curry-Howard image of LTL!
\item \textcolor{blue}{\emph{I work after the boss comes by and until the
phone rings}}: \\
$\quad$\texttt{let after\_until w (b,r) = (w or b) and not r in }\\
$\quad\quad$\texttt{foldp after\_until false (boss, phone)}
\end{itemize}
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{Conclusions and outlook}
\begin{itemize}
\item There are some languages that implement FRP in various \emph{ad hoc}
ways
\item The ideal is not (yet) reached
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{Conclusions and outlook}
\begin{itemize}
\item The ideal is not (yet) reached
\end{itemize}

\lyxframeend{}


\lyxframeend{}\lyxframe{Abstract}

In my day job, most bugs come from imperatively implemented reactive
programs. FRP is a declarative approach that promises to solve my
problems. \medskip{}


FRP can be defined as a $\lambda$-calculus with types given by a
propositional intuitionistic linear-time temporal logic (LTL). Although
the \texttt{Elm} language uses only a subset of LTL, it achieves high
expressivity for GUI programming. I discuss the current limitations
of \texttt{Elm} and outline some possible extensions. I will also
briefly review the motivations behind and the connections between
temporal logic, FRP, and \texttt{Elm}. \medskip{}


My talk will be understandable to anyone familiar with Curry-Howard
and functional programming. (The first part of the talk does not rely
on temporal logic or Curry-Howard.)


\lyxframeend{}


\lyxframeend{}\lyxframe{Suggested reading }

E. Czaplicki, S. Chong. \href{http://people.seas.harvard.edu/~chong/pubs/pldi13-elm.pdf}{Asynchronous FRP for GUIs}.
(2013) 

E. Czaplicki. \href{http://www.seas.harvard.edu/sites/default/files/files/archived/Czaplicki.pdf}{Concurrent FRP for functional GUI}
(2012). 

M. F. Dam. Lectures on temporal logic. Slides: \href{http://www.csc.kth.se/~mfd/Courses/Temporal_logic/lecture1.pdf}{Syntax and semantics of LTL},
\href{http://www.csc.kth.se/~mfd/Courses/Temporal_logic/lecture2.pdf}{A Hilbert-style proof system for LTL} 

E. Bainomugisha, et al. \href{ftp://progftp.vub.ac.be/tech_report/2012/vub-soft-tr-12-13.pdf}{A survey of reactive programming}
(2013).

W. Jeltsch. \href{http://www.ioc.ee/~wolfgang/research/plpv-2013-paper.pdf}{Temporal logic with Until, Functional Reactive Programming with processes, and concrete process categories.}
(2013).

A. Jeffrey. \href{http://ect.bell-labs.com/who/ajeffrey/papers/plpv12.pdf}{LTL types FRP.}
(2012).

D. Marchignoli. \href{http://phd.di.unipi.it/Theses/PhDthesis_Marchignoli.pdf}{Natural deduction systems for temporal logic.}
(2002). -- See Chapter 2 for a natural deduction system for modal
and temporal logics. 


\lyxframeend{}
\end{document}
