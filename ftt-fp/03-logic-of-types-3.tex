%% LyX 2.2.0 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{amsmath}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 % this default might be overridden by plain title style
 \newcommand\makebeamertitle{\frame{\maketitle}}%
 % (ERT) argument for the TOC
 \AtBeginDocument{%
   \let\origtableofcontents=\tableofcontents
   \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
   \def\gobbletableofcontents#1{\origtableofcontents}
 }
 \newenvironment{lyxcode}
   {\par\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \setlength{\listparindent}{0pt}% needed for AMS classes
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \normalfont\ttfamily}%
    \def\{{\char`\{}
    \def\}{\char`\}}
    \def\textasciitilde{\char`\~}
    \item[]}
   {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 3: Logic of Types III]{Chapter 3: The Logic of Types, Part III}
\subtitle{The Curry-Howard correspondence}
\author{Sergei Winitzki}
\date{December 16, 2017}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{navigation symbols}{}

\makeatother

\begin{document}
\frame{\titlepage}
\begin{frame}{Types and propositional logic}


\framesubtitle{The Curry-Howard correspondence}

The code \texttt{\textcolor{blue}{\footnotesize{}val x:\ T =}} ...
shows that \emph{we can compute a value} of type \texttt{\textcolor{blue}{\footnotesize{}T}}
as part of our program expression
\begin{itemize}
\item Let's denote this \emph{proposition} by ${\cal CH}(T)$ \textendash{}
``$\mathcal{C}$ode $\mathcal{H}$as a value of type \texttt{\textcolor{blue}{\footnotesize{}T}}''
\item We have the following correspondence between types and propositions:
\end{itemize}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{Type} & \textbf{Proposition} & \textbf{Short notation}\tabularnewline
\hline 
\hline 
\texttt{\textcolor{blue}{\footnotesize{}T}} & ${\cal CH}(T)$ & $T$\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}(A, B)}} & ${\cal CH}(A)$ \emph{and} ${\cal CH}(B)$ & $A\times B$\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}Either{[}A, B{]}}} & ${\cal CH}(A)$ \emph{or} ${\cal CH}(B)$ & $A+B$\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}A $\Rightarrow$ B}} & ${\cal CH}(A)$ \emph{implies} ${\cal CH}(B)$ & $A\Rightarrow B$\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}Unit}} & \emph{true} & 1\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}Nothing}} & \emph{false} & 0\tabularnewline
\hline 
\end{tabular}
\par\end{center}
\begin{itemize}
\item type parameter \texttt{\textcolor{blue}{\footnotesize{}{[}T{]}}} in
a function type means $\forall T$, for example the type of the function
\texttt{\textcolor{blue}{\footnotesize{}def dupl{[}A{]}:\ A $\Rightarrow$
(A, A)}} corresponds to the (valid) proposition $\forall A:A\Rightarrow A\times A$
\end{itemize}
\end{frame}

\begin{frame}{Working with the CH correspondence I}


\framesubtitle{Convert Scala types to short notation and back}
\begin{itemize}
\item Example 1: A disjunction type
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~UserAction}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}case~class~SetName(first:~String,~last:~String)~extends~UserAction}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}case~class~SetEmail(email:~String)~extends~UserAction}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}case~class~SetUserId(id:~Long)~extends~UserAction}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Short notation: \texttt{\textcolor{blue}{\footnotesize{}UserAction}}
$=$ \texttt{\textcolor{blue}{\footnotesize{}String}} $\times$ \texttt{\textcolor{blue}{\footnotesize{}String
$+$}} \texttt{\textcolor{blue}{\footnotesize{}String}} \texttt{\textcolor{blue}{\footnotesize{}$+$}}
\texttt{\textcolor{blue}{\footnotesize{}Long}}{\footnotesize \par}
\item Example 2: A parameterized disjunction type
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Either3{[}A,~B,~C{]}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}case~class~Left{[}A,~B,~C{]}(x:~A~$\Rightarrow$~C)~extends~Either3{[}A,~B,~C{]}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}case~class~Middle{[}A,~B,~C{]}(x:~B)~extends~Either3{[}A,~B,~C{]}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}case~class~Right{[}A,~B,~C{]}(x:~C~$\Rightarrow$~A)~extends~Either3{[}A,~B,~C{]}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Short notation: $\forall A\forall B\forall C:$ $(A\Rightarrow B)+B+(C\Rightarrow A)$
\end{itemize}
\end{frame}

\begin{frame}{Working with the CH correspondence II}

\begin{itemize}
\item Any valid formula can be implemented in code\\
~

\begin{tabular}{|c|c|}
\hline 
\textbf{Proposition} & \textbf{Code}\tabularnewline
\hline 
\hline 
$\forall A:A\Rightarrow A$ & \texttt{\textcolor{blue}{\footnotesize{}def identity{[}A{]}(x:A):A
= x}}\tabularnewline
\hline 
$\forall A:A\Rightarrow1$ & \texttt{\textcolor{blue}{\footnotesize{}def toUnit{[}A{]}(x:A): Unit
= ()}}\tabularnewline
\hline 
$\forall A\forall B:A\Rightarrow A+B$ & \texttt{\textcolor{blue}{\footnotesize{}def inLeft{[}A,B{]}(x:A):\ Either{[}A,B{]}
= Left(x)}}\tabularnewline
\hline 
$\forall A\forall B:A\times B\Rightarrow A$ & \texttt{\textcolor{blue}{\footnotesize{}def first{[}A,B{]}(p:(A,B)):A
= p.\_1}}\tabularnewline
\hline 
$\forall A\forall B:A\Rightarrow(B\Rightarrow A)$ & \texttt{\textcolor{blue}{\footnotesize{}def const{[}A,B{]}(x:A):B$\Rightarrow$A
= (y:B)$\Rightarrow$x}}\tabularnewline
\hline 
\end{tabular}\\
~
\item Invalid formulas \emph{cannot be implemented} in code 
\begin{itemize}
\item Examples of invalid formulas:\\
 $\forall A:1\Rightarrow A$; $\forall A\forall B:A+B\Rightarrow A$;
\\
$\forall A\forall B:A\Rightarrow A\times B$; \  $\quad\forall A\forall B:(A\Rightarrow B)\Rightarrow A$
\end{itemize}
\item Given a type's formula, can we implement it in code?
\begin{itemize}
\item Example: $\forall A\forall B:((((A\Rightarrow B)\Rightarrow A)\Rightarrow A)\Rightarrow B)\Rightarrow B$
\end{itemize}
\item Constructive propositional logic has a decision algorithm
\item See code examples using the \href{https://github.com/Chymyst/curryhoward}{curryhoward}
library
\end{itemize}
\end{frame}

\begin{frame}{Working with the CH correspondence III}


\framesubtitle{Using known properties of propositional logic and arithmetic}

Are $A+B,\:A\times B$ more like logic or like arithmetic?
\begin{itemize}
\item Some standard identities in logic ($\forall A\forall B\forall C$
is assumed):
\begin{align*}
A\times1=A; & \quad A+1=1\\
(A\times B)\times C & =A\times(B\times C)\\
(A+B)+C & =A+(B+C)\\
A\times(B+C) & =(A\times B)+(A\times C)\\
A+(B\times C) & =(A+B)\times(A+C)\\
(A\times B)\Rightarrow C & =A\Rightarrow(B\Rightarrow C)\\
A\Rightarrow(B\times C) & =(A\Rightarrow B)\times(A\Rightarrow C)\\
(A+B)\Rightarrow C & =(A\Rightarrow C)\times(B\Rightarrow C)
\end{align*}
\item Each identity means 2 function types: ``$X=Y$'' is $X\Rightarrow Y$,
$Y\Rightarrow X$
\begin{itemize}
\item Do these functions convert values between the types $X$ and $Y$?
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Type isomorphisms I}

\begin{itemize}
\item Types $A$ and $B$ are isomorphic, $A\equiv B$, if there is a 1-to-1
correspondence between all values of these types. Formally, this requires
us to find two functions $f:A\Rightarrow B$ and $g:B\Rightarrow A$
such that $f\circ g=id$ and $g\circ f=id$
\end{itemize}
Example 1: Is $\forall A:A\times1\equiv A$? Types in Scala: \texttt{\textcolor{blue}{\footnotesize{}(A,
Unit)}} and \texttt{\textcolor{blue}{\footnotesize{}A}}{\footnotesize \par}
\begin{itemize}
\item Two functions with types $\forall A:A\times1\Rightarrow A$ and $\forall A:A\Rightarrow A\times1$:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~f1{[}A{]}:~((A,~Unit))~$\Rightarrow$~A~=~\{~case~(a,~())~$\Rightarrow$~a~\}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}def~f2{[}A{]}:~A~$\Rightarrow$~((A,~Unit))~=~a~$\Rightarrow$~(a,~())}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Verify that their compositions equal $id$ (see test code)
\end{itemize}
Example 2: Is $\forall A:A+1\equiv1$? Types in Scala: \texttt{\textcolor{blue}{\footnotesize{}Option{[}A{]}}}
and \texttt{\textcolor{blue}{\footnotesize{}Unit}}{\footnotesize \par}
\begin{itemize}
\item These types are \emph{not} isomorhic
\end{itemize}
\emph{Some} of the logic identities yield\emph{ }isomorphisms of types
\begin{itemize}
\item Which ones \emph{do} \emph{not} yield isomorphisms, and why?
\end{itemize}
\end{frame}

\begin{frame}{Type isomorphisms II}


\framesubtitle{Verifying a type isomorphism}
\begin{itemize}
\item Need to verify that $f_{1}\circ f_{2}=id$ and $f_{2}\circ f_{1}=id$
\end{itemize}
Example 3: $\forall A\forall B\forall C:(A\times B)\Rightarrow C\equiv(A\Rightarrow C)\times(B\Rightarrow C)$
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~f1{[}A,B,C{]}:~((A,~B)~$\Rightarrow$~C)~$\Rightarrow$~(A~$\Rightarrow$~C,~B~$\Rightarrow$~C)~=~...}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}def~f2{[}A,B,C{]}:~((A~$\Rightarrow$~C,~B~$\Rightarrow$~C))~$\Rightarrow$~((A,~B))~$\Rightarrow$~C~=~...}{\footnotesize \par}
\end{lyxcode}
Example 4: $\forall A\forall B\forall C:(A\times B)\times C\equiv A\times(B\times C)$
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~g1{[}A,B,C{]}:~(((A,~B),~C))~$\Rightarrow$~(A,~(B,~C))~=~...}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}def~g2{[}A,B,C{]}:~((A,~(B,~C)))~$\Rightarrow$~((A,~B),~C)~=~...}{\footnotesize \par}
\end{lyxcode}
Example 5: $\forall A\forall B\forall C:A\times(B+C)\equiv(A\times B)+(A\times C)$
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~h1{[}A,B,C{]}:~((A,~Either{[}B,~C{]}))~$\Rightarrow$~Either{[}(A,~B),~(A,~C){]}~=~...}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}def~h2{[}A,B,C{]}:~Either{[}(A,~B),~(A,~C){]}~$\Rightarrow$~(A,~Either{[}B,~C{]})~=~...}{\footnotesize \par}
\end{lyxcode}
Example 6: (This is not $\equiv$!) $\forall A\forall B\forall C:A+(B\times C)=(A+B)\times(A+C)$
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~j1{[}A,B,C{]}:~Either{[}A,~(B,~C){]}~$\Rightarrow$~(Either{[}A,B{]},~Either{[}A,C{]})~=~...}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}def~j2{[}A,B,C{]}:((Either{[}A,B{]},~Either{[}A,C{]}))~$\Rightarrow$~Either{[}A,~(B,C){]}~=~...}{\footnotesize \par}
\end{lyxcode}
\end{frame}

\begin{frame}{Type isomorphisms III}


\framesubtitle{Logic CH vs.\ arithmetic CH for elementary (``algebraic'') types}
\begin{itemize}
\item WLOG, consider types $A,B,...$ that have \emph{finite} sets of possible
values
\begin{itemize}
\item Disjunction type $A+B$ (size $\left|A\right|+\left|B\right|$) provides
a disjoint union of sets
\item Tuple type $A\times B$ (size $\left|A\right|\cdot\left|B\right|$)
provides a Cartesian product of sets
\item Function type $A\Rightarrow B$ provides the set of all maps between
sets
\begin{itemize}
\item The size of $A\Rightarrow B$ is $\left|B\right|^{\left|A\right|}$
\end{itemize}
\end{itemize}
\item If the set size (cardinality) differs, $A$ and $B$ cannot be isomorphic 
\begin{itemize}
\item Only the arithmetic identities yield type isomorphisms
\item Logic identities yield only the ``equal implementability''
\end{itemize}
\end{itemize}
The meaning of the types/logic/arithmetic correspondence:
\begin{itemize}
\item Arithmetic formulas show isomorphism
\item Logic formulas show implementability
\end{itemize}
Reasoning about types is just like doing school algebra
\begin{itemize}
\item \textbf{Elementary types}: constants, sums, products, exponentials
\item \textbf{Polynomial types}: constants, sums, products
\end{itemize}
\end{frame}

\begin{frame}{Algebraic computation with recursive types}

Recursive type: ``list of integers''
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~IntList}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~object~Empty~extends~IntList}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~class~Nonempty(head:~Int,~tail:~IntList)~extends~IntList}{\footnotesize \par}
\end{lyxcode}
Parameterized recursive type: ``list of \texttt{\textcolor{blue}{\footnotesize{}T}}''
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~List{[}T{]}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~object~Nil~extends~List{[}Nothing{]}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~class~::(head:~T,~tail:~List{[}T{]})~extends~List{[}T{]}}{\footnotesize \par}
\end{lyxcode}
Short notation: (the sign ``$\equiv$'' means type isomorphism)\texttt{\textcolor{blue}{\footnotesize{}
\begin{align*}
\text{List}(t) & \equiv1+t\times\text{List}(t)\equiv1+t\times(1+t\times(1+t\times(...)...)\\
 & \equiv1+t+\left(t\times t\right)+\left(t\times t\times t\right)+...
\end{align*}
}}{\footnotesize \par}
\begin{itemize}
\item A curious analogy with calculus: $\text{List}(t)=1+t\cdot\text{List}(t)$;
``solve'' this as 
\begin{align*}
\text{List}(t) & =\frac{1}{1-t}=1+t+t^{2}+t^{3}+...
\end{align*}
\end{itemize}
\end{frame}

\begin{frame}{Worked examples}

\begin{itemize}
\item a
\item a
\end{itemize}
\end{frame}

\begin{frame}{Exercises III}

\begin{enumerate}
\item a
\end{enumerate}
\end{frame}

\begin{frame}{Working with the CH correspondence IV}


\framesubtitle{Implications for designing new programming languages}
\begin{itemize}
\item The CH correspondence maps the type system of each programming language
into a certain system of logical propositions 
\item Scala, Haskell, OCaml, F\#, Swift, Rust, etc.~are mapped into the
full constructive logic (all logical operations are available)
\begin{itemize}
\item C, C++, Java, C\#, etc.~are mapped to \emph{incomplete} \emph{logics}
\textendash{} without ``or'' and without ``true'' / ``false''
\item Python, JavaScript, Ruby, Clojure, etc.~have only one type (``any
value'') and are mapped to logics with only one proposition
\end{itemize}
\item The CH correspondence is a principle for designing type systems:
\begin{itemize}
\item Choose a complete logic, free of inconsistency
\begin{itemize}
\item Mathematicians have studied all kinds of logics and determined which
ones are interesting, and found the minimal sets of axioms for them
\item Modal logic, temporal logic, linear logic, etc.
\end{itemize}
\item Provide a type constructor for each basic operation (e.g.~``\emph{or}'',
``\emph{and}'')
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Working with the CH correspondence V}


\framesubtitle{Implications for actually writing code}

What problems can we solve now?
\begin{itemize}
\item Use the short type notation for reasoning about types
\item Given a fully parametric type, decide whether it can be implemented
in code (``type is inhabited''); if so, \emph{generate} the code
\begin{itemize}
\item The \href{http://apt13.unibe.ch/slides/Dyckhoff.pdf}{Gentzen-Vorobiev-Hudelmaier algorithm}
and its generalizations
\item See also the \href{https://github.com/Chymyst/curryhoward}{curryhoward}
project
\end{itemize}
\item Given some expression, infer the most general type it can have
\begin{itemize}
\item The \href{https://en.wikipedia.org/wiki/Hindley\%E2\%80\%93Milner_type_system}{Damas-Hindley-Milner algorithm}
(\href{http://dysphoria.net/2009/06/28/hindley-milner-type-inference-in-scala/}{Scala code})
and generalizations
\end{itemize}
\item Decide type isomorphism, simplify type formulas (the ``arithmetic
CH'')
\item Compute the necessary types before starting to write code
\end{itemize}
What problems cannot be solved with these tools?
\begin{itemize}
\item Automatically generate code satisfying properties (e.g.\ isomorphism)
\item Express complicated conditions via types (e.g.\ ``array is sorted'')
\begin{itemize}
\item Need dependent types for that (Coq, Agda, Idris, ...)
\end{itemize}
\end{itemize}
\end{frame}

\end{document}
