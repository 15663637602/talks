#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 3: Logic of Types III]{Chapter 3: The Logic of Types, Part III}
\subtitle{The Curry-Howard correspondence}
\author{Sergei Winitzki}
\date{December 16, 2017}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{navigation symbols}{}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Types and propositional logic
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
The Curry-Howard correspondence
\end_layout

\begin_layout Standard
The code 
\family typewriter
\size footnotesize
\color blue
val x:
\begin_inset space \space{}
\end_inset

T =
\family default
\size default
\color inherit
 ...
 shows that 
\emph on
we can compute a value
\emph default
 of type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 as part of our program expression
\end_layout

\begin_layout Itemize
Let's denote this 
\emph on
proposition
\emph default
 by 
\begin_inset Formula ${\cal CH}(T)$
\end_inset

 â€“ 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathcal{C}$
\end_inset

ode 
\begin_inset Formula $\mathcal{H}$
\end_inset

as a value of type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
We have the following correspondence between types and propositions:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Short notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(T)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(A, B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
and
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Either[A, B]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
or
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A+B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
implies
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\Rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Nothing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
type parameter 
\family typewriter
\size footnotesize
\color blue
[T]
\family default
\size default
\color inherit
 in a function type means 
\begin_inset Formula $\forall T$
\end_inset

, for example the type of the function 
\family typewriter
\size footnotesize
\color blue
def dupl[A]:
\begin_inset space \space{}
\end_inset

A 
\begin_inset Formula $\Rightarrow$
\end_inset

 (A, A)
\family default
\size default
\color inherit
 corresponds to the (valid) proposition 
\begin_inset Formula $\forall A:A\Rightarrow A\times A$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Convert Scala types to short notation and back
\end_layout

\begin_layout Itemize
Example 1: A disjunction type
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait UserAction
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class SetName(first: String, last: String) extends UserAction
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class SetEmail(email: String) extends UserAction
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class SetUserId(id: Long) extends UserAction
\end_layout

\begin_layout Itemize
Short notation: 
\family typewriter
\size footnotesize
\color blue
UserAction
\family default
\size default
\color inherit
 
\begin_inset Formula $=$
\end_inset

 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 
\begin_inset Formula $\times$
\end_inset

 
\family typewriter
\size footnotesize
\color blue
String 
\begin_inset Formula $+$
\end_inset


\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue

\begin_inset Formula $+$
\end_inset


\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue
Long
\end_layout

\begin_layout Itemize
Example 2: A parameterized disjunction type
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Either3[A, B, C]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Left[A, B, C](x: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 C) extends Either3[A, B, C]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Middle[A, B, C](x: B) extends Either3[A, B, C]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Right[A, B, C](x: C 
\begin_inset Formula $\Rightarrow$
\end_inset

 A) extends Either3[A, B, C]
\end_layout

\begin_layout Itemize
Short notation: 
\begin_inset Formula $\forall A\forall B\forall C:$
\end_inset

 
\begin_inset Formula $(A\Rightarrow B)+B+(C\Rightarrow A)$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Any valid formula can be implemented in code
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def identity[A](x:A):A = x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\Rightarrow1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def toUnit[A](x:A): Unit = ()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\Rightarrow A+B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def inLeft[A,B](x:A):
\begin_inset space \space{}
\end_inset

Either[A,B] = Left(x)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\times B\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def first[A,B](p:(A,B)):A = p._1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\Rightarrow(B\Rightarrow A)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def const[A,B](x:A):B
\begin_inset Formula $\Rightarrow$
\end_inset

A = (y:B)
\begin_inset Formula $\Rightarrow$
\end_inset

x
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Invalid formulas 
\emph on
cannot be implemented
\emph default
 in code 
\end_layout

\begin_deeper
\begin_layout Itemize
Examples of invalid formulas:
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $\forall A:1\Rightarrow A$
\end_inset

; 
\begin_inset Formula $\forall A\forall B:A+B\Rightarrow A$
\end_inset

; 
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\forall A\forall B:A\Rightarrow A\times B$
\end_inset

; 
\begin_inset space \space{}
\end_inset

 
\begin_inset Formula $\quad\forall A\forall B:(A\Rightarrow B)\Rightarrow A$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Given a type's formula, can we implement it in code?
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $\forall A\forall B:((((A\Rightarrow B)\Rightarrow A)\Rightarrow A)\Rightarrow B)\Rightarrow B$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Constructive propositional logic has a decision algorithm
\end_layout

\begin_layout Itemize
See code examples using the 
\begin_inset CommandInset href
LatexCommand href
name "curryhoward"
target "https://github.com/Chymyst/curryhoward"

\end_inset

 library
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence III
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Using known properties of propositional logic and arithmetic
\end_layout

\begin_layout Standard
Are 
\begin_inset Formula $A+B,\:A\times B$
\end_inset

 more like logic or like arithmetic?
\end_layout

\begin_layout Itemize
Some standard identities in logic (
\begin_inset Formula $\forall A\forall B\forall C$
\end_inset

 is assumed):
\begin_inset Formula 
\begin{align*}
A\times1=A; & \quad A+1=1\\
(A\times B)\times C & =A\times(B\times C)\\
(A+B)+C & =A+(B+C)\\
A\times(B+C) & =(A\times B)+(A\times C)\\
A+(B\times C) & =(A+B)\times(A+C)\\
(A\times B)\Rightarrow C & =A\Rightarrow(B\Rightarrow C)\\
A\Rightarrow(B\times C) & =(A\Rightarrow B)\times(A\Rightarrow C)\\
(A+B)\Rightarrow C & =(A\Rightarrow C)\times(B\Rightarrow C)
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
Each identity means 2 function types: 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $X=Y$
\end_inset


\begin_inset Quotes erd
\end_inset

 is 
\begin_inset Formula $X\Rightarrow Y$
\end_inset

, 
\begin_inset Formula $Y\Rightarrow X$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Do these functions convert values between the types 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

?
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type isomorphisms I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are isomorphic, 
\begin_inset Formula $A\equiv B$
\end_inset

, if there is a 1-to-1 correspondence between all values of these types.
 Formally, this requires us to find two functions 
\begin_inset Formula $f:A\Rightarrow B$
\end_inset

 and 
\begin_inset Formula $g:B\Rightarrow A$
\end_inset

 such that 
\begin_inset Formula $f\circ g=id$
\end_inset

 and 
\begin_inset Formula $g\circ f=id$
\end_inset


\end_layout

\begin_layout Standard
Example 1: Is 
\begin_inset Formula $\forall A:A\times1\equiv A$
\end_inset

? Types in Scala: 
\family typewriter
\size footnotesize
\color blue
(A, Unit)
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
A
\end_layout

\begin_layout Itemize
Two functions with types 
\begin_inset Formula $\forall A:A\times1\Rightarrow A$
\end_inset

 and 
\begin_inset Formula $\forall A:A\Rightarrow A\times1$
\end_inset

:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f1[A]: ((A, Unit)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 A = { case (a, ()) 
\begin_inset Formula $\Rightarrow$
\end_inset

 a }
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f2[A]: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 ((A, Unit)) = a 
\begin_inset Formula $\Rightarrow$
\end_inset

 (a, ())
\end_layout

\begin_layout Itemize
Verify that their compositions equal 
\begin_inset Formula $id$
\end_inset

 (see test code)
\end_layout

\begin_layout Standard
Example 2: Is 
\begin_inset Formula $\forall A:A+1\equiv1$
\end_inset

? Types in Scala: 
\family typewriter
\size footnotesize
\color blue
Option[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\begin_layout Itemize
These types are 
\emph on
not
\emph default
 isomorhic
\end_layout

\begin_layout Standard

\emph on
Some
\emph default
 of the logic identities yield
\emph on
 
\emph default
isomorphisms of types
\end_layout

\begin_layout Itemize
Which ones 
\emph on
do
\emph default
 
\emph on
not
\emph default
 yield isomorphisms, and why?
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type isomorphisms II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Verifying a type isomorphism
\end_layout

\begin_layout Itemize
Need to verify that 
\begin_inset Formula $f_{1}\circ f_{2}=id$
\end_inset

 and 
\begin_inset Formula $f_{2}\circ f_{1}=id$
\end_inset


\end_layout

\begin_layout Standard
Example 3: 
\begin_inset Formula $\forall A\forall B\forall C:(A\times B)\Rightarrow C\equiv(A\Rightarrow C)\times(B\Rightarrow C)$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f1[A,B,C]: ((A, B) 
\begin_inset Formula $\Rightarrow$
\end_inset

 C) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (A 
\begin_inset Formula $\Rightarrow$
\end_inset

 C, B 
\begin_inset Formula $\Rightarrow$
\end_inset

 C) = ...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f2[A,B,C]: ((A 
\begin_inset Formula $\Rightarrow$
\end_inset

 C, B 
\begin_inset Formula $\Rightarrow$
\end_inset

 C)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 ((A, B)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 C = ...
\end_layout

\begin_layout Standard
Example 4: 
\begin_inset Formula $\forall A\forall B\forall C:(A\times B)\times C\equiv A\times(B\times C)$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def g1[A,B,C]: (((A, B), C)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (A, (B, C)) = ...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def g2[A,B,C]: ((A, (B, C))) 
\begin_inset Formula $\Rightarrow$
\end_inset

 ((A, B), C) = ...
\end_layout

\begin_layout Standard
Example 5: 
\begin_inset Formula $\forall A\forall B\forall C:A\times(B+C)\equiv(A\times B)+(A\times C)$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def h1[A,B,C]: ((A, Either[B, C])) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Either[(A, B), (A, C)] = ...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def h2[A,B,C]: Either[(A, B), (A, C)] 
\begin_inset Formula $\Rightarrow$
\end_inset

 (A, Either[B, C]) = ...
\end_layout

\begin_layout Standard
Example 6: (This is not 
\begin_inset Formula $\equiv$
\end_inset

!) 
\begin_inset Formula $\forall A\forall B\forall C:A+(B\times C)=(A+B)\times(A+C)$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def j1[A,B,C]: Either[A, (B, C)] 
\begin_inset Formula $\Rightarrow$
\end_inset

 (Either[A,B], Either[A,C]) = ...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def j2[A,B,C]:((Either[A,B], Either[A,C])) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Either[A, (B,C)] = ...
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type isomorphisms III
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Logic CH vs.
\begin_inset space \space{}
\end_inset

arithmetic CH for elementary (
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Quotes erd
\end_inset

) types
\end_layout

\begin_layout Itemize
WLOG, consider types 
\begin_inset Formula $A,B,...$
\end_inset

 that have 
\emph on
finite
\emph default
 sets of possible values
\end_layout

\begin_deeper
\begin_layout Itemize
Disjunction type 
\begin_inset Formula $A+B$
\end_inset

 (size 
\begin_inset Formula $\left|A\right|+\left|B\right|$
\end_inset

) provides a disjoint union of sets
\end_layout

\begin_layout Itemize
Tuple type 
\begin_inset Formula $A\times B$
\end_inset

 (size 
\begin_inset Formula $\left|A\right|\cdot\left|B\right|$
\end_inset

) provides a Cartesian product of sets
\end_layout

\begin_layout Itemize
Function type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 provides the set of all maps between sets
\end_layout

\begin_deeper
\begin_layout Itemize
The size of 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 is 
\begin_inset Formula $\left|B\right|^{\left|A\right|}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
If the set size (cardinality) differs, 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 cannot be isomorphic 
\end_layout

\begin_deeper
\begin_layout Itemize
Only the arithmetic identities yield type isomorphisms
\end_layout

\begin_layout Itemize
Logic identities yield only the 
\begin_inset Quotes eld
\end_inset

equal implementability
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
The meaning of the types/logic/arithmetic correspondence:
\end_layout

\begin_layout Itemize
Arithmetic formulas show isomorphism
\end_layout

\begin_layout Itemize
Logic formulas show implementability
\end_layout

\begin_layout Standard
Reasoning about types is just like doing school algebra
\end_layout

\begin_layout Itemize

\series bold
Elementary types
\series default
: constants, sums, products, exponentials
\end_layout

\begin_layout Itemize

\series bold
Polynomial types
\series default
: constants, sums, products
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Algebraic computation with recursive types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Recursive type: 
\begin_inset Quotes eld
\end_inset

list of integers
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait IntList
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case object Empty extends IntList
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class Nonempty(head: Int, tail: IntList) extends IntList
\end_layout

\begin_layout Standard
Parameterized recursive type: 
\begin_inset Quotes eld
\end_inset

list of 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait List[T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case object Nil extends List[Nothing]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class ::(head: T, tail: List[T]) extends List[T]
\end_layout

\begin_layout Standard
Short notation: (the sign 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\equiv$
\end_inset


\begin_inset Quotes erd
\end_inset

 means type isomorphism)
\family typewriter
\size footnotesize
\color blue

\begin_inset Formula 
\begin{align*}
\text{List}(t) & \equiv1+t\times\text{List}(t)\equiv1+t\times(1+t\times(1+t\times(...)...)\\
 & \equiv1+t+\left(t\times t\right)+\left(t\times t\times t\right)+...
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
A curious analogy with calculus: 
\begin_inset Formula $\text{List}(t)=1+t\cdot\text{List}(t)$
\end_inset

; 
\begin_inset Quotes eld
\end_inset

solve
\begin_inset Quotes erd
\end_inset

 this as 
\begin_inset Formula 
\begin{align*}
\text{List}(t) & =\frac{1}{1-t}=1+t+t^{2}+t^{3}+...
\end{align*}

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked examples
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
a
\end_layout

\begin_layout Itemize
a
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises III
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
a
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence IV
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Implications for designing new programming languages
\end_layout

\begin_layout Itemize
The CH correspondence maps the type system of each programming language
 into a certain system of logical propositions 
\end_layout

\begin_layout Itemize
Scala, Haskell, OCaml, F#, Swift, Rust, etc.
\begin_inset space ~
\end_inset

are mapped into the full constructive logic (all logical operations are
 available)
\end_layout

\begin_deeper
\begin_layout Itemize
C, C++, Java, C#, etc.
\begin_inset space ~
\end_inset

are mapped to 
\emph on
incomplete
\emph default
 
\emph on
logics
\emph default
 â€“ without 
\begin_inset Quotes eld
\end_inset

or
\begin_inset Quotes erd
\end_inset

 and without 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 / 
\begin_inset Quotes eld
\end_inset

false
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Python, JavaScript, Ruby, Clojure, etc.
\begin_inset space ~
\end_inset

have only one type (
\begin_inset Quotes eld
\end_inset

any value
\begin_inset Quotes erd
\end_inset

) and are mapped to logics with only one proposition
\end_layout

\end_deeper
\begin_layout Itemize
The CH correspondence is a principle for designing type systems:
\end_layout

\begin_deeper
\begin_layout Itemize
Choose a complete logic, free of inconsistency
\end_layout

\begin_deeper
\begin_layout Itemize
Mathematicians have studied all kinds of logics and determined which ones
 are interesting, and found the minimal sets of axioms for them
\end_layout

\begin_layout Itemize
Modal logic, temporal logic, linear logic, etc.
\end_layout

\end_deeper
\begin_layout Itemize
Provide a type constructor for each basic operation (e.g.
\begin_inset space ~
\end_inset


\begin_inset Quotes eld
\end_inset


\emph on
or
\emph default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\emph on
and
\emph default

\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence V
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Implications for actually writing code
\end_layout

\begin_layout Standard
What problems can we solve now?
\end_layout

\begin_layout Itemize
Use the short type notation for reasoning about types
\end_layout

\begin_layout Itemize
Given a fully parametric type, decide whether it can be implemented in code
 (
\begin_inset Quotes eld
\end_inset

type is inhabited
\begin_inset Quotes erd
\end_inset

); if so, 
\emph on
generate
\emph default
 the code
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset CommandInset href
LatexCommand href
name "Gentzen-Vorobiev-Hudelmaier algorithm"
target "http://apt13.unibe.ch/slides/Dyckhoff.pdf"

\end_inset

 and its generalizations
\end_layout

\begin_layout Itemize
See also the 
\begin_inset CommandInset href
LatexCommand href
name "curryhoward"
target "https://github.com/Chymyst/curryhoward"

\end_inset

 project
\end_layout

\end_deeper
\begin_layout Itemize
Given some expression, infer the most general type it can have
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset CommandInset href
LatexCommand href
name "Damas-Hindley-Milner algorithm"
target "https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system"

\end_inset

 (
\begin_inset CommandInset href
LatexCommand href
name "Scala code"
target "http://dysphoria.net/2009/06/28/hindley-milner-type-inference-in-scala/"

\end_inset

) and generalizations
\end_layout

\end_deeper
\begin_layout Itemize
Decide type isomorphism, simplify type formulas (the 
\begin_inset Quotes eld
\end_inset

arithmetic CH
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
Compute the necessary types before starting to write code
\end_layout

\begin_layout Standard
What problems cannot be solved with these tools?
\end_layout

\begin_layout Itemize
Automatically generate code satisfying properties (e.g.
\begin_inset space \space{}
\end_inset

isomorphism)
\end_layout

\begin_layout Itemize
Express complicated conditions via types (e.g.
\begin_inset space \space{}
\end_inset


\begin_inset Quotes eld
\end_inset

array is sorted
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
Need dependent types for that (Coq, Agda, Idris, ...)
\end_layout

\end_deeper
\end_deeper
\end_body
\end_document
