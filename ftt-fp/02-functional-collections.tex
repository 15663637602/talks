%% LyX 2.2.0 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 % this default might be overridden by plain title style
 \newcommand\makebeamertitle{\frame{\maketitle}}%
 % (ERT) argument for the TOC
 \AtBeginDocument{%
   \let\origtableofcontents=\tableofcontents
   \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
   \def\gobbletableofcontents#1{\origtableofcontents}
 }
 \newenvironment{lyxcode}
   {\par\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \setlength{\listparindent}{0pt}% needed for AMS classes
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \normalfont\ttfamily}%
    \def\{{\char`\{}
    \def\}{\char`\}}
    \def\textasciitilde{\char`\~}
    \item[]}
   {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 2: Functional Collections]{Chapter 2: The Functional Approach to Collections}
\author{Sergei Winitzki}
\date{November 12, 2017}
\institute[ABTB]{Academy by the Bay}

\makeatother

\begin{document}
\frame{\titlepage}
\begin{frame}{Tuples}

\begin{itemize}
\item Pair of values: \texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val a:\ (Int, String) = (123,
``xyz'')}}{\footnotesize \par}
\item Triple of values: \texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val b:\ (Boolean, Int, Int)
= (true, 3, 4)}}{\footnotesize \par}
\item Tuples can be nested: \texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val c:\ (Boolean, (String,
Int), Boolean) =}}~\\
\texttt{\textcolor{blue}{\footnotesize{} (true, (``abc'', 3), false)}}{\footnotesize \par}
\item Parts of the tuple can be accessed by number: \texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val x:\ (String, Int) = c.\_2}}{\footnotesize \par}
\item Functions on tuples:\texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}def f(p:\ (Boolean, Int),
q:\ Int):\ Boolean = p.\_1 \&\& (p.\_2 > q) }}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Pattern-matching syntax for tuples}

Scala allows pattern matching in two places:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}val }}\textcolor{blue}{\emph{\footnotesize{}pattern}}\texttt{\textcolor{blue}{\footnotesize{}
= ...}} (value assignment)
\item \texttt{\textcolor{blue}{\footnotesize{}case }}\textcolor{blue}{\emph{\footnotesize{}pattern}}\texttt{\textcolor{blue}{\footnotesize{}
}}\textcolor{blue}{\footnotesize{}$\Rightarrow$}\texttt{\textcolor{blue}{\footnotesize{}
...}} (partial function)
\end{itemize}
Examples:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}val a = (1, 2, 3); val (x,
y, z) = a}}{\footnotesize \par}
\item \texttt{\textcolor{blue}{\footnotesize{}val f:\ ((Int, Int, Int))
$\Rightarrow$ Int = \{ case (x, y, z) $\Rightarrow$ x + y + z \};
f(a)}}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Combining tuple types with other types}

We can use tuple types anywhere:
\begin{itemize}
\item Tuple of functions:\\
 \texttt{\textcolor{blue}{\footnotesize{}val q:\ (Int $\Rightarrow$
Int, Int $\Rightarrow$ Int) = (x $\Rightarrow$ x + 1, x $\Rightarrow$
x - 1)}}{\footnotesize \par}
\item Sequence of tuples:\\
 \texttt{\textcolor{blue}{\footnotesize{}val s:\ Seq{[}(String, Int){]}
=}}~\\
\texttt{\textcolor{blue}{\footnotesize{} \  Seq((``apples'', 3),
(``oranges'', 2), (``pears'', 0))}}{\footnotesize \par}
\item Tuples are used a lot in the Scala standard library...
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}zip:\ (Seq{[}A{]}, Seq{[}B{]})
$\Rightarrow$ Seq{[}(A, B){]}}}{\footnotesize \par}
\item \texttt{\textcolor{blue}{\footnotesize{}map:\ (Map{[}K, V{]}, (K,
V) $\Rightarrow$ R) $\Rightarrow$ Seq{[}R{]}}}{\footnotesize \par}
\begin{itemize}
\item Note: the syntax \texttt{\textcolor{blue}{\footnotesize{}(a $\rightarrow$
b)}} means the same as the tuple \texttt{\textcolor{blue}{\footnotesize{}(a,
b) }}{\footnotesize \par}
\end{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}toMap:\ Seq{[}(K, V){]} $\Rightarrow$
Map{[}K, V{]}}}{\footnotesize \par}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Worked examples}

\begin{enumerate}
\item for a given sequence $a_{i}$, compute the sequence of pairs $b_{i}=\left(\cos a_{i},\sin a_{i}\right)$
\textendash{} use \texttt{\textcolor{blue}{\footnotesize{}.map}},
assume \texttt{\textcolor{blue}{\footnotesize{}Seq{[}Double{]}}}{\footnotesize \par}
\item in a given sequence $a_{i}$, count how many times $\cos a_{i}>\sin a_{i}$
occurs\\
\textendash{} use \texttt{\textcolor{blue}{\footnotesize{}.count}},
assume \texttt{\textcolor{blue}{\footnotesize{}Seq{[}Double{]}}}{\footnotesize \par}
\item for given sequences $a_{i}$ and $b_{i}$, compute the sequence of
differences\\
 $c_{i}=a_{i}-b_{i}$ (use \texttt{\textcolor{blue}{\footnotesize{}.zip}},
\texttt{\textcolor{blue}{\footnotesize{}.map}}, assume \texttt{\textcolor{blue}{\footnotesize{}Seq{[}Double{]}}})
\item in a given sequence $a_{i}$, count how many times $a_{i}>a_{i+1}$
occurs
\item for a given $k>0$, compute the sequence $b_{i}=\max(a_{i-k},...,a_{i+k})$\\
 \textendash{} use \texttt{\textcolor{blue}{\footnotesize{}.sliding}} 
\item create a multiplication table as a value of type \texttt{\textcolor{blue}{\footnotesize{}Map{[}(Int,
Int), Int{]}}}~\\
 \textendash{} use \texttt{\textcolor{blue}{\footnotesize{}.flatMap}}{\footnotesize \par}
\item for a given sequence $a_{i}$, compute the combined set of the numbers
$a_{i}$, $\cos a_{i}$ $\sin a_{i}$ and find its maximum value \textendash{}
use \texttt{\textcolor{blue}{\footnotesize{}.map, .flatMap, .max}}{\footnotesize \par}
\item from a \texttt{\textcolor{blue}{\footnotesize{}Map{[}String, String{]}}}
mapping names to addresses, and assuming that the addresses do not
repeat, compute a \texttt{\textcolor{blue}{\footnotesize{}Map{[}String,
String{]}}} mapping addresses to names \textendash{} use \texttt{\textcolor{blue}{\footnotesize{}.toMap}},
\texttt{\textcolor{blue}{\footnotesize{}.map}}{\footnotesize \par}
\begin{itemize}
\item Write this as a function with type parameters \texttt{\textcolor{blue}{\footnotesize{}Name}}
and \texttt{\textcolor{blue}{\footnotesize{}Address}} instead of the
fixed type \texttt{\textcolor{blue}{\footnotesize{}String}}{\footnotesize \par}
\end{itemize}
\end{enumerate}
\end{frame}

\begin{frame}{Exercises I}

\begin{enumerate}
\item Find all $i,j$ within $\left(0,1,...,9\right)$ such that $i+4*j>i*j$
(use \texttt{\textcolor{blue}{\footnotesize{}.flatMap}})
\begin{itemize}
\item Same task for $i,j,k$ and the condition $i+4*j+9*k>i*j*k$
\end{itemize}
\item Given two sequences \texttt{\textcolor{blue}{\footnotesize{}a:}}~\texttt{\textcolor{blue}{\footnotesize{}Seq{[}String{]}}}
and \texttt{\textcolor{blue}{\footnotesize{}b:}}~\texttt{\textcolor{blue}{\footnotesize{}Seq{[}Boolean{]}}}
of equal length, compute a \texttt{\textcolor{blue}{\footnotesize{}Seq{[}String{]}}}
with those elements of \texttt{\textcolor{blue}{\footnotesize{}a}}
for which the corresponding element of \texttt{\textcolor{blue}{\footnotesize{}b}}
is \texttt{\textcolor{blue}{\footnotesize{}true}} \textendash{} use
\texttt{\textcolor{blue}{\footnotesize{}.zip}}, \texttt{\textcolor{blue}{\footnotesize{}.map}},
\texttt{\textcolor{blue}{\footnotesize{}.filter}}{\footnotesize \par}
\item Convert a \texttt{\textcolor{blue}{\footnotesize{}Seq{[}Int{]}}} into
a \texttt{\textcolor{blue}{\footnotesize{}Seq{[}(Int, Boolean){]}}}
where the Boolean value is \texttt{\textcolor{blue}{\footnotesize{}true}}
when the element is followed by a larger value; e.g. \texttt{\textcolor{blue}{\footnotesize{}Seq(1,3,2,4)}}
is to be converted into \texttt{\textcolor{blue}{\footnotesize{}Seq((1,true),(3,false),(2,true))}}{\footnotesize \par}
\item Given \texttt{\textcolor{blue}{\footnotesize{}a:}}~\texttt{\textcolor{blue}{\footnotesize{}Seq{[}String{]}}}
and \texttt{\textcolor{blue}{\footnotesize{}b:}}~\texttt{\textcolor{blue}{\footnotesize{}Seq{[}Int{]}}}
of equal length, and assuming that elements of \texttt{\textcolor{blue}{\footnotesize{}b}}
do not repeat, compute a \texttt{\textcolor{blue}{\footnotesize{}Map{[}Int,
String{]}}} that maps numbers from \texttt{\textcolor{blue}{\footnotesize{}b}}
to their corresponding strings from \texttt{\textcolor{blue}{\footnotesize{}a}}{\footnotesize \par}
\begin{itemize}
\item Write this as a function with type parameters \texttt{\textcolor{blue}{\footnotesize{}S}}
and \texttt{\textcolor{blue}{\footnotesize{}I}} instead of the fixed
types \texttt{\textcolor{blue}{\footnotesize{}String}} and \texttt{\textcolor{blue}{\footnotesize{}Int}}{\footnotesize \par}
\end{itemize}
\item Given \texttt{\textcolor{blue}{\footnotesize{}a:}}~\texttt{\textcolor{blue}{\footnotesize{}Seq{[}String{]}}}
and \texttt{\textcolor{blue}{\footnotesize{}b:}}~\texttt{\textcolor{blue}{\footnotesize{}Seq{[}Int{]}}}
of equal length, compute a \texttt{\textcolor{blue}{\footnotesize{}Seq{[}String{]}}}
that contains the strings from \texttt{\textcolor{blue}{\footnotesize{}a}}
ordered according to the corresponding numbers from \texttt{\textcolor{blue}{\footnotesize{}b}}
\textendash{} use \texttt{\textcolor{blue}{\footnotesize{}.sortBy}}{\footnotesize \par}
\begin{itemize}
\item Write this as a function with type parameter \texttt{\textcolor{blue}{\footnotesize{}S}}
instead of \texttt{\textcolor{blue}{\footnotesize{}String}}{\footnotesize \par}
\end{itemize}
\end{enumerate}
\end{frame}

\begin{frame}{Exercises II}

\begin{enumerate}
\item Given a \texttt{\textcolor{blue}{\footnotesize{}Seq{[}(String, Int){]}}}
showing a list of purchased items (names may repeat), compute \texttt{\textcolor{blue}{\footnotesize{}Map{[}String,
Int{]}}} showing the total counts: e.g.~given a \texttt{\textcolor{blue}{\footnotesize{}Seq((``apple'',
2), (``pear'', 3), (``apple'', 5))}}, compute \texttt{\textcolor{blue}{\footnotesize{}Map(``apple''
$\rightarrow$ 7, ``pear'' $\rightarrow$ 3)}} \textendash{} use
\texttt{\textcolor{blue}{\footnotesize{}.groupBy}}, \texttt{\textcolor{blue}{\footnotesize{}.map}},
\texttt{\textcolor{blue}{\footnotesize{}.sum}}{\footnotesize \par}
\begin{itemize}
\item Write this as a function with type parameter \texttt{\textcolor{blue}{\footnotesize{}S}}
instead of \texttt{\textcolor{blue}{\footnotesize{}String}}{\footnotesize \par}
\end{itemize}
\item Given a \texttt{\textcolor{blue}{\footnotesize{}Seq{[}List{[}Int{]}{]}}},
compute a \texttt{\textcolor{blue}{\footnotesize{}Seq{[}List{[}Int{]}{]}}}
where each new inner list contains the three largest elements from
the initial inner list \textendash{} use \texttt{\textcolor{blue}{\footnotesize{}.sortBy}},
\texttt{\textcolor{blue}{\footnotesize{}.take}}, \texttt{\textcolor{blue}{\footnotesize{}.map}}{\footnotesize \par}
\item Given two sets \texttt{\textcolor{blue}{\footnotesize{}a}}, \texttt{\textcolor{blue}{\footnotesize{}b}}
of type \texttt{\textcolor{blue}{\footnotesize{}Set{[}Int{]}}}, compute
a \texttt{\textcolor{blue}{\footnotesize{}Set{[}(Int, Int){]}}} representing
the Cartesian product of the sets \texttt{\textcolor{blue}{\footnotesize{}a}}
and \texttt{\textcolor{blue}{\footnotesize{}b}} \textendash{} use
\texttt{\textcolor{blue}{\footnotesize{}.flatMap}}{\footnotesize \par}
\begin{itemize}
\item Write this as a function with type parameters \texttt{\textcolor{blue}{\footnotesize{}I}},
\texttt{\textcolor{blue}{\footnotesize{}J}} instead of \texttt{\textcolor{blue}{\footnotesize{}Int}}{\footnotesize \par}
\end{itemize}
\item {*} Given a \texttt{\textcolor{blue}{\footnotesize{}Seq{[}Map{[}Person,
Amount{]}{]}}}, showing the amounts various people paid on each day,
compute a \texttt{\textcolor{blue}{\footnotesize{}Map{[}Person, Seq{[}Amount{]}{]}}},
showing the sequence of payments for each person (assume \texttt{\textcolor{blue}{\footnotesize{}Person}}
and \texttt{\textcolor{blue}{\footnotesize{}Amount}} are type parameters
and use \texttt{\textcolor{blue}{\footnotesize{}.flatMap}}, \texttt{\textcolor{blue}{\footnotesize{}.toSeq}},
\texttt{\textcolor{blue}{\footnotesize{}.groupBy}})
\end{enumerate}
\end{frame}

\begin{frame}{Mathematical induction I}


\framesubtitle{Computing a number from a sequence}

Typical problem:
\begin{itemize}
\item Compute an integer value from the sequence of its decimal digits
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~fromDigits(digits:~Seq{[}Int{]}):~Int~=~???}~\\
{\footnotesize \par}

\textcolor{blue}{\footnotesize{}fromDigits(Seq(1,~3,~0,~0))~==~1300}{\footnotesize \par}
\end{lyxcode}
Mathematical formulation uses \emph{induction}
\begin{itemize}
\item base case: empty sequence: \texttt{\textcolor{blue}{\footnotesize{}fromDigits(Seq())
= 0}}{\footnotesize \par}
\item induction step: if \texttt{\textcolor{blue}{\footnotesize{}fromDigits}}
is already computed for a sequence \textcolor{blue}{\emph{\footnotesize{}previous}}\textcolor{blue}{\footnotesize{}...},
how to compute it for a sequence with one more element:\texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}fromDigits(Seq(}}\textcolor{blue}{\emph{\footnotesize{}previous...}}\texttt{\textcolor{blue}{\footnotesize{},
x)) = 10 {*} fromDigits(}}\textcolor{blue}{\emph{\footnotesize{}previous...}}\texttt{\textcolor{blue}{\footnotesize{})
+ x}}{\footnotesize \par}
\begin{itemize}
\item the result still needs to be divided by 10
\end{itemize}
\end{itemize}
Translating mathematical induction into code:
\begin{itemize}
\item use recursion
\item use standard library functions \texttt{\textcolor{blue}{\footnotesize{}fold}},
\texttt{\textcolor{blue}{\footnotesize{}scan}}, etc.
\end{itemize}
\end{frame}

\begin{frame}{Mathematical induction II}


\framesubtitle{Writing a recursive function by hand}
\begin{itemize}
\item base case vs.~inductive step needs to be decided in the code
\item the function calls itself recursively
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~fromDigits(digits:~Seq{[}Int{]}):~Int~=~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~digits~match~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~Seq()~$\Rightarrow$~0}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~\_~$\Rightarrow$}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~val~x~=~digits.head}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~val~rest~=~digits.tail}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~10~{*}~fromDigits(rest)~+~x}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~\}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item lots of code...
\begin{itemize}
\item not very different from writing a loop
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Mathematical induction III}


\framesubtitle{Computing a number from a sequence}

The standard function \texttt{\textcolor{blue}{\footnotesize{}foldLeft}}
implements general induction:
\begin{itemize}
\item base case is the first argument to \texttt{\textcolor{blue}{\footnotesize{}foldLeft}}{\footnotesize \par}
\item induction step is represented by a function\texttt{ }\texttt{\textcolor{blue}{\footnotesize{}(previous,
x) $\Rightarrow$ next}}{\footnotesize \par}
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~fromDigits(digits:~Seq{[}Int{]}):~Int~=}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~digits.foldLeft(0)\{~case~(prev,~x)~$\Rightarrow$~prev~{*}~10~+~x~\}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item see other library functions: \texttt{\textcolor{blue}{\footnotesize{}.foldRight}},
\texttt{\textcolor{blue}{\footnotesize{}.fold}}, \texttt{\textcolor{blue}{\footnotesize{}.reduce}}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Mathematical induction IV}


\framesubtitle{Computing a sequence from a number (\texttt{iterate})}

Typical problem:
\begin{itemize}
\item compute the sequence of decimal digits of a given integer
\begin{itemize}
\item we cannot solve this with \texttt{\textcolor{blue}{\footnotesize{}.map}},
\texttt{\textcolor{blue}{\footnotesize{}.zip}}, \texttt{\textcolor{blue}{\footnotesize{}.fold}}
etc., because the length of the resulting sequence is unknown
\item we need to ``unfold'' into a sequence of unknown length, and terminate
it when some condition holds
\end{itemize}
\end{itemize}
The \texttt{\textcolor{blue}{\footnotesize{}Iterator }}type has methods
\texttt{\textcolor{blue}{\footnotesize{}iterate}}, \texttt{\textcolor{blue}{\footnotesize{}fill}},
\texttt{\textcolor{blue}{\footnotesize{}tabulate}} that can help
\end{frame}

\begin{frame}{Mathematical induction V}


\framesubtitle{Computing a sequence from a sequence (\texttt{scan})}

Typical problem:
\begin{itemize}
\item compute partial sums of the given sequence
\end{itemize}
\end{frame}

\begin{frame}{Examples}

\begin{itemize}
\item Using both \texttt{\textcolor{blue}{\footnotesize{}def}} and \texttt{\textcolor{blue}{\footnotesize{}val}},
define a function that...
\begin{enumerate}
\item adds 20 to its integer argument
\item takes an integer \texttt{\textcolor{blue}{\footnotesize{}x}}, and
returns a \emph{function} that adds \texttt{\textcolor{blue}{\footnotesize{}x}}
to \emph{its} argument
\item takes an integer \texttt{\textcolor{blue}{\footnotesize{}x}} and returns
\texttt{\textcolor{blue}{\footnotesize{}true}} iff \texttt{\textcolor{blue}{\footnotesize{}x
+ 1}} is prime
\end{enumerate}
\item What are the types of the functions in Examples 1 - 3?
\item Compute the average of all numbers in a sequence of type \texttt{\textcolor{blue}{\footnotesize{}Seq{[}Double{]}}}.
Use \texttt{\textcolor{blue}{\footnotesize{}sum}} and \texttt{\textcolor{blue}{\footnotesize{}size}}
but no loops.
\item Given $n$, compute \href{https://en.wikipedia.org/wiki/Wallis_product}{the Wallis product}
truncated up to $\frac{2n}{2n+1}$: 
\[
\frac{2}{1}\frac{2}{3}\frac{4}{3}\frac{4}{5}\frac{6}{5}\frac{6}{7}...\frac{2n}{2n+1}.
\]
Use a sequence of \texttt{\textcolor{blue}{\footnotesize{}Int}} or
\texttt{\textcolor{blue}{\footnotesize{}Double}} numbers, \texttt{\textcolor{blue}{\footnotesize{}map}},
and \texttt{\textcolor{blue}{\footnotesize{}product}}.
\item Given \texttt{\textcolor{blue}{\footnotesize{}s:~Seq{[}Set{[}Int{]}{]}}},
compute the sequence containing the sets of size at least 3. Use \texttt{\textcolor{blue}{\footnotesize{}map}},
\texttt{\textcolor{blue}{\footnotesize{}filter}}, \texttt{\textcolor{blue}{\footnotesize{}size}}.
The result must be again of type \texttt{\textcolor{blue}{\footnotesize{}Seq{[}Set{[}Int{]}{]}}}.
\end{itemize}
\end{frame}

\begin{frame}{Summary}

\begin{itemize}
\item What problems can we solve now?
\begin{itemize}
\item Compute mathematical expressions involving sums, products, and quantifiers,
based on integer ranges (such as $\sum_{k=1}^{n}f(k)$ etc.)
\item Implement functions that take or return other functions
\item Work on collections using \texttt{\textcolor{blue}{\footnotesize{}map}}
and other library methods
\end{itemize}
\item What kinds of problems are not solved with these tools?
\begin{itemize}
\item Compute the smallest $n$ such that $f(f(f(...f(1)...)>1000$, where
the function $f$ is applied $n$ times.
\item Find the $k$-th largest element in an (unsorted) array of integers.
\item Perform binary search over a sorted array.
\end{itemize}
\item Why can't we solve such problems yet?
\begin{itemize}
\item Because we can't yet put \emph{mathematical induction} into code
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Exercises}

\begin{enumerate}
\item Define a function of type \texttt{\textcolor{blue}{\footnotesize{}Seq{[}Double{]}
=> Seq{[}Double{]}}} that ``normalizes'' the sequence: it finds
the element having the max.~absolute value and, if that value is
nonzero, divides all elements by that factor.
\item Define a function of type \texttt{\textcolor{blue}{\footnotesize{}Seq{[}Seq{[}Int{]}{]}
=> Seq{[}Seq{[}Int{]}{]}}} that adds 20 to every element of every
inner sequence.
\item An integer $n$ is called ``3-factor'' if it is divisible by only
three different integers $j$ such that $2\leq j<n$. Compute the
set of all ``3-factor'' integers $n$ among $n\in[1,...,1000]$
.
\item Given a function $f$ of type \texttt{\textcolor{blue}{\footnotesize{}Int
=> Boolean}}, an integer $n$ is called ``3-$f$'' if there are
only three different integers $j\in[1,...,n]$ such that $f(j)$ returns
\texttt{\textcolor{blue}{\footnotesize{}true}}. Define a function
that takes $f$ as an argument and returns a sequence of all ``3-$f$''
integers among $n\in[1,...,1000]$. What is the type of that function?
Rewrite Exercise~3 using that function.
\item Define a function that takes two functions \texttt{\textcolor{blue}{\footnotesize{}f:~Int
=> Double}} and \texttt{\textcolor{blue}{\footnotesize{}g:~Double
=> String}} as arguments, and returns a new function that computes
the functional composition of \texttt{\textcolor{blue}{\footnotesize{}f}}
and \texttt{\textcolor{blue}{\footnotesize{}g}}.
\end{enumerate}
\end{frame}

\end{document}
