%% LyX 2.2.0 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 % this default might be overridden by plain title style
 \newcommand\makebeamertitle{\frame{\maketitle}}%
 % (ERT) argument for the TOC
 \AtBeginDocument{%
   \let\origtableofcontents=\tableofcontents
   \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
   \def\gobbletableofcontents#1{\origtableofcontents}
 }
 \newenvironment{lyxcode}
   {\par\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \setlength{\listparindent}{0pt}% needed for AMS classes
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \normalfont\ttfamily}%
    \def\{{\char`\{}
    \def\}{\char`\}}
    \def\textasciitilde{\char`\~}
    \item[]}
   {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 3: Logic of Types]{Chapter 3: The Logic of Types}
\author{Sergei Winitzki}
\date{November 22, 2017}
\institute[ABTB]{Academy by the Bay}

\makeatother

\begin{document}
\frame{\titlepage}
\begin{frame}{Tuples with names, or ``case classes''}

\begin{itemize}
\item Pair of values: \texttt{\textcolor{blue}{\footnotesize{}val a:\ (Int,
String) = (123, \textquotedbl{}xyz\textquotedbl{})}}{\footnotesize \par}
\item For \emph{convenience}, we can define a name for this type:\\
 \texttt{\textcolor{blue}{\footnotesize{}type MyPair = (Int, String);
val a:\ MyPair = (123, \textquotedbl{}xyz\textquotedbl{})}}{\footnotesize \par}
\item We can define a name for each value and also for the type:\texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}case class MySocks(size:\ Double,
color:\ String)}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val a:\ MySocks = MySocks(10.5,
\textquotedbl{}white\textquotedbl{})}}{\footnotesize \par}
\item Case classes can be nested: \texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}case class BagOfSocks(socks:\ MySocks,
count:\ Int)}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val bag = BagOfSocks(MySocks(10.5,
\textquotedbl{}white\textquotedbl{}), 6)}}{\footnotesize \par}
\item Parts of the case class can be accessed by name: \texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val c:\ String = bag.socks.color}}{\footnotesize \par}
\item Parts can be given in any order by using names:\texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val y = MySocks(color = \textquotedbl{}black\textquotedbl{},
size = 11.0) }}{\footnotesize \par}
\item Default values can be defined for parts: \texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}case class Shirt(color:\ String
= \textquotedbl{}blue\textquotedbl{}, hasHoles:\ Boolean = false)}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val sock = Shirt(hasHoles
= true)}}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Tuples with one element and with zero elements}

\begin{itemize}
\item A tuple type expression \texttt{\textcolor{blue}{\footnotesize{}(Int,
String)}} is special syntax for parameterized type \texttt{\textcolor{blue}{\footnotesize{}Tuple2{[}Int,
String{]}}}{\footnotesize \par}
\item Case class with no parts is called a ``case object''
\item What are tuples with one element or with zero elements?
\begin{itemize}
\item There is no \texttt{\textcolor{blue}{\footnotesize{}Tuple0}} \textendash{}
it is a special type called \texttt{\textcolor{blue}{\footnotesize{}Unit}}{\footnotesize \par}
\end{itemize}
\end{itemize}
\begin{center}
\begin{tabular}{|c|c|}
\hline 
\textbf{Tuples} & \textbf{Case classes}\tabularnewline
\hline 
\hline 
\texttt{\textcolor{blue}{\footnotesize{}(123, \textquotedbl{}xyz\textquotedbl{}):\ Tuple2{[}Int,
String{]}}} & \texttt{\textcolor{blue}{\footnotesize{}case class A(x:\ Int, y:\ String)}}\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}(123,):\ Tuple1{[}Int{]}}} & \texttt{\textcolor{blue}{\footnotesize{}case class B(z:\ Int)}}\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}(): Unit}} & \texttt{\textcolor{blue}{\footnotesize{}case object C}}\tabularnewline
\hline 
\end{tabular}
\par\end{center}
\begin{itemize}
\item Case classes can have one or more type parameters: \\
\texttt{\textcolor{blue}{\footnotesize{}case class Pairs{[}A, B{]}(left:\ A,
right:\ B, count:\ Int)}}{\footnotesize \par}
\item The ``\texttt{\textcolor{blue}{\footnotesize{}Tuple}}'' types could
be defined by this code:\texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}case class Tuple2{[}A, B{]}(\_1:\ A,
\_2:\ B)}}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Pattern-matching syntax for case classes}

Scala allows pattern matching in two places:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}val }}\textcolor{blue}{\emph{\footnotesize{}pattern}}\texttt{\textcolor{blue}{\footnotesize{}
= ...}} (value assignment)
\item \texttt{\textcolor{blue}{\footnotesize{}case }}\textcolor{blue}{\emph{\footnotesize{}pattern}}\texttt{\textcolor{blue}{\footnotesize{}
}}\textcolor{blue}{\footnotesize{}$\Rightarrow$}\texttt{\textcolor{blue}{\footnotesize{}
...}} (partial function)
\end{itemize}
Examples with case classes:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}val a = MySocks(10.5, \textquotedbl{}white\textquotedbl{})}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val MySocks(x, y) = a}}{\footnotesize \par}
\item \texttt{\textcolor{blue}{\footnotesize{}val f:\ BagOfSocks$\Rightarrow$Int
= \{ case BagOfSocks(MySocks(s, c), z)$\Rightarrow$...\}}}{\footnotesize \par}
\item \texttt{\textcolor{blue}{\footnotesize{}def f(b:\ BagOfSocks):\ String
= b match \{ }}~\\
\texttt{\textcolor{blue}{\footnotesize{}\  \ case BagOfSocks(MySocks(s,
c), z) $\Rightarrow$ c}}~\\
\texttt{\textcolor{blue}{\footnotesize{}\}}}{\footnotesize \par}
\item Note: \texttt{\textcolor{blue}{\footnotesize{}s}}, \texttt{\textcolor{blue}{\footnotesize{}c}},
\texttt{\textcolor{blue}{\footnotesize{}z}} are defined as \textbf{pattern
variables} of correct types
\end{itemize}
\end{frame}

\begin{frame}{Disjunction type: \texttt{Either{[}A, B{]}}}

Example: \texttt{\textcolor{blue}{\footnotesize{}Either{[}String,
Int{]}}} 
\begin{itemize}
\item Represents a value that is \emph{either} a \texttt{\textcolor{blue}{\footnotesize{}String}}
or an \texttt{\textcolor{blue}{\footnotesize{}Int}} (but not both)
\item Example values: \texttt{\textcolor{blue}{\footnotesize{}Left(\textquotedbl{}blah\textquotedbl{})}}
or \texttt{\textcolor{blue}{\footnotesize{}Right(123)}}{\footnotesize \par}
\item Use pattern matching to distinguish ``left'' from ``right'':
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~logError(x: Either{[}String,~Int{]}): Int~=~x~match~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~Left(error)~$\Rightarrow$~println(s\textquotedbl{}Got~error:~\$error\textquotedbl{});~-1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~Right(res)~$\Rightarrow$~res}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}\textsf{\textcolor{gray}{\footnotesize{}~//~Left(``blah'')~and~Right(123)~are~possible~values~of~type~Either{[}String,~Int{]}}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Now \texttt{\textcolor{blue}{\footnotesize{}logError(Right(123))}}
returns \texttt{\textcolor{blue}{\footnotesize{}123}} while \texttt{\textcolor{blue}{\footnotesize{}logError(Left(\textquotedbl{}bad
result\textquotedbl{}))}} prints the error and returns \texttt{\textcolor{blue}{\footnotesize{}-1}}{\footnotesize \par}
\item The \texttt{\textcolor{blue}{\footnotesize{}case}} expression chooses
among possible values of a given type
\begin{itemize}
\item Note the similarity with this code:
\end{itemize}
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~f(x:~Int):~Int~=~x~match~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~0~$\Rightarrow$~println(s\textquotedbl{}error:~must~be~nonzero\textquotedbl{});~-1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~1~$\Rightarrow$~println(s\textquotedbl{}error:~must~be~greater~than~1\textquotedbl{});~-1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~res~$\Rightarrow$~res}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}\textsf{\textcolor{gray}{\footnotesize{}~//0~and~1~are~possible~values~of~type~Int}}{\footnotesize \par}
\end{lyxcode}
\end{frame}

\begin{frame}{More general disjunction types: using case classes}

In a future version of Scala 3, there is a short syntax for disjunction
types:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}type MyIntOrStr = Int | String}}{\footnotesize \par}
\item more generally, \texttt{\textcolor{blue}{\footnotesize{}type MyType
= List{[}Int{]} | Boolean | MySocks}}{\footnotesize \par}
\end{itemize}
For now, in Scala 2, we use the ``long syntax'':
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~MyType}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}case~class~HaveListInt(x:~List{[}Int{]})~extends~MyType}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}case~class~HaveBool(b:~Boolean)~extends~MyType}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}case~class~HaveSocks(socks:~MySocks)~extends~MyType}{\footnotesize \par}
\end{lyxcode}
Pattern-matching example:\texttt{\textcolor{blue}{\footnotesize{} }}{\footnotesize \par}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}exa{*}{*}{*}}{\footnotesize \par}
\end{lyxcode}
\end{frame}

\begin{frame}{Types and propositional logic}

\begin{itemize}
\item Tuple of functions:\\
 \texttt{\textcolor{blue}{\footnotesize{}val q:\ (Int $\Rightarrow$
Int, Int $\Rightarrow$ Int) = (x $\Rightarrow$ x + 1, x $\Rightarrow$
x - 1)}}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Summary}

\begin{itemize}
\item What problems can we solve now?
\begin{itemize}
\item Compute mathematical expressions involving sums, products, and quantifiers,
based on integer ranges (such as $\sum_{k=1}^{n}f(k)$ etc.)
\item Implement functions that take or return other functions
\item Work on collections using \texttt{\textcolor{blue}{\footnotesize{}map}}
and other library methods
\end{itemize}
\item What kinds of problems are not solved with these tools?
\begin{itemize}
\item Compute the smallest $n$ such that $f(f(f(...f(1)...)>1000$, where
the function $f$ is applied $n$ times.
\item Find the $k$-th largest element in an (unsorted) array of integers.
\item Perform binary search over a sorted array.
\end{itemize}
\item Why can't we solve such problems yet?
\begin{itemize}
\item Because we can't yet put \emph{mathematical induction} into code
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Exercises}

\begin{enumerate}
\item Define a function of type \texttt{\textcolor{blue}{\footnotesize{}Seq{[}Double{]}
=> Seq{[}Double{]}}} that ``normalizes'' the sequence: it finds
the element having the max.~absolute value and, if that value is
nonzero, divides all elements by that factor.
\item Define a function of type \texttt{\textcolor{blue}{\footnotesize{}Seq{[}Seq{[}Int{]}{]}
=> Seq{[}Seq{[}Int{]}{]}}} that adds 20 to every element of every
inner sequence.
\item An integer $n$ is called ``3-factor'' if it is divisible by only
three different integers $j$ such that $2\leq j<n$. Compute the
set of all ``3-factor'' integers $n$ among $n\in[1,...,1000]$
.
\item Given a function $f$ of type \texttt{\textcolor{blue}{\footnotesize{}Int
=> Boolean}}, an integer $n$ is called ``3-$f$'' if there are
only three different integers $j\in[1,...,n]$ such that $f(j)$ returns
\texttt{\textcolor{blue}{\footnotesize{}true}}. Define a function
that takes $f$ as an argument and returns a sequence of all ``3-$f$''
integers among $n\in[1,...,1000]$. What is the type of that function?
Rewrite Exercise~3 using that function.
\item Define a function that takes two functions \texttt{\textcolor{blue}{\footnotesize{}f:~Int
=> Double}} and \texttt{\textcolor{blue}{\footnotesize{}g:~Double
=> String}} as arguments, and returns a new function that computes
the functional composition of \texttt{\textcolor{blue}{\footnotesize{}f}}
and \texttt{\textcolor{blue}{\footnotesize{}g}}.
\end{enumerate}
\end{frame}

\end{document}
