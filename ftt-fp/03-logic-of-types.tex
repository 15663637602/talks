%% LyX 2.2.0 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 % this default might be overridden by plain title style
 \newcommand\makebeamertitle{\frame{\maketitle}}%
 % (ERT) argument for the TOC
 \AtBeginDocument{%
   \let\origtableofcontents=\tableofcontents
   \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
   \def\gobbletableofcontents#1{\origtableofcontents}
 }
 \newenvironment{lyxcode}
   {\par\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \setlength{\listparindent}{0pt}% needed for AMS classes
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \normalfont\ttfamily}%
    \def\{{\char`\{}
    \def\}{\char`\}}
    \def\textasciitilde{\char`\~}
    \item[]}
   {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 3: Logic of Types]{Chapter 3: The Logic of Types}
\author{Sergei Winitzki}
\date{November 22, 2017}
\institute[ABTB]{Academy by the Bay}

\makeatother

\begin{document}
\frame{\titlepage}
\begin{frame}{Tuples with names, or ``case classes''}

\begin{itemize}
\item Pair of values: \texttt{\textcolor{blue}{\footnotesize{}val a:\ (Int,
String) = (123, \textquotedbl{}xyz\textquotedbl{})}}{\footnotesize \par}
\item For \emph{convenience}, we can define a name for this type:\\
 \texttt{\textcolor{blue}{\footnotesize{}type MyPair = (Int, String);
val a:\ MyPair = (123, \textquotedbl{}xyz\textquotedbl{})}}{\footnotesize \par}
\item We can define a name for each value and also for the type:\texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}case class MySocks(size:\ Double,
color:\ String)}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val a:\ MySocks = MySocks(10.5,
\textquotedbl{}white\textquotedbl{})}}{\footnotesize \par}
\item Case classes can be nested: \texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}case class BagOfSocks(socks:\ MySocks,
count:\ Int)}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val bag = BagOfSocks(MySocks(10.5,
\textquotedbl{}white\textquotedbl{}), 6)}}{\footnotesize \par}
\item Parts of the case class can be accessed by name: \texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val c:\ String = bag.socks.color}}{\footnotesize \par}
\item Parts can be given in any order by using names:\texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val y = MySocks(color = \textquotedbl{}black\textquotedbl{},
size = 11.0) }}{\footnotesize \par}
\item Default values can be defined for parts: \texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}case class Shirt(color:\ String
= \textquotedbl{}blue\textquotedbl{}, hasHoles:\ Boolean = false)}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val sock = Shirt(hasHoles
= true)}}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Tuples with one element and with zero elements}

\begin{itemize}
\item A tuple type expression \texttt{\textcolor{blue}{\footnotesize{}(Int,
String)}} is special syntax for parameterized type \texttt{\textcolor{blue}{\footnotesize{}Tuple2{[}Int,
String{]}}}{\footnotesize \par}
\item Case class with no parts is called a ``case object''
\item What are tuples with one element or with zero elements?
\begin{itemize}
\item There is no \texttt{\textcolor{blue}{\footnotesize{}Tuple0}} \textendash{}
it is a special type called \texttt{\textcolor{blue}{\footnotesize{}Unit}}{\footnotesize \par}
\end{itemize}
\end{itemize}
\begin{center}
\begin{tabular}{|c|c|}
\hline 
\textbf{Tuples} & \textbf{Case classes}\tabularnewline
\hline 
\hline 
\texttt{\textcolor{blue}{\footnotesize{}(123, \textquotedbl{}xyz\textquotedbl{}):\ Tuple2{[}Int,
String{]}}} & \texttt{\textcolor{blue}{\footnotesize{}case class A(x:\ Int, y:\ String)}}\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}(123,):\ Tuple1{[}Int{]}}} & \texttt{\textcolor{blue}{\footnotesize{}case class B(z:\ Int)}}\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}(): Unit}} & \texttt{\textcolor{blue}{\footnotesize{}case object C}}\tabularnewline
\hline 
\end{tabular}
\par\end{center}
\begin{itemize}
\item Case classes can have one or more type parameters: \\
\texttt{\textcolor{blue}{\footnotesize{}case class Pairs{[}A, B{]}(left:\ A,
right:\ B, count:\ Int)}}{\footnotesize \par}
\item The ``\texttt{\textcolor{blue}{\footnotesize{}Tuple}}'' types could
be defined by this code:\texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}case class Tuple2{[}A, B{]}(\_1:\ A,
\_2:\ B)}}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Pattern-matching syntax for case classes}

Scala allows pattern matching in two places:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}val }}\textcolor{blue}{\emph{\footnotesize{}pattern}}\texttt{\textcolor{blue}{\footnotesize{}
= ...}} (value assignment)
\item \texttt{\textcolor{blue}{\footnotesize{}case }}\textcolor{blue}{\emph{\footnotesize{}pattern}}\texttt{\textcolor{blue}{\footnotesize{}
}}\textcolor{blue}{\footnotesize{}$\Rightarrow$}\texttt{\textcolor{blue}{\footnotesize{}
...}} (partial function)
\end{itemize}
Examples with case classes:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}val a = MySocks(10.5, \textquotedbl{}white\textquotedbl{})}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val MySocks(x, y) = a}}{\footnotesize \par}
\item \texttt{\textcolor{blue}{\footnotesize{}val f:\ BagOfSocks$\Rightarrow$Int
= \{ case BagOfSocks(MySocks(s, c), z)$\Rightarrow$...\}}}{\footnotesize \par}
\item \texttt{\textcolor{blue}{\footnotesize{}def f(b:\ BagOfSocks):\ String
= b match \{ }}~\\
\texttt{\textcolor{blue}{\footnotesize{}\  \ case BagOfSocks(MySocks(s,
c), z) $\Rightarrow$ c}}~\\
\texttt{\textcolor{blue}{\footnotesize{}\}}}{\footnotesize \par}
\item Note: \texttt{\textcolor{blue}{\footnotesize{}s}}, \texttt{\textcolor{blue}{\footnotesize{}c}},
\texttt{\textcolor{blue}{\footnotesize{}z}} are defined as \textbf{pattern
variables} of correct types
\end{itemize}
\end{frame}

\begin{frame}{Disjunction type: \texttt{Either{[}A, B{]}}}

Example: \texttt{\textcolor{blue}{\footnotesize{}Either{[}String,
Int{]}}} (may be used for error reporting)
\begin{itemize}
\item Represents a value that is \emph{either} a \texttt{\textcolor{blue}{\footnotesize{}String}}
or an \texttt{\textcolor{blue}{\footnotesize{}Int}} (but not both)
\item Example values: \texttt{\textcolor{blue}{\footnotesize{}Left(\textquotedbl{}blah\textquotedbl{})}}
or \texttt{\textcolor{blue}{\footnotesize{}Right(123)}}{\footnotesize \par}
\item Use pattern matching to distinguish ``left'' from ``right'':
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~logError(x:~Either{[}String,~Int{]}):~Int~=~x~match~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~Left(error)~$\Rightarrow$~println(s\textquotedbl{}Got~error:~\$error\textquotedbl{});~-1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~Right(res)~$\Rightarrow$~res}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}\textsf{\textcolor{gray}{\footnotesize{}~//~Left(``blah'')~and~Right(123)~are~possible~values~of~type~Either{[}String,~Int{]}}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Now \texttt{\textcolor{blue}{\footnotesize{}logError(Right(123))}}
returns \texttt{\textcolor{blue}{\footnotesize{}123}} while \texttt{\textcolor{blue}{\footnotesize{}logError(Left(\textquotedbl{}bad
result\textquotedbl{}))}} prints the error and returns \texttt{\textcolor{blue}{\footnotesize{}-1}}{\footnotesize \par}
\item The \texttt{\textcolor{blue}{\footnotesize{}case}} expression chooses
among possible values of a given type
\begin{itemize}
\item Note the similarity with this code:
\end{itemize}
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~f(x:~Int):~Int~=~x~match~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~0~$\Rightarrow$~println(s\textquotedbl{}error:~must~be~nonzero\textquotedbl{});~-1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~1~$\Rightarrow$~println(s\textquotedbl{}error:~must~be~greater~than~1\textquotedbl{});~-1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~res~$\Rightarrow$~res}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}\textsf{\textcolor{gray}{\footnotesize{}~//0~and~1~are~possible~values~of~type~Int}}{\footnotesize \par}
\end{lyxcode}
\end{frame}

\begin{frame}{More general disjunction types: using case classes}

A future version of Scala 3 has a short syntax for disjunction types:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}type MyIntOrStr = Int | String}}{\footnotesize \par}
\item more generally, \texttt{\textcolor{blue}{\footnotesize{}type MyType
= List{[}Int{]} | (Int, Boolean) | MySocks}}{\footnotesize \par}
\begin{itemize}
\item Some (experimental) Scala libraries also provide shorter syntax
\end{itemize}
\end{itemize}
For now, in Scala 2, we use the ``long syntax'':

(specify a name for each case and for each part, use ``trait'' /
``extends'')
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~MyType}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~class~HaveListInt(x:~List{[}Int{]})~extends~MyType}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~class~HaveIntBool(s:~Int,~b:~Boolean)~extends~MyType}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~class~HaveSocks(socks:~MySocks)~extends~MyType}{\footnotesize \par}
\end{lyxcode}
Pattern-matching example:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~x:~MyType~=~???}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}x~match~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~HaveListInt(lst)~$\Rightarrow$~...}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~HaveIntBool(p,~q)~$\Rightarrow$~...}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~HaveSocks(s)~$\Rightarrow$~...}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize \par}
\end{lyxcode}
\end{frame}

\begin{frame}{Types and propositional logic}


\framesubtitle{The Curry-Howard correspondence}

This code:\texttt{\textcolor{blue}{\footnotesize{} val x:\ T = ...}}
means that we can compute a value of type \texttt{\textcolor{blue}{\footnotesize{}T}}
as part of our program
\begin{itemize}
\item Let's denote this \emph{proposition} by ${\cal CH}(T)$ \textendash{}
``Code Has a value of type \texttt{\textcolor{blue}{\footnotesize{}T}}''
\item We have the following correspondence:
\end{itemize}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{Type} & \textbf{Proposition} & \textbf{Short notation}\tabularnewline
\hline 
\hline 
\texttt{\textcolor{blue}{\footnotesize{}T}} & ${\cal CH}(T)$ & $T$\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}(A, B)}} & ${\cal CH}(A)$ \emph{and} ${\cal CH}(B)$ & $A\,\&\,B$\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}Either{[}A, B{]}}} & ${\cal CH}(A)$ \emph{or} ${\cal CH}(B)$ & $A\,|\,B$\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}A $\Rightarrow$ B}} & ${\cal CH}(A)$ \emph{implies} ${\cal CH}(B)$ & $A\Rightarrow B$\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}Unit}} & \emph{true} & 1\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}Nothing}} & \emph{false} & 0\tabularnewline
\hline 
\end{tabular}
\par\end{center}
\begin{itemize}
\item type parameter \texttt{\textcolor{blue}{\footnotesize{}{[}T{]}}} means
$\forall T$, for example the type of the function\texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}def dupl{[}A{]}(x:\ A):\ (A,
A)}} corresponds to the (valid) proposition:\\
$\forall A:A\Rightarrow(A\,\&\,A)$
\end{itemize}
\end{frame}

\begin{frame}{Working with the CH correspondence}

\begin{itemize}
\item Any valid proposition can be implemented in code
\begin{center}
\begin{tabular}{|c|c|}
\hline 
\textbf{Proposition} & \textbf{Code}\tabularnewline
\hline 
\hline 
$\forall A:A\Rightarrow A$ & \texttt{\textcolor{blue}{\footnotesize{}def identity{[}A{]}(x:A):A
= x}}\tabularnewline
\hline 
$\forall A:A\Rightarrow1$ & \texttt{\textcolor{blue}{\footnotesize{}def toUnit{[}A{]}(x:A): Unit
= ()}}\tabularnewline
\hline 
$\forall A\forall B:A\Rightarrow A\,|\,B$ & \texttt{\textcolor{blue}{\footnotesize{}def inLeft{[}A,B{]}(x:A):Either{[}A,B{]}
= Left(x)}}\tabularnewline
\hline 
$\forall A\forall B:A\,\&\,B\Rightarrow A$ & \texttt{\textcolor{blue}{\footnotesize{}def first{[}A,B{]}(p:(A,B)):A
= p.\_1}}\tabularnewline
\hline 
$\forall A\forall B:A\Rightarrow(B\Rightarrow A)$ & \texttt{\textcolor{blue}{\footnotesize{}def const{[}A,B{]}(x:A):B$\Rightarrow$A
= (y:B)$\Rightarrow$x}}\tabularnewline
\hline 
\end{tabular}
\par\end{center}
\item Invalid propositions \emph{cannot be implemented} in code 
\begin{itemize}
\item Examples:\\
 $\forall A:1\Rightarrow A$; $\forall A\forall B:A\,|\,B\Rightarrow A$;
\\
$\forall A\forall B:A\Rightarrow A\,\&\,B$; $\forall A\forall B:(A\Rightarrow B)\Rightarrow A$
\end{itemize}
\item Given a type, can we decide whether it is implementable?
\begin{itemize}
\item Example: $\forall A\forall B:((((A\Rightarrow B)\Rightarrow B)\Rightarrow A)\Rightarrow B)\Rightarrow B$
\item Propositional constructive logic has a decision algorithm
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Working with the CH correspondence}


\framesubtitle{Implications for programming language design}
\begin{itemize}
\item The CH correspondence maps the type system of each programming language
into a certain system of logical propositions 
\item Scala, Haskell, OCaml, F\#, Swift, Rust, etc.~are mapped into the
full constructive logic (all logical operations are available)
\begin{itemize}
\item C, C++, Java, C\#, etc.~are mapped to \emph{incomplete} logics \textendash{}
without ``or'' and without ``true''
\item Python, JavaScript, Ruby, Clojure, etc.~have only one type (``any
value'') and are mapped to logics with only one proposition
\end{itemize}
\item The CH correspondence is a principle for designing type systems:
\begin{itemize}
\item Choose a complete logic, free of inconsistency
\begin{itemize}
\item Mathematicians have studied all kinds of logics and determined which
ones are interesting, and found the minimal sets of axioms for them
\end{itemize}
\item Provide a type constructor for each basic operation (e.g.~``\emph{or}'',
``\emph{and}'')
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Working with the CH correspondence}

\begin{itemize}
\item What problems can we solve now?
\end{itemize}
\end{frame}

\begin{frame}{Summary}

\begin{itemize}
\item What problems can we solve now?
\end{itemize}
\end{frame}

\begin{frame}{Exercises}

\begin{enumerate}
\item a
\end{enumerate}
\end{frame}

\end{document}
