%% LyX 2.2.0 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{amsmath}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 % this default might be overridden by plain title style
 \newcommand\makebeamertitle{\frame{\maketitle}}%
 % (ERT) argument for the TOC
 \AtBeginDocument{%
   \let\origtableofcontents=\tableofcontents
   \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
   \def\gobbletableofcontents#1{\origtableofcontents}
 }
 \newenvironment{lyxcode}
   {\par\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \setlength{\listparindent}{0pt}% needed for AMS classes
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \normalfont\ttfamily}%
    \def\{{\char`\{}
    \def\}{\char`\}}
    \def\textasciitilde{\char`\~}
    \item[]}
   {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 3: Logic of Types]{Chapter 3: The Logic of Types}
\author{Sergei Winitzki}
\date{November 22, 2017}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{navigation symbols}{}

\makeatother

\begin{document}
\frame{\titlepage}
\begin{frame}{Types and syntax of functions returning functions}


\framesubtitle{``Curried functions'' in Scala}
\begin{itemize}
\item A function that returns a function:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~logWith(topic:~String):~(String~$\Rightarrow$~Unit)~=~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~x~$\Rightarrow$~println(s\textquotedbl{}\$topic:~\$x\textquotedbl{})}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Calling this function:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~statusLogger:~(String~$\Rightarrow$~Unit)~=~logWith(\textquotedbl{}Result~status\textquotedbl{})}~\\
\textcolor{blue}{\footnotesize{}~}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}primaryLogger(\textquotedbl{}success\textquotedbl{})}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item One-line syntax for calling: \texttt{\textcolor{blue}{\footnotesize{}logWith(\textquotedbl{}Result
status\textquotedbl{})(\textquotedbl{}success\textquotedbl{})}} 
\item Alternative syntax (``\href{https://en.wikipedia.org/wiki/Currying}{Curried}''
function): 
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~logWith:~String~$\Rightarrow$~String~$\Rightarrow$~Unit~=~}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~topic~$\Rightarrow$~x~$\Rightarrow$~println(s\textquotedbl{}\$topic:~\$x\textquotedbl{})}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Syntax convention: \texttt{\textcolor{blue}{\footnotesize{}x}} \texttt{\textcolor{blue}{\footnotesize{}$\Rightarrow$
y}} \texttt{\textcolor{blue}{\footnotesize{}$\Rightarrow$}} \texttt{\textcolor{blue}{\footnotesize{}z}}
means \texttt{\textcolor{blue}{\footnotesize{}x}} \texttt{\textcolor{blue}{\footnotesize{}$\Rightarrow$
(y}} \texttt{\textcolor{blue}{\footnotesize{}$\Rightarrow$}} \texttt{\textcolor{blue}{\footnotesize{}z)}}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Functions with fully parametric types}


\framesubtitle{``No argument type left non-parametric''}

Compare these two functions (note tuple type syntax):
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~hypothenuse~=~(x:~Double,~y:~Double)~$\Rightarrow$~math.sqrt(x{*}x~+~y{*}y)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}def~swap:~((Double,~Double))~$\Rightarrow$~(Double,~Double)~=}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~\{~case~(x,~y)~$\Rightarrow$~(y,~x)~\}~}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item We can fully parameterize the argument types for \texttt{\textcolor{blue}{\footnotesize{}swap}}:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~swap{[}X,~Y{]}:~((X,~Y))~$\Rightarrow$~(Y,~X)~=~\{~case~(x,~y)~$\Rightarrow$~(y,~x)~\}~}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item (The first function is too specific to generalize the argument types.)
\item Note: Scala does not support a \texttt{\textcolor{blue}{\footnotesize{}val}}
with a parametric type
\begin{itemize}
\item Instead we can use \texttt{\textcolor{blue}{\footnotesize{}def}} or
parametric classes/traits
\end{itemize}
\item More examples:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~identity{[}T{]}:~(T~$\Rightarrow$~T)~=~x~$\Rightarrow$~x}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}def~const{[}C,~X{]}:~(C~$\Rightarrow$~X~$\Rightarrow$~C)~=~c~$\Rightarrow$~x~$\Rightarrow$~c}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}def~compose{[}X,~Y,~Z{]}(f:~X~$\Rightarrow$~Y,~g:~Y~$\Rightarrow$~Z):~X~$\Rightarrow$~Z~=~x~$\Rightarrow$~g(f(x))}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Functions with fully parametric types \emph{are} actually useful!
\end{itemize}
\end{frame}

\begin{frame}{Worked examples}

\begin{itemize}
\item For the functions \texttt{\textcolor{blue}{\footnotesize{}const}}
and \texttt{\textcolor{blue}{\footnotesize{}identity}} defined above,
what is \texttt{\textcolor{blue}{\footnotesize{}const(identity)}}
and what is its type? Write out the type parameters.
\item Define a function \texttt{\textcolor{blue}{\footnotesize{}twice}}
that takes a function $f$ as its argument and returns a \emph{function}
that applies $f$ twice. For example, \texttt{\textcolor{blue}{\footnotesize{}twice(x}}
\texttt{\textcolor{blue}{\footnotesize{}$\Rightarrow$}} \texttt{\textcolor{blue}{\footnotesize{}x+3)}}
should return a function equivalent to \texttt{\textcolor{blue}{\footnotesize{}x}}
\texttt{\textcolor{blue}{\footnotesize{}$\Rightarrow$}} \texttt{\textcolor{blue}{\footnotesize{}x+6}}.
Find the type of \texttt{\textcolor{blue}{\footnotesize{}twice.}}{\footnotesize \par}
\item What does \texttt{\textcolor{blue}{\footnotesize{}twice(twice)}} do?
Test your answer on the expression \texttt{\textcolor{blue}{\footnotesize{}twice(twice{[}Int{]})(x}}
\texttt{\textcolor{blue}{\footnotesize{}$\Rightarrow$}} \texttt{\textcolor{blue}{\footnotesize{}x+3)(10)}}.
What are the type parameters here?
\item Implement a function that applies a given function $f$ repeatedly
to an initial value $x_{0}$, until a given condition function \texttt{\textcolor{blue}{\footnotesize{}cond}}
returns true:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~converge{[}X{]}(f:~X~$\Rightarrow$~X,~x0:~X,~cond:~X~$\Rightarrow$~Boolean):~X~=~???}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Take a function with two arguments, fix the value of the first argument,
and return the function of the remaining one argument. Define this
operation as a function with fully parametric types:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~firstArg{[}X,~Y,~Z{]}(f:~(X,~Y)~$\Rightarrow$~Z,~x0:~X):~Y~$\Rightarrow$~Z~=~???}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Infer missing types: \texttt{\textcolor{blue}{\footnotesize{}def p{[}}}...\texttt{\textcolor{blue}{\footnotesize{}{]}:}}...\texttt{\textcolor{blue}{\footnotesize{} =
f $\Rightarrow$ f(2)}}. Does \texttt{\textcolor{blue}{\footnotesize{}f(f)}}
compile?
\item Infer missing types: \texttt{\textcolor{blue}{\footnotesize{}def p{[}}}...\texttt{\textcolor{blue}{\footnotesize{}{]}:}}...\texttt{\textcolor{blue}{\footnotesize{} =
f $\Rightarrow$ g $\Rightarrow$ g(f)}}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Exercises I}

\begin{itemize}
\item For the function \texttt{\textcolor{blue}{\footnotesize{}identity}}
defined above, what is \texttt{\textcolor{blue}{\footnotesize{}identity(identity)}}
and what is its type? Same question for \texttt{\textcolor{blue}{\footnotesize{}identity(const)}}. 
\item For the function \texttt{\textcolor{blue}{\footnotesize{}const}} above,
what is \texttt{\textcolor{blue}{\footnotesize{}const(const)}}, what
is its type?
\item For the function \texttt{\textcolor{blue}{\footnotesize{}twice}} above,
what does \texttt{\textcolor{blue}{\footnotesize{}twice(twice(twice)))}}
do? Test your answer on an example.
\item Define a function \texttt{\textcolor{blue}{\footnotesize{}thrice}}
that applies its argument function 3 times, similarly to \texttt{\textcolor{blue}{\footnotesize{}twice}}.
What does \texttt{\textcolor{blue}{\footnotesize{}thrice(thrice(thrice)))}}
do?
\item Define a function \texttt{\textcolor{blue}{\footnotesize{}ence}} that
applies a given function $n$ times.
\item Take a function with two arguments, and define a function of these
two arguments swapped. Package this functionality as a function \texttt{\textcolor{blue}{\footnotesize{}swapFunc}}
with fully parametric types. To test: 
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~f(x:~Int,~y:~Int)~=~x~-~y}\textsf{\textcolor{gray}{\footnotesize{}~//~check~that~f(10,~2)~gives~8}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}val~g~=~swapFunc(f)}\textsf{\textcolor{gray}{\footnotesize{}~~//~now~check~that~g(10,~2)~gives~\textendash{}~8}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Infer missing types: \texttt{\textcolor{blue}{\footnotesize{}def r{[}}}...\texttt{\textcolor{blue}{\footnotesize{}{]}:}}...\texttt{\textcolor{blue}{\footnotesize{} =
f $\Rightarrow$ f(g $\Rightarrow$ g(f))}}{\footnotesize \par}
\item Infer missing types: \texttt{\textcolor{blue}{\footnotesize{}def s{[}}}...\texttt{\textcolor{blue}{\footnotesize{}{]}:}}...\texttt{\textcolor{blue}{\footnotesize{} =
f $\Rightarrow$ g $\Rightarrow$ g(x $\Rightarrow$ f(g(x)))}}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Tuples with names: ``case classes''}

\begin{itemize}
\item Pair of values: \texttt{\textcolor{blue}{\footnotesize{}val a:\ (Int,
String) = (123, \textquotedbl{}xyz\textquotedbl{})}}{\footnotesize \par}
\item For convenience, we can define a name for this type:\\
 \texttt{\textcolor{blue}{\footnotesize{}type MyPair = (Int, String);
val a:\ MyPair = (123, \textquotedbl{}xyz\textquotedbl{})}}{\footnotesize \par}
\item We can define a name for each value and also for the type:\texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}case class MySocks(size:\ Double,
color:\ String)}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val a:\ MySocks = MySocks(10.5,
\textquotedbl{}white\textquotedbl{})}}{\footnotesize \par}
\item Case classes can be nested: \texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}case class BagOfSocks(socks:\ MySocks,
count:\ Int)}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val bag = BagOfSocks(MySocks(10.5,
\textquotedbl{}white\textquotedbl{}), 6)}}{\footnotesize \par}
\item Parts of the case class can be accessed by name: \texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val c:\ String = bag.socks.color}}{\footnotesize \par}
\item Parts can be given in any order by using names:\texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val y = MySocks(color = \textquotedbl{}black\textquotedbl{},
size = 11.0) }}{\footnotesize \par}
\item Default values can be defined for parts: \texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}case class Shirt(color:\ String
= \textquotedbl{}blue\textquotedbl{}, hasHoles:\ Boolean = false)}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val sock = Shirt(hasHoles
= true)}}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Tuples with one element and with zero elements}

\begin{itemize}
\item A tuple type expression \texttt{\textcolor{blue}{\footnotesize{}(Int,
String)}} is special syntax for parameterized type \texttt{\textcolor{blue}{\footnotesize{}Tuple2{[}Int,
String{]}}}{\footnotesize \par}
\item Case class with no parts is called a ``case object''
\item What are tuples with one element or with zero elements?
\begin{itemize}
\item There is no \texttt{\textcolor{blue}{\footnotesize{}Tuple0}} \textendash{}
it is a special type called \texttt{\textcolor{blue}{\footnotesize{}Unit}}{\footnotesize \par}
\end{itemize}
\end{itemize}
\begin{center}
\begin{tabular}{|c|c|}
\hline 
\textbf{Tuples} & \textbf{Case classes}\tabularnewline
\hline 
\hline 
\texttt{\textcolor{blue}{\footnotesize{}(123, \textquotedbl{}xyz\textquotedbl{}):\ Tuple2{[}Int,
String{]}}} & \texttt{\textcolor{blue}{\footnotesize{}case class A(x:\ Int, y:\ String)}}\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}(123,):\ Tuple1{[}Int{]}}} & \texttt{\textcolor{blue}{\footnotesize{}case class B(z:\ Int)}}\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}(): Unit}} & \texttt{\textcolor{blue}{\footnotesize{}case object C}}\tabularnewline
\hline 
\end{tabular}
\par\end{center}
\begin{itemize}
\item Case classes can have one or more type parameters: \\
\texttt{\textcolor{blue}{\footnotesize{}case class Pairs{[}A, B{]}(left:\ A,
right:\ B, count:\ Int)}}{\footnotesize \par}
\item The ``\texttt{\textcolor{blue}{\footnotesize{}Tuple}}'' types could
be defined by this code:\texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}case class Tuple2{[}A, B{]}(\_1:\ A,
\_2:\ B)}}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Pattern-matching syntax for case classes}

Scala allows pattern matching in two places:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}val }}\textcolor{blue}{\emph{\footnotesize{}pattern}}\texttt{\textcolor{blue}{\footnotesize{}
= ...}} (value assignment)
\item \texttt{\textcolor{blue}{\footnotesize{}case }}\textcolor{blue}{\emph{\footnotesize{}pattern}}\texttt{\textcolor{blue}{\footnotesize{}
}}\textcolor{blue}{\footnotesize{}$\Rightarrow$}\texttt{\textcolor{blue}{\footnotesize{}
...}} (partial function)
\end{itemize}
Examples with case classes:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}val a = MySocks(10.5, \textquotedbl{}white\textquotedbl{})}}~\\
\texttt{\textcolor{blue}{\footnotesize{}val MySocks(x, y) = a}}{\footnotesize \par}
\item \texttt{\textcolor{blue}{\footnotesize{}val f:\ BagOfSocks$\Rightarrow$Int
= \{ case BagOfSocks(MySocks(s, c), z)$\Rightarrow$...\}}}{\footnotesize \par}
\item \texttt{\textcolor{blue}{\footnotesize{}def f(b:\ BagOfSocks):\ String
= b match \{ }}~\\
\texttt{\textcolor{blue}{\footnotesize{}\  \ case BagOfSocks(MySocks(s,
c), z) $\Rightarrow$ c}}~\\
\texttt{\textcolor{blue}{\footnotesize{}\}}}{\footnotesize \par}
\item Note: \texttt{\textcolor{blue}{\footnotesize{}s}}, \texttt{\textcolor{blue}{\footnotesize{}c}},
\texttt{\textcolor{blue}{\footnotesize{}z}} are defined as \textbf{pattern
variables} of correct types
\end{itemize}
\end{frame}

\begin{frame}{Disjunction types}

\begin{itemize}
\item Motivational examples:
\begin{itemize}
\item The roots of a quadratic equation are either a pair, or one, or none
\item Binary search gives either a found value and an index, or nothing
\item Computations that give a value or an error with a text message
\item Computer game states: several kinds of rooms, types players, etc.
\begin{itemize}
\item Each kind of room may have different sets of properties
\end{itemize}
\end{itemize}
\item We would like to be able to represent \emph{disjunctions} of sets
\begin{itemize}
\item A value that is \emph{either} \texttt{\textcolor{blue}{\footnotesize{}(Complex,
Complex)}} or \texttt{\textcolor{blue}{\footnotesize{}Complex}} or
empty \texttt{\textcolor{blue}{\footnotesize{}()}}{\footnotesize \par}
\item A value that is \emph{either} \texttt{\textcolor{blue}{\footnotesize{}(Int,
Int)}} or empty \texttt{\textcolor{blue}{\footnotesize{}()}}{\footnotesize \par}
\item A value that is \emph{either} an \texttt{\textcolor{blue}{\footnotesize{}Int}}
value or a \texttt{\textcolor{blue}{\footnotesize{}String}} error
message
\item A value that is one case class out of a number of case classes
\end{itemize}
\item Disjunction types represent such values as types
\end{itemize}
\end{frame}

\begin{frame}{Disjunction type: \texttt{Either{[}A, B{]}}}

Example: \texttt{\textcolor{blue}{\footnotesize{}Either{[}String,
Int{]}}} (may be used for error reporting)
\begin{itemize}
\item Represents a value that is \emph{either} a \texttt{\textcolor{blue}{\footnotesize{}String}}
or an \texttt{\textcolor{blue}{\footnotesize{}Int}} (but not both)
\item Example values: \texttt{\textcolor{blue}{\footnotesize{}Left(\textquotedbl{}blah\textquotedbl{})}}
or \texttt{\textcolor{blue}{\footnotesize{}Right(123)}}{\footnotesize \par}
\item Use pattern matching to distinguish ``left'' from ``right'':
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~logError(x:~Either{[}String,~Int{]}):~Int~=~x~match~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~Left(error)~$\Rightarrow$~println(s\textquotedbl{}Got~error:~\$error\textquotedbl{});~-1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~Right(res)~$\Rightarrow$~res}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}\textsf{\textcolor{gray}{\footnotesize{}~//~Left(``blah'')~and~Right(123)~are~possible~values~of~type~Either{[}String,~Int{]}}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Now \texttt{\textcolor{blue}{\footnotesize{}logError(Right(123))}}
returns \texttt{\textcolor{blue}{\footnotesize{}123}} while \texttt{\textcolor{blue}{\footnotesize{}logError(Left(\textquotedbl{}bad
result\textquotedbl{}))}} prints the error and returns \texttt{\textcolor{blue}{\footnotesize{}-1}}{\footnotesize \par}
\item The \texttt{\textcolor{blue}{\footnotesize{}case}} expression chooses
among possible values of a given type
\begin{itemize}
\item Note the similarity with this code:
\end{itemize}
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~f(x:~Int):~Int~=~x~match~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~0~$\Rightarrow$~println(s\textquotedbl{}error:~must~be~nonzero\textquotedbl{});~-1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~1~$\Rightarrow$~println(s\textquotedbl{}error:~must~be~greater~than~1\textquotedbl{});~-1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~res~$\Rightarrow$~res}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}\textsf{\textcolor{gray}{\footnotesize{}~//~0~and~1~are~possible~values~of~type~Int}}{\footnotesize \par}
\end{lyxcode}
\end{frame}

\begin{frame}{More general disjunction types: using case classes}

A future version of Scala 3 has a short syntax for disjunction types:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}type MyIntOrStr = Int | String}}{\footnotesize \par}
\item more generally, \texttt{\textcolor{blue}{\footnotesize{}type MyType
= List{[}Int{]} | (Int, Boolean) | MySocks}}{\footnotesize \par}
\begin{itemize}
\item Some libraries (scalaz, cats, shapeless) also provide shorter syntax
\end{itemize}
\end{itemize}
For now, in Scala 2, we use the ``long syntax'':

(specify names for each case and for each part, use ``\texttt{\textcolor{blue}{\footnotesize{}trait}}''
/ ``\texttt{\textcolor{blue}{\footnotesize{}extends}}'')
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~MyType}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~class~HaveListInt(x:~List{[}Int{]})~extends~MyType}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~class~HaveIntBool(s:~Int,~b:~Boolean)~extends~MyType}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~class~HaveSocks(socks:~MySocks)~extends~MyType}{\footnotesize \par}
\end{lyxcode}
Pattern-matching example:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~x:~MyType~=~if~(...)~HaveSocks(...)~else~HaveListInt(...)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}...~}\textsf{\textcolor{gray}{\footnotesize{}//~some~other~code~here}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}x~match~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~HaveListInt(lst)~$\Rightarrow$~...}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~HaveIntBool(p,~q)~$\Rightarrow$~...}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~HaveSocks(s)~$\Rightarrow$~...}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize \par}
\end{lyxcode}
\end{frame}

\begin{frame}{The most used disjunction type: \texttt{Option{[}T{]}}}

A simple implementation: 
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Option{[}T{]}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~class~Some{[}T{]}(t:~T)~extends~Option{[}T{]}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~object~None~extends~Option{[}Nothing{]}}{\footnotesize \par}
\end{lyxcode}
Pattern-matching example:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~saveDivide(x:~Double,~y:~Double):~Option{[}Double{]}~=~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~if~(y~==~0)~None~else~Some(x~/~y)}{\footnotesize \par}

\textsf{\textcolor{gray}{\footnotesize{}//~Example~usage:}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}val~result~=~safeDivide(1.0,~q)~match~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~Some(x)~$\Rightarrow$~previousResult~{*}~x}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~None~$\Rightarrow$~previousResult~}\textsf{\textcolor{gray}{\footnotesize{}//~provide~a~default~value}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize \par}
\end{lyxcode}
Many Scala library functions return an \texttt{\textcolor{blue}{\footnotesize{}Option{[}T{]}}}{\footnotesize \par}
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}find, headOption, reduceOption,
get}} (for\texttt{\textcolor{blue}{\footnotesize{} Map{[}K, V{]}}}),
etc.
\begin{itemize}
\item Note: \texttt{\textcolor{blue}{\footnotesize{}Option{[}T{]}}} is ``collection-like'':
has \texttt{\textcolor{blue}{\footnotesize{}map}}, \texttt{\textcolor{blue}{\footnotesize{}flatMap}},
\texttt{\textcolor{blue}{\footnotesize{}filter}}, \texttt{\textcolor{blue}{\footnotesize{}exists}}...
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Worked examples}

\begin{itemize}
\item What problems can we solve now?
\end{itemize}
\end{frame}

\begin{frame}{Exercises II}

\begin{enumerate}
\item a
\end{enumerate}
\end{frame}

\begin{frame}{Types and propositional logic}


\framesubtitle{The Curry-Howard correspondence}

This code:\texttt{\textcolor{blue}{\footnotesize{} val x:\ T = ...}}
means that \emph{we can compute a value} of type \texttt{\textcolor{blue}{\footnotesize{}T}}
as part of our program
\begin{itemize}
\item Let's denote this \emph{proposition} by ${\cal CH}(T)$ \textendash{}
``Code Has a value of type \texttt{\textcolor{blue}{\footnotesize{}T}}''
\item We have the following correspondence:
\end{itemize}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{Type} & \textbf{Proposition} & \textbf{Short notation}\tabularnewline
\hline 
\hline 
\texttt{\textcolor{blue}{\footnotesize{}T}} & ${\cal CH}(T)$ & $T$\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}(A, B)}} & ${\cal CH}(A)$ \emph{and} ${\cal CH}(B)$ & $A\times B$\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}Either{[}A, B{]}}} & ${\cal CH}(A)$ \emph{or} ${\cal CH}(B)$ & $A\oplus B$\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}A $\Rightarrow$ B}} & ${\cal CH}(A)$ \emph{implies} ${\cal CH}(B)$ & $A\Rightarrow B$\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}Unit}} & \emph{true} & 1\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}Nothing}} & \emph{false} & 0\tabularnewline
\hline 
\end{tabular}
\par\end{center}
\begin{itemize}
\item type parameter \texttt{\textcolor{blue}{\footnotesize{}{[}T{]}}} means
$\forall T$, for example the type of the function\texttt{\textcolor{blue}{\footnotesize{}}}~\\
\texttt{\textcolor{blue}{\footnotesize{}def dupl{[}A{]}(x:\ A):\ (A,
A)}} corresponds to the (valid) proposition:\\
$\forall A:A\Rightarrow A\times A$
\end{itemize}
\end{frame}

\begin{frame}{Working with the CH correspondence}

\begin{itemize}
\item Example 1:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~UserAction}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}case~class~SetName(first:~String,~last:~String)~extends~UserAction}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}case~class~SetEmail(email:~String)~extends~UserAction}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}case~class~SetUserId(id:~Long)~extends~UserAction}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Short notation: \texttt{\textcolor{blue}{\footnotesize{}UserAction}}
$=$ (\texttt{\textcolor{blue}{\footnotesize{}String}} $\times$ \texttt{\textcolor{blue}{\footnotesize{}String}})\texttt{\textcolor{blue}{\footnotesize{}
$\oplus$}} \texttt{\textcolor{blue}{\footnotesize{}String}} \texttt{\textcolor{blue}{\footnotesize{}$\oplus$}}
\texttt{\textcolor{blue}{\footnotesize{}Long}}{\footnotesize \par}
\item Example 2: parametric type
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Either3{[}A,~B,~C{]}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}case~class~Left{[}A,~B,~C{]}(x:~A)~extends~Either3{[}A,~B,~C{]}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}case~class~Middle{[}A,~B,~C{]}(x:~B)~extends~Either3{[}A,~B,~C{]}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}case~class~Right{[}A,~B,~C{]}(x:~C)~extends~Either3{[}A,~B,~C{]}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Short notation: $\forall A\forall B\forall C:$ Either3$[A,B,C]=A\oplus B\oplus C$
\end{itemize}
\end{frame}

\begin{frame}{Working with the CH correspondence}


\framesubtitle{Using known properties of propositional logic}
\begin{itemize}
\item Some standard identities in logic:
\begin{align*}
A\times1 & =A\\
A+1 & =1\\
(A\times B)\times C & =A\times(B\times C)\\
(A\oplus B)\oplus C & =A\oplus(B\oplus C)\\
A\times(B\oplus C) & =(A\times B)\oplus(A\times C)\\
A\oplus(B\times C) & =(A\oplus B)\times(A\oplus C)
\end{align*}
\item Each identity gives functions that map both ways
\item Some of these identities yield\emph{ isomorphisms of types}
\begin{itemize}
\item Which ones do \emph{not} yield isomorphisms, and why?
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Working with the CH correspondence}


\framesubtitle{Algebraic computations with types}
\begin{itemize}
\item Example 3: Recursive type
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~IntList}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~object~Empty~extends~IntList}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~class~Nonempty(head:~Int,~tail:~IntList)~extends~IntList}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Short notation: (the sign ``$\equiv$'' means type isomorphism)\texttt{\textcolor{blue}{\footnotesize{}
\begin{align*}
\text{IntList} & \equiv1\oplus\text{Int}\times\text{IntList}\equiv1\oplus\text{Int}\times(1\oplus\text{Int}\times(1\oplus\text{Int}\times(...)...)\\
 & \equiv1\oplus\text{Int}\oplus\text{Int}\times\text{Int}\oplus\text{Int}\times\text{Int}\times\text{Int}\oplus...
\end{align*}
}}{\footnotesize \par}
\item Recursive list of integers $\equiv$ disjunction of empty, list of
1 integer, list of 2 integers, etc.
\end{itemize}
\end{frame}

\begin{frame}{Working with the CH correspondence}

\begin{itemize}
\item Any valid proposition can be implemented in code\\
~

\begin{tabular}{|c|c|}
\hline 
\textbf{Proposition} & \textbf{Code}\tabularnewline
\hline 
\hline 
$\forall A:A\Rightarrow A$ & \texttt{\textcolor{blue}{\footnotesize{}def identity{[}A{]}(x:A):A
= x}}\tabularnewline
\hline 
$\forall A:A\Rightarrow1$ & \texttt{\textcolor{blue}{\footnotesize{}def toUnit{[}A{]}(x:A): Unit
= ()}}\tabularnewline
\hline 
$\forall A\forall B:A\Rightarrow A\oplus B$ & \texttt{\textcolor{blue}{\footnotesize{}def inLeft{[}A,B{]}(x:A):\ Either{[}A,B{]}
= Left(x)}}\tabularnewline
\hline 
$\forall A\forall B:A\times B\Rightarrow A$ & \texttt{\textcolor{blue}{\footnotesize{}def first{[}A,B{]}(p:(A,B)):A
= p.\_1}}\tabularnewline
\hline 
$\forall A\forall B:A\Rightarrow(B\Rightarrow A)$ & \texttt{\textcolor{blue}{\footnotesize{}def const{[}A,B{]}(x:A):B$\Rightarrow$A
= (y:B)$\Rightarrow$x}}\tabularnewline
\hline 
\end{tabular}\\
~
\item Invalid propositions \emph{cannot be implemented} in code 
\begin{itemize}
\item Examples:\\
 $\forall A:1\Rightarrow A$; $\forall A\forall B:A\oplus B\Rightarrow A$;
\\
$\forall A\forall B:A\Rightarrow A\times B$; \  $\quad\forall A\forall B:(A\Rightarrow B)\Rightarrow A$
\end{itemize}
\item Given a type, can we decide whether it is implementable?
\begin{itemize}
\item Example: $\forall A\forall B:((((A\Rightarrow B)\Rightarrow B)\Rightarrow A)\Rightarrow B)\Rightarrow B$
\begin{itemize}
\item Pure propositional logic has a decision algorithm
\end{itemize}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Worked examples}

\begin{itemize}
\item What problems can we solve now?
\end{itemize}
\end{frame}

\begin{frame}{Exercises III}

\begin{enumerate}
\item a
\end{enumerate}
\end{frame}

\begin{frame}{Working with the CH correspondence}


\framesubtitle{Implications for designing new programming languages}
\begin{itemize}
\item The CH correspondence maps the type system of each programming language
into a certain system of logical propositions 
\item Scala, Haskell, OCaml, F\#, Swift, Rust, etc.~are mapped into the
full constructive logic (all logical operations are available)
\begin{itemize}
\item C, C++, Java, C\#, etc.~are mapped to \emph{incomplete} \emph{logics}
\textendash{} without ``or'' and without ``true'' / ``false''
\item Python, JavaScript, Ruby, Clojure, etc.~have only one type (``any
value'') and are mapped to logics with only one proposition
\end{itemize}
\item The CH correspondence is a principle for designing type systems:
\begin{itemize}
\item Choose a complete logic, free of inconsistency
\begin{itemize}
\item Mathematicians have studied all kinds of logics and determined which
ones are interesting, and found the minimal sets of axioms for them
\end{itemize}
\item Provide a type constructor for each basic operation (e.g.~``\emph{or}'',
``\emph{and}'')
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Working with the CH correspondence}


\framesubtitle{Implications for actually writing code}

What problems can we solve now?
\begin{itemize}
\item Given a fully parametric type, decide whether it can be implemented
in code (``type is inhabited''); if so, \emph{generate} the code
\begin{itemize}
\item The \href{http://apt13.unibe.ch/slides/Dyckhoff.pdf}{Gentzen-Vorobiev-Hudelmaier algorithms}
and generalizations
\end{itemize}
\item Given some code, infer the most general type it can have
\begin{itemize}
\item The \href{https://en.wikipedia.org/wiki/Hindley\%E2\%80\%93Milner_type_system}{Damas-Hindley-Milner algorithm}
(\href{http://dysphoria.net/2009/06/28/hindley-milner-type-inference-in-scala/}{Scala code})
and generalizations
\end{itemize}
\end{itemize}
\end{frame}

\end{document}
