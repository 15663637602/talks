%% LyX 2.2.0 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{amsmath}
\usepackage[all]{xy}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 % this default might be overridden by plain title style
 \newcommand\makebeamertitle{\frame{\maketitle}}%
 % (ERT) argument for the TOC
 \AtBeginDocument{%
   \let\origtableofcontents=\tableofcontents
   \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
   \def\gobbletableofcontents#1{\origtableofcontents}
 }
 \newenvironment{lyxcode}
   {\par\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \setlength{\listparindent}{0pt}% needed for AMS classes
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \normalfont\ttfamily}%
    \def\{{\char`\{}
    \def\}{\char`\}}
    \def\textasciitilde{\char`\~}
    \item[]}
   {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 8: Applicatives and traversables II]{Chapter 8: Applicative and traversable functors}
\subtitle{Part 2: Their laws and structure}
\author{Sergei Winitzki}
\date{2018-06-07}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy}
\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

\makeatother

\begin{document}
\frame{\titlepage}
\begin{frame}{Motivation for applicative functors}

\begin{itemize}
\item \vspace{-0.25cm}Monads are inconvenient for expressing \emph{independent}
effects
\end{itemize}
Monads perform effects \emph{sequentially} even if effects are independent:\texttt{\textcolor{blue}{\footnotesize{}\medskip{}
}}{\footnotesize \par}

\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[c][1\totalheight][t]{0.4\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}x~$\leftarrow$~Future~\{~c1~\}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}y~$\leftarrow$~Future~\{~c2~\}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}z~$\leftarrow$~Future~\{~c3~\}}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}}}%
\begin{minipage}[c][1\totalheight][t]{0.4\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}Future~\{~c1~\}.flatMap~\{~x~$\Rightarrow$}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~Future~\{~c2~\}.flatMap~\{~y~$\Rightarrow$}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~Future~\{~c3~\}.map~\{~z~$\Rightarrow$~...\}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}~\}}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}\medskip{}
}}{\footnotesize \par}
\begin{itemize}
\item We would like to parallelize independent computations
\item We would like to accumulate \emph{all} errors, rather than stop at
the first one
\end{itemize}
Changing the order of monad's effects will (generally) change the
result:\texttt{\textcolor{blue}{\footnotesize{}\medskip{}
}}{\footnotesize \par}

\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[c][1\totalheight][t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}for~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~x~$\leftarrow$~List(1,~2)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~y~$\leftarrow$~List(10,~20)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}~yield~f(x,~y)}{\footnotesize \par}

\textrm{\textcolor{gray}{\footnotesize{}//~f(1,~10),~f(1,~20),~f(2,~10),~f(2,~20)}}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}}}%
\begin{minipage}[c][1\totalheight][t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}for~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~y~$\leftarrow$~List(10,~20)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~x~$\leftarrow$~List(1,~2)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}~yield~f(x,~y)}{\footnotesize \par}

\textrm{\textcolor{gray}{\footnotesize{}//~f(1,~10),~f(2,~10),~f(1,~20),~f(2,~20)}}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}\medskip{}
}}{\footnotesize \par}
\begin{itemize}
\item We would like to express a computation where effects are unordered
\begin{itemize}
\item This can be done using a method \texttt{\textcolor{blue}{\footnotesize{}map2}},
\emph{not} defined via \texttt{\textcolor{blue}{\footnotesize{}flatMap}}:
the desired type signature is $\text{map2}:F^{A}\times F^{B}\Rightarrow\left(A\times B\Rightarrow C\right)\Rightarrow F^{C}$
\item An \textbf{applicative functor} has \texttt{\textcolor{blue}{\footnotesize{}map2}}
but is not necessarily a monad
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Defining \texttt{\textcolor{blue}{\footnotesize{}map2}}, \texttt{\textcolor{blue}{\footnotesize{}map3}},
etc.}

\vspace{-0.15cm}Consider 1, 2, 3, ... commutative and independent
``effects''

\texttt{\textcolor{blue}{\footnotesize{}\hrule\medskip{}
}}%
\begin{minipage}[c][1\totalheight][t]{0.4\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}for~\{~x1~$\leftarrow$~c1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}~yield~f(x1)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}}}%
\begin{minipage}[c][1\totalheight][t]{0.4\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}c1.map(f)}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}\medskip{}
}}{\footnotesize \par}

\texttt{\textcolor{blue}{\footnotesize{}\hrule\medskip{}
}}{\footnotesize \par}

\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[c][1\totalheight][t]{0.4\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}for~\{~x1~$\leftarrow$~c1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~x2~$\leftarrow$~c2}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}~yield~f(x1,~x2)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}}}%
\begin{minipage}[c][1\totalheight][t]{0.4\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}(c1,~c2).map2(f)}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}\medskip{}
\hrule\medskip{}
}}{\footnotesize \par}

\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[c][1\totalheight][t]{0.4\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}for~\{~x~$\leftarrow$~c1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~x2~$\leftarrow$~c2}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~x3~$\leftarrow$~c3}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}~yield~f(x1,~x2,~x3)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}}}%
\begin{minipage}[c][1\totalheight][t]{0.4\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}(c1,~c2,~c3).map3(f)}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}\medskip{}
\hrule\medskip{}
}}{\footnotesize \par}
\begin{itemize}
\item Generalize to \texttt{\textcolor{blue}{\footnotesize{}mapN}} from
\begin{align*}
\text{map}_{1} & :F^{A}\Rightarrow\left(A\Rightarrow Z\right)\Rightarrow F^{Z}\\
\text{map}_{2} & :F^{A}\times F^{B}\Rightarrow\left(A\times B\Rightarrow Z\right)\Rightarrow F^{Z}\\
\text{map}_{3} & :F^{A}\times F^{B}\times F^{C}\Rightarrow\left(A\times B\times C\Rightarrow Z\right)\Rightarrow F^{Z}
\end{align*}
\end{itemize}
\end{frame}

\begin{frame}{Examples of using \texttt{\textcolor{blue}{\footnotesize{}mapN}} }
\begin{itemize}
\item \vspace{-0.2cm}$F^{A}\equiv Z+A$ where $Z$ is a monoid: collect
all errors
\item $F^{A}=Z+A$: Create a validated case class out of validated parts
\item $F^{A}\equiv$ \texttt{\textcolor{blue}{\footnotesize{}Future{[}A{]}}}:
perform several computations concurrently
\item $F^{A}\equiv E\Rightarrow A$: pass arguments to functions automatically
\item $F^{A}\equiv\text{List}^{A}$: transposing a matrix uses \texttt{\textcolor{blue}{\footnotesize{}map2}} 
\item ``fold fusion'': automatically merge several \texttt{\textcolor{blue}{\footnotesize{}fold}}s
into one (\href{https://github.com/amarpotghan/scala-fold}{scala-folds})\texttt{\textcolor{blue}{\footnotesize{}\medskip{}
}}{\footnotesize \par}
\end{itemize}
\texttt{\textcolor{blue}{\footnotesize{}\hrule\medskip{}
}}{\footnotesize \par}
\begin{itemize}
\item Can we avoid having to define $\text{map}_{n}$ separately for each
$n$?
\end{itemize}
\end{frame}

\begin{frame}{Deriving the \texttt{\textcolor{blue}{\footnotesize{}ap}} operation
from \texttt{\textcolor{blue}{\footnotesize{}map2}} }
\begin{itemize}
\item \vspace{-0.2cm}Use curried arguments, $\text{fmap}_{2}:(A\Rightarrow B\Rightarrow Z)\Rightarrow F^{A}\Rightarrow F^{B}\Rightarrow F^{Z}$
\item Set $A=B\Rightarrow Z$ and apply $\text{fmap}_{2}$ to the identity
$\text{id}^{\left(B\Rightarrow Z\right)\Rightarrow\left(B\Rightarrow Z\right)}$:
obtain 
\[
\text{ap}:F^{B\Rightarrow Z}\Rightarrow F^{B}\Rightarrow F^{Z}\equiv\text{fmap}_{2}\left(\text{id}\right)
\]
\item The functions \texttt{\textcolor{blue}{\footnotesize{}fmap2}} and
\texttt{\textcolor{blue}{\footnotesize{}ap}} are computationally equivalent:
\[
\text{fmap}_{2}\,f^{A\Rightarrow B\Rightarrow Z}=\text{fmap}\,f\circ\text{ap}
\]
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{B\Rightarrow Z}\ar[rd]\sp(0.45){\text{ap}}\\
F^{A}\ar[ru]\sp(0.45){\text{fmap}\,f}\ar[rr]\sb(0.45){\text{fmap}_{2}\,(f^{A\Rightarrow B\Rightarrow Z})} &  & \left(F^{B}\Rightarrow F^{Z}\right)
}
\]
\item The functions \texttt{\textcolor{blue}{\footnotesize{}fmap3}}, \texttt{\textcolor{blue}{\footnotesize{}fmap4}}
etc.\ can be defined similarly:
\[
\text{fmap}_{3}\,f^{A\Rightarrow B\Rightarrow C\Rightarrow Z}=\text{fmap}\,f\circ\text{ap}\circ\text{fmap}_{F^{B}\Rightarrow?}\text{ap}
\]
{\footnotesize{}
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{B\Rightarrow C\Rightarrow Z}\ar[r]\sp(0.45){\text{ap}} & \left(F^{B}\Rightarrow F^{C\Rightarrow Z}\right)\ar[rd]\sp(0.55){\text{fmap}_{F^{B}\Rightarrow?}\text{ap}}\\
F^{A}\ar[ru]\sp(0.45){\text{fmap}\,f}\ar[rrr]\sb(0.45){\text{fmap}_{3}\,(f^{A\Rightarrow B\Rightarrow C\Rightarrow Z})} &  &  & \left(F^{B}\Rightarrow F^{C}\Rightarrow F^{Z}\right)
}
\]
}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Intuition: the \texttt{\textcolor{blue}{\footnotesize{}zip}} operation
on lists}
\begin{itemize}
\item Note: Function types $A\Rightarrow B\Rightarrow C$ and $A\times B\Rightarrow C$
are equivalent
\item Uncurry $\text{fmap}_{2}$ to $\text{fmap2}:\left(A\times B\Rightarrow C\right)\Rightarrow F^{A}\times F^{B}\Rightarrow F^{C}$ 
\item Compute $\text{fmap2}\left(f\right)$ with $f=\text{id}^{A\times B\Rightarrow A\times B}$,
expecting to obtain a simpler natural transformation: 
\[
\text{zip}:F^{A}\times F^{B}\Rightarrow F^{A\times B}
\]
 
\item This is quite similar to \texttt{\textcolor{blue}{\footnotesize{}zip}}
for lists:

\texttt{\textcolor{blue}{\footnotesize{}List(1, 2).zip(List(10, 20))
= List((1, 10), (2, 20))}}{\footnotesize \par}
\item The functions \texttt{\textcolor{blue}{\footnotesize{}zip}} and \texttt{\textcolor{blue}{\footnotesize{}fmap2}}
are computationally equivalent:
\begin{align*}
\text{zip} & =\text{fmap2}\left(\text{id}\right)\\
\text{fmap2}\,(f^{A\times B\Rightarrow C}) & =\text{zip}\circ\text{fmap}\,f
\end{align*}
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{A\times B}\ar[rd]\sp(0.65){\ \ \text{fmap}\,f^{A\times B\Rightarrow C}}\\
F^{A}\times F^{B}\ar[ru]\sp(0.5){\text{zip}}\ar[rr]\sb(0.6){\text{fmap2}\,(f^{A\times B\Rightarrow C})} &  & F^{C}
}
\]
\item The functor $F$ is ``zippable'' if such a \texttt{\textcolor{blue}{\footnotesize{}zip}}
exists
\end{itemize}
\end{frame}

\begin{frame}{Deriving the \texttt{\textcolor{blue}{\footnotesize{}ap}} operation
from \texttt{\textcolor{blue}{\footnotesize{}zip}} }
\begin{itemize}
\item \vspace{-0.2cm}Set $A\equiv B\Rightarrow C$, get $\text{zip}^{[B\Rightarrow C,B]}:F^{B\Rightarrow C}\times F^{B}\Rightarrow F^{(B\Rightarrow C)\times B}$
\item Use \texttt{\textcolor{blue}{\footnotesize{}eval}} $:\left(B\Rightarrow C\right)\times B\Rightarrow C$
and $\text{fmap}\left(\text{eval}\right):F^{(B\Rightarrow C)\times B}\Rightarrow F^{C}$
\item Define $\text{app}^{[B,C]}:F^{B\Rightarrow C}\times F^{B}\Rightarrow F^{C}\equiv\text{zip}\circ\text{fmap}\left(\text{eval}\right)$ 
\item The functions \texttt{\textcolor{blue}{\footnotesize{}zip}} and \texttt{\textcolor{blue}{\footnotesize{}app}}
are computationally equivalent:
\begin{itemize}
\item use $\text{pair}:\left(A\Rightarrow B\Rightarrow A\times B\right)=a^{A}\Rightarrow b^{B}\Rightarrow a\times b$
\item use $\text{fmap}\left(\text{pair}\right)\equiv\text{pair}^{\uparrow}$
on an $fa^{F^{A}}$, get $(\text{pair}^{\uparrow}fa):F^{B\Rightarrow A\times B}$;
then
\begin{align*}
\text{zip}\left(fa\times fb\right) & =\text{app}\left((\text{pair}^{\uparrow}fa)\times fb\right)\\
\text{app}^{[B\Rightarrow C,B]} & =\text{zip}^{[B\Rightarrow C,B]}\circ\text{fmap}\left(\text{eval}\right)
\end{align*}
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{(B\Rightarrow C)\times B}\ar[rd]\sp(0.65){\ \ \text{fmap}\left(\text{eval}\right)}\\
F^{B\Rightarrow C}\times F^{B}\ar[ru]\sp(0.5){\text{zip}}\ar[rr]\sb(0.55){\text{app}^{[B\Rightarrow C,B]}} &  & F^{C}
}
\]
\end{itemize}
\item Rewrite this using curried arguments: $\text{fzip}^{[A,B]}:F^{A}\Rightarrow F^{B}\Rightarrow F^{A\times B}$;
$\text{ap}^{[B,C]}:F^{B\Rightarrow C}\Rightarrow F^{B}\Rightarrow F^{C}$;
then $\text{ap}\,f=\text{fzip}\,f\circ\text{fmap}\left(\text{eval}\right)$. 
\item Now $\text{fzip}\,p^{F^{A}}q^{F^{B}}=\text{ap}\left(\text{pair}^{\uparrow}p\right)q$,
hence we can write as point-free: $\text{fzip}=\text{pair}^{\uparrow}\circ\text{ap}$.
With explicit types: $\text{fzip}^{[A,B]}=\text{pair}^{\uparrow}\circ\text{ap}^{[B,A\Rightarrow B]}$.
\end{itemize}
\end{frame}

\end{document}
