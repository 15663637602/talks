\batchmode
\makeatletter
\def\input@path{{/Users/sergei.winitzki/Code/talks/ftt-fp/}}
\makeatother
\documentclass[english]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{amsmath}
\usepackage[all]{xy}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 % this default might be overridden by plain title style
 \newcommand\makebeamertitle{\frame{\maketitle}}%
 % (ERT) argument for the TOC
 \AtBeginDocument{%
   \let\origtableofcontents=\tableofcontents
   \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
   \def\gobbletableofcontents#1{\origtableofcontents}
 }
 \newenvironment{lyxcode}
   {\par\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \setlength{\listparindent}{0pt}% needed for AMS classes
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \normalfont\ttfamily}%
    \def\{{\char`\{}
    \def\}{\char`\}}
    \def\textasciitilde{\char`\~}
    \item[]}
   {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 8: Applicative functors]{Chapter 8: Applicative functors and profunctors}
\subtitle{Part 2: Their laws and structure}
\author{Sergei Winitzki}
\date{2018-07-01}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy}
\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

\makeatother

\begin{document}
\frame{\titlepage}
\begin{frame}{Deriving the \texttt{\textcolor{blue}{\footnotesize{}ap}} operation
from \texttt{\textcolor{blue}{\footnotesize{}map2}} }

\vspace{-0.1cm}Can we avoid having to define $\text{map}_{n}$ separately
for each $n$?
\begin{itemize}
\item Use curried arguments, $\text{fmap}_{2}:(A\Rightarrow B\Rightarrow Z)\Rightarrow F^{A}\Rightarrow F^{B}\Rightarrow F^{Z}$
\item Set $A=B\Rightarrow Z$ and apply $\text{fmap}_{2}$ to the identity
$\text{id}^{\left(B\Rightarrow Z\right)\Rightarrow\left(B\Rightarrow Z\right)}$:
obtain $\text{ap}^{[B,Z]}:F^{B\Rightarrow Z}\Rightarrow F^{B}\Rightarrow F^{Z}\equiv\text{fmap}_{2}\left(\text{id}\right)$
\item The functions \texttt{\textcolor{blue}{\footnotesize{}fmap$_{2}$}}
and \texttt{\textcolor{blue}{\footnotesize{}ap}} are computationally
equivalent:{\footnotesize{}
\[
\text{fmap}_{2}\,f^{A\Rightarrow B\Rightarrow Z}=\text{fmap}\,f\circ\text{ap}
\]
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{B\Rightarrow Z}\ar[rd]\sp(0.45){\text{ap}}\\
F^{A}\ar[ru]\sp(0.45){\text{fmap}\,f}\ar[rr]\sb(0.45){\text{fmap}_{2}\,(f^{A\Rightarrow B\Rightarrow Z})} &  & \left(F^{B}\Rightarrow F^{Z}\right)
}
\]
}{\footnotesize \par}
\item The functions \texttt{\textcolor{blue}{\footnotesize{}fmap$_{3}$}},
\texttt{\textcolor{blue}{\footnotesize{}fmap$_{4}$}} etc.\ can be
defined similarly:{\footnotesize{}
\[
\text{fmap}_{3}\,f^{A\Rightarrow B\Rightarrow C\Rightarrow Z}=\text{fmap}\,f\circ\text{ap}\circ\text{fmap}_{F^{B}\Rightarrow?}\text{ap}
\]
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{B\Rightarrow C\Rightarrow Z}\ar[r]\sp(0.45){\text{ap}^{[B,C\Rightarrow Z]}} & \left(F^{B}\Rightarrow F^{C\Rightarrow Z}\right)\ar[rd]\sp(0.55){\text{fmap}_{F^{B}\Rightarrow?}\text{ap}^{[C,Z]}}\\
F^{A}\ar[ru]\sp(0.45){\text{fmap}\,f}\ar[rrr]\sb(0.45){\text{fmap}_{3}\,(f^{A\Rightarrow B\Rightarrow C\Rightarrow Z})} &  &  & \left(F^{B}\Rightarrow F^{C}\Rightarrow F^{Z}\right)
}
\]
}{\footnotesize \par}
\item Using the infix syntax will get rid of {\footnotesize{}$\text{fmap}_{F^{B}\Rightarrow?}\text{ap}$}
(see example code)
\begin{itemize}
\item Note the pattern: a natural transformation is equivalent to a lifting
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Deriving the \texttt{\textcolor{blue}{\footnotesize{}zip}} operation
from \texttt{\textcolor{blue}{\footnotesize{}map2}} }
\begin{itemize}
\item Note: Function types $A\Rightarrow B\Rightarrow C$ and $A\times B\Rightarrow C$
are equivalent
\item Uncurry $\text{fmap}_{2}$ to $\text{fmap2}:\left(A\times B\Rightarrow C\right)\Rightarrow F^{A}\times F^{B}\Rightarrow F^{C}$ 
\item Compute $\text{fmap2}\left(f\right)$ with $f=\text{id}^{A\times B\Rightarrow A\times B}$,
expecting to obtain a simpler natural transformation: 
\[
\text{zip}:F^{A}\times F^{B}\Rightarrow F^{A\times B}
\]
 
\item This is quite similar to \texttt{\textcolor{blue}{\footnotesize{}zip}}
for lists:

\texttt{\textcolor{blue}{\footnotesize{}List(1, 2).zip(List(10, 20))
= List((1, 10), (2, 20))}}{\footnotesize \par}
\item The functions \texttt{\textcolor{blue}{\footnotesize{}zip}} and \texttt{\textcolor{blue}{\footnotesize{}fmap2}}
are computationally equivalent:{\footnotesize{}
\begin{align*}
\text{zip} & =\text{fmap2}\left(\text{id}\right)\\
\text{fmap2}\,(f^{A\times B\Rightarrow C}) & =\text{zip}\circ\text{fmap}\,f
\end{align*}
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{A\times B}\ar[rd]\sp(0.65){\ \ \text{fmap}\,f^{A\times B\Rightarrow C}}\\
F^{A}\times F^{B}\ar[ru]\sp(0.5){\text{zip}}\ar[rr]\sb(0.6){\text{fmap2}\,(f^{A\times B\Rightarrow C})} &  & F^{C}
}
\]
}{\footnotesize \par}
\item The functor $F$ is \textbf{zippable} if such a \texttt{\textcolor{blue}{\footnotesize{}zip}}
exists (with appropriate laws)
\begin{itemize}
\item The same pattern: a natural transformation is equivalent to a lifting
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{{*} Equivalence of the operations \texttt{\textcolor{blue}{\footnotesize{}ap}}
and \texttt{\textcolor{blue}{\footnotesize{}zip}} }
\begin{itemize}
\item \vspace{-0.2cm}Set $A\equiv B\Rightarrow C$, get $\text{zip}^{[B\Rightarrow C,B]}:F^{B\Rightarrow C}\times F^{B}\Rightarrow F^{(B\Rightarrow C)\times B}$
\item Use \texttt{\textcolor{blue}{\footnotesize{}eval}} $:\left(B\Rightarrow C\right)\times B\Rightarrow C$
and $\text{fmap}\left(\text{eval}\right):F^{(B\Rightarrow C)\times B}\Rightarrow F^{C}$
\item Uncurry: \texttt{\textcolor{blue}{\footnotesize{}app}}$\text{}^{[B,C]}:F^{B\Rightarrow C}\times F^{B}\Rightarrow F^{C}\equiv\text{zip}\circ\text{fmap}\left(\text{eval}\right)$ 
\item The functions \texttt{\textcolor{blue}{\footnotesize{}zip}} and \texttt{\textcolor{blue}{\footnotesize{}app}}
are computationally equivalent:
\begin{itemize}
\item use $\text{pair}:\left(A\Rightarrow B\Rightarrow A\times B\right)=a^{A}\Rightarrow b^{B}\Rightarrow a\times b$
\item use $\text{fmap}\left(\text{pair}\right)\equiv\text{pair}^{\uparrow}$
on an $fa^{F^{A}}$, get $(\text{pair}^{\uparrow}fa):F^{B\Rightarrow A\times B}$;
then{\footnotesize{}
\begin{align*}
\text{zip}\left(fa\times fb\right) & =\text{app}\left((\text{pair}^{\uparrow}fa)\times fb\right)\\
\text{app}^{[B\Rightarrow C,B]} & =\text{zip}^{[B\Rightarrow C,B]}\circ\text{fmap}\left(\text{eval}\right)
\end{align*}
}
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{(B\Rightarrow C)\times B}\ar[rd]\sp(0.65){\ \ \text{fmap}\left(\text{eval}\right)}\\
F^{B\Rightarrow C}\times F^{B}\ar[ru]\sp(0.5){\text{zip}}\ar[rr]\sb(0.55){\text{app}^{[B\Rightarrow C,B]}} &  & F^{C}
}
\]
\end{itemize}
\item Rewrite this using curried arguments: $\text{fzip}^{[A,B]}:F^{A}\Rightarrow F^{B}\Rightarrow F^{A\times B}$;
$\text{ap}^{[B,C]}:F^{B\Rightarrow C}\Rightarrow F^{B}\Rightarrow F^{C}$;
then $\text{ap}\,f=\text{fzip}\,f\circ\text{fmap}\left(\text{eval}\right)$. 
\item Now $\text{fzip}\,p^{F^{A}}q^{F^{B}}=\text{ap}\left(\text{pair}^{\uparrow}p\right)q$,
hence we may omit the argument $q$: $\text{fzip}=\text{pair}^{\uparrow}\circ\text{ap}$.
With explicit types: $\text{fzip}^{[A,B]}=\text{pair}^{\uparrow}\circ\text{ap}^{[B,A\Rightarrow B]}$.
\end{itemize}
\end{frame}

\begin{frame}{Motivation for applicative laws. Naturality laws for \texttt{\textcolor{blue}{\footnotesize{}map2}} }

Treat \texttt{\textcolor{blue}{\footnotesize{}map2}} as a replacement
for a monadic block with independent effects:\texttt{\textcolor{blue}{\footnotesize{}\smallskip{}
}}{\footnotesize \par}

\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[c][1\totalheight][t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}for~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~x~$\leftarrow$~cont1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~y~$\leftarrow$~cont2}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}~yield~g(x,~y)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}}}%
\begin{minipage}[c][1\totalheight][t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}map2~(}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~cont1,}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~cont2}{\footnotesize \par}

\textcolor{blue}{\footnotesize{})~\{~(x,~y)~$\Rightarrow$~g(x,~y)~\}}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}\medskip{}
}}{\footnotesize \par}
\begin{itemize}
\item Main idea: Formulate the monad laws in terms of \texttt{\textcolor{blue}{\footnotesize{}map2}}
and \texttt{\textcolor{blue}{\footnotesize{}pure}} 
\end{itemize}
Naturality laws: Manipulate data in one of the containers\texttt{\textcolor{blue}{\footnotesize{}\smallskip{}
}}{\footnotesize \par}

\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[c][1\totalheight][t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}for~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~x~$\leftarrow$~cont1.map(f)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~y~$\leftarrow$~cont2}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}~yield~g(x,~y)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}}}%
\begin{minipage}[c][1\totalheight][t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}for~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~x~$\leftarrow$~cont1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~y~$\leftarrow$~cont2}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}~yield~g(f(x),~y)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}\medskip{}
}}{\footnotesize \par}

and similarly for \texttt{\textcolor{blue}{\footnotesize{}cont2}}
instead of \texttt{\textcolor{blue}{\footnotesize{}cont1}}; now rewrite
in terms of for \texttt{\textcolor{blue}{\footnotesize{}map2}}:
\begin{itemize}
\item \textbf{Left naturality} for \texttt{\textcolor{blue}{\footnotesize{}map2}}:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}map2(cont1.map(f),~cont2)(g)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~=~map2(cont1,~cont2)\{~(x,~y)~$\Rightarrow$~g(f(x),~y)~\}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item \textbf{Right naturality} for \texttt{\textcolor{blue}{\footnotesize{}map2}}:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}map2(cont1,~cont2.map(f))(g)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~=~map2(cont1,~cont2)\{~(x,~y)~$\Rightarrow$~g(x,~f(y))~\}}{\footnotesize \par}
\end{lyxcode}
\end{frame}

\begin{frame}{Associativity and identity laws for \texttt{\textcolor{blue}{\footnotesize{}map2}} }

\vspace{-0.1cm}Inline two generators out of three, in two different
ways:\texttt{\textcolor{blue}{\footnotesize{}\smallskip{}
}}{\footnotesize \par}

\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[c][1\totalheight][t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}for~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~x~$\leftarrow$~cont1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~(y,~z)~$\leftarrow$~for~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~~~~~~yy~$\leftarrow$~cont2}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~~~~~~zz~$\leftarrow$~cont3}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~~~~\}~yield~(yy,~zz)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}~yield~g(x,~y,~z)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}}}%
\begin{minipage}[c][1\totalheight][t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}for~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~(x,~y)~$\leftarrow$~for~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~~~~~~~~~~~xx~$\leftarrow$~cont1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~~~~~~~~~~~yy~$\leftarrow$~cont2}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~~~~~~~~~\}~yield~(xx,~yy)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~z~$\leftarrow$~cont3}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}~yield~g(x,~y,~z)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}\medskip{}
}}{\footnotesize \par}

Write this in terms of \texttt{\textcolor{blue}{\footnotesize{}map2}}
to obtain the \textbf{associativity law} for \texttt{\textcolor{blue}{\footnotesize{}map2}}:
\begin{lyxcode}
\vspace{-0.1cm}\textcolor{blue}{\footnotesize{}map2(cont1,~map2(cont2,~cont3)((\_,\_))\{~case(x,(y,z))$\Rightarrow$g(x,y,z)\}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~=~map2(map2(cont1,~cont2)((\_,\_)),~cont3)\{~case((x,y),z))$\Rightarrow$g(x,y,z)\}}~
\end{lyxcode}
Empty context preceds a generator, or follows a generator:\texttt{\textcolor{blue}{\footnotesize{}\smallskip{}
}}{\footnotesize \par}

\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[c][1\totalheight][t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}for~\{~x~$\leftarrow$~pure(a)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~~~y~$\leftarrow$~cont}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}~yield~g(x,~y)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}}}%
\begin{minipage}[c][1\totalheight][t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}for~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~y~$\leftarrow$~cont}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}~yield~g(a,~y)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}\medskip{}
}}{\footnotesize \par}

Write this in terms of \texttt{\textcolor{blue}{\footnotesize{}map2}}
to obtain the \textbf{identity laws} for \texttt{\textcolor{blue}{\footnotesize{}map2}}
and \texttt{\textcolor{blue}{\footnotesize{}pure}}:
\begin{lyxcode}
\vspace{-0.1cm}\textcolor{blue}{\footnotesize{}map2(pure(a),~cont)(g)~=~cont.map~\{~y~$\Rightarrow$~g(a,~y)~\}}~

\textcolor{blue}{\footnotesize{}map2(cont,~pure(b))(g)~=~cont.map~\{~x~$\Rightarrow$~g(x,~b)~\}}~
\end{lyxcode}
\end{frame}

\begin{frame}{Deriving the laws for \texttt{\textcolor{blue}{\footnotesize{}zip}}:
naturality}
\begin{itemize}
\item \vspace{-0.2cm}The laws for \texttt{\textcolor{blue}{\footnotesize{}map2}}
in a short notation; here{\footnotesize{} $f\otimes g\equiv\left\{ a\times b\Rightarrow f(a)\times g(b)\right\} $}
{\footnotesize{}
\begin{align*}
\text{fmap2}\left(g^{A\times B\Rightarrow C}\right)\left(f^{\uparrow}q_{1}\times q_{2}\right) & =\text{fmap2}\left(\left(f\otimes\text{id}\right)\circ g\right)\left(q_{1}\times q_{2}\right)\\
\text{fmap2}\left(g^{A\times B\Rightarrow C}\right)\left(q_{1}\times f^{\uparrow}q_{2}\right) & =\text{fmap2}\left(\left(\text{id}\otimes f\right)\circ g\right)\left(q_{1}\times q_{2}\right)\\
\text{fmap2}\left(g_{1.23}\right)\left(q_{1}\times\text{fmap2}\left(\text{id}\right)\left(q_{2}\times q_{3}\right)\right) & =\text{fmap2}\left(g_{12.3}\right)\left(\text{fmap2}\left(\text{id}\right)\left(q_{1}\times q_{2}\right)\times q_{3}\right)\\
\text{fmap2}\left(g^{A\times B\Rightarrow C}\right)\left(\text{pure}\,a^{A}\times q_{2}^{F^{B}}\right) & =\left(b\Rightarrow g\left(a\times b\right)\right)^{\uparrow}q_{2}\\
\text{fmap2}\left(g^{A\times B\Rightarrow C}\right)\left(q_{1}^{F^{A}}\times\text{pure}\,b^{B}\right) & =\left(a\Rightarrow g\left(a\times b\right)\right)^{\uparrow}q_{1}
\end{align*}
}{\footnotesize \par}
\item Express \texttt{\textcolor{blue}{\footnotesize{}map2}} through \texttt{\textcolor{blue}{\footnotesize{}zip}}:{\footnotesize{}
\begin{align*}
\text{fmap}_{2}\,g^{A\times B\Rightarrow C}\left(q_{1}^{F^{A}}\times q_{2}^{F^{B}}\right) & \equiv\left(\text{zip}\circ g^{\uparrow}\right)\left(q_{1}\times q_{2}\right)\\
\text{fmap}_{2}\,g^{A\times B\Rightarrow C} & \equiv\text{zip}\circ g^{\uparrow}
\end{align*}
}{\footnotesize \par}
\item Combine the two naturality laws into one by using two functions $f_{1}$,
$f_{2}$:{\footnotesize{}
\begin{align*}
\left(f_{1}^{\uparrow}\otimes f_{2}^{\uparrow}\right)\circ\text{fmap2}\,g & =\text{fmap2}\left(\left(f_{1}\otimes f_{2}\right)^{\uparrow}\circ g\right)\\
\left(f_{1}^{\uparrow}\otimes f_{2}^{\uparrow}\right)\circ\text{zip}\circ g^{\uparrow} & =\text{zip}\circ\left(f_{1}\otimes f_{2}\right)^{\uparrow}\circ g^{\uparrow}
\end{align*}
}{\footnotesize \par}
\item \vspace{-0.2cm}The \textbf{naturality law} for \texttt{\textcolor{blue}{\footnotesize{}zip}}
then becomes: {\footnotesize{}$\left(f_{1}^{\uparrow}\otimes f_{2}^{\uparrow}\right)\circ\text{zip}=\text{zip}\circ\left(f_{1}\otimes f_{2}\right)^{\uparrow}$} 
\end{itemize}
\end{frame}

\begin{frame}{Deriving the laws for \texttt{\textcolor{blue}{\footnotesize{}zip}}:
associativity}
\begin{itemize}
\item Express \texttt{\textcolor{blue}{\footnotesize{}map2}} through \texttt{\textcolor{blue}{\footnotesize{}zip}}
and substitute into the associativity law:{\footnotesize{}
\[
g_{1.23}^{\uparrow}\left(\text{zip}\left(q_{1}\times\text{zip}\left(q_{2}\times q_{3}\right)\right)\right)=g_{12.3}^{\uparrow}\left(\text{zip}\left(\text{zip}\left(q_{1}\times q_{2}\right)\times q_{3}\right)\right)
\]
}{\footnotesize \par}
\item The arbitrary function $g$ is preceded by transformations of the
tuples,{\footnotesize{}
\[
a\times\left(b\times c\right)\equiv\left(a\times b\right)\times c\quad\text{(type isomorphism)}
\]
}{\footnotesize \par}
\item Assume that the isomorphism transformations are applied as needed,
then we may formulate the \textbf{associativity law} for \texttt{\textcolor{blue}{\footnotesize{}zip}}
more concisely:{\footnotesize{}
\[
\text{zip}\left(q_{1}\times\text{zip}\left(q_{2}\times q_{3}\right)\right)\cong\text{zip}\left(\text{zip}\left(q_{1}\times q_{2}\right)\times q_{3}\right)
\]
}\vspace{-0.2cm}
\[
\xymatrix{\xyScaleY{1.4pc}\xyScaleX{3pc}F^{\left(A\times B\right)\times C}\ar[r] & F^{A\times B\times C}\ar[r]\ar[l] & F^{A\times\left(B\times C\right)}\ar[l]\\
F^{A\times B}\times F^{C}\ar[u]\sp(0.6){\text{zip}} & F^{A}\ar[ldd]\ar[r] & F^{A}\times F^{B\times C}\ar[u]\sb(0.6){\text{zip}}\\
F^{A\times B}\ar[u] & F^{C}\ar[rd]\ar[lu] & F^{B\times C}\ar[u]\\
F^{A}\times F^{B}\ar[u]\sp(0.6){\text{zip}} & F^{B}\ar[r]\ar[l] & F^{B}\times F^{C}\ar[u]\sb(0.6){\text{zip}}
}
\]
\end{itemize}
\end{frame}

\begin{frame}{Deriving the laws for \texttt{\textcolor{blue}{\footnotesize{}zip}}:
identity laws}
\begin{itemize}
\item Identity laws seem to be complicated, e.g.\ the left identity:{\footnotesize{}
\[
g^{\uparrow}\left(\text{zip}\left(\text{pure}\,a\times q\right)\right)=\left(b\Rightarrow g\left(a\times b\right)\right)^{\uparrow}q
\]
}{\footnotesize \par}
\item Replace \texttt{\textcolor{blue}{\footnotesize{}pure}} by a simpler
``wrapped unit'' method \texttt{\textcolor{blue}{\footnotesize{}unit:\ F{[}Unit{]}}}{\footnotesize{}
\[
\text{unit}^{F^{1}}\equiv\text{pure}\left(1\right);\quad\text{pure}(a^{A})=\left(1\Rightarrow a\right)^{\uparrow}\text{unit}
\]
}Then the left identity law can be simplified using left naturality:{\footnotesize{}
\[
g^{\uparrow}\left(\text{zip}\left(\left(\left(1\Rightarrow a\right)^{\uparrow}\text{unit}\right)\times q\right)\right)=g^{\uparrow}\left(\left((1\Rightarrow a)\times\text{id}\right)^{\uparrow}\text{zip}\left(\text{unit}\times q\right)\right)
\]
}{\footnotesize \par}
\item Denote $\phi^{B\Rightarrow1\times B}\equiv b\Rightarrow1\times b$
and $\beta_{a}^{1\times B\Rightarrow A\times B}\equiv\left(1\Rightarrow a\right)\times\text{id}$;
then the function $b\Rightarrow g\left(a\times b\right)$ can be expressed
more simply as $\phi\circ\beta_{a}\circ g$, and the naturality law
becomes {\footnotesize{}
\[
g^{\uparrow}(\beta_{a}^{\uparrow}\,\text{zip}\left(\text{unit}\times q\right))=\left(\beta_{a}\circ g\right)^{\uparrow}\left(\text{zip}\left(\text{unit}\times q\right)\right)=\left(\phi\circ\beta_{a}\circ g\right)^{\uparrow}q=\left(\beta_{a}\circ g\right)^{\uparrow}(\phi^{\uparrow}q)
\]
}Omitting the common prefix {\footnotesize{}$\left(\beta_{a}\circ g\right)^{\uparrow}$},
we obtain the \textbf{left identity} law:{\footnotesize{}
\[
\text{zip}\left(\text{unit}\times q\right)=\phi^{\uparrow}q
\]
}{\footnotesize \par}
\begin{itemize}
\item Note that $\phi^{\uparrow}$ is an isomorphism between $F^{B}$ and
$F^{1\times B}$
\item Assume that this isomorphism is applied as needed, then we may write{\footnotesize{}
\[
\text{zip}\left(\text{unit}\times q\right)\cong q
\]
}{\footnotesize \par}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Applicative laws as monoid laws}
\begin{itemize}
\item Use infix syntax for \texttt{\textcolor{blue}{\footnotesize{}zip}}
and write $\text{zip}\left(p\times q\right)\equiv p\bowtie q$
\item Then the associativity and identity laws may be written as{\footnotesize{}
\begin{align*}
q_{1}\bowtie\left(q_{2}\bowtie q_{3}\right) & \cong\left(q_{1}\bowtie q_{2}\right)\bowtie q_{3}\\
\left(\text{unit}\,\bowtie q\right) & \cong q\\
\left(q\bowtie\text{unit}\right) & \cong q
\end{align*}
}These are the laws of a monoid (with some assumed transformations)
\item Naturality law for \texttt{\textcolor{blue}{\footnotesize{}zip}} written
in the infix syntax:{\footnotesize{}
\[
f_{1}^{\uparrow}q_{1}\bowtie f_{2}^{\uparrow}q_{2}=\left(f_{1}\otimes f_{2}\right)^{\uparrow}\left(q_{1}\bowtie q_{2}\right)
\]
}{\footnotesize \par}
\item \texttt{\textcolor{blue}{\footnotesize{}unit}} has no laws; the naturality
for \texttt{\textcolor{blue}{\footnotesize{}pure}} follows automatically
\item The laws are simplest when formulated in terms of \texttt{\textcolor{blue}{\footnotesize{}zip}}
and \texttt{\textcolor{blue}{\footnotesize{}unit}} 
\begin{itemize}
\item Naturality for \texttt{\textcolor{blue}{\footnotesize{}zip}} will
usually follow from parametricity
\end{itemize}
\item ``Zippable'' functors have only the associativity and naturality
laws
\item Applicative functors are a strict subset of monadic functors
\begin{itemize}
\item There are applicative functors that cannot be monads
\item Applicative functor implementation may disagree with the monad
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Constructions of applicative functors}
\begin{itemize}
\item All monadic constructions still hold for applicative functors
\item Additionally, there are some non-monadic constructions
\end{itemize}
\begin{enumerate}
\item $F^{A}\equiv1$ (constant functor) and $F^{A}\equiv A$ (identity
functor)
\item $F^{A}\equiv G^{A}\times H^{A}$ for any applicative $G^{A}$ and
$H^{A}$
\begin{itemize}
\item but $G^{A}+H^{A}$ is in general \emph{not} applicative
\end{itemize}
\item $F^{A}\equiv R\Rightarrow G^{A}$ for any applicative $G^{A}$ and
any fixed type $R$
\item $F^{A}\equiv A+G^{A}$ for any applicative $G^{A}$ (\textbf{free
pointed} over $G$)
\item $F^{A}\equiv A+G^{F^{A}}$ (recursive) for any functor $G^{A}$ (\textbf{free
monad} over $G$)
\item $F^{A}\equiv H^{A}\Rightarrow A$ for any contrafunctor $H^{A}$A$ for any contrafunctor $H^{A}$\\
Constructions that are not monadic:
\item $F^{A}\equiv Z$ (constant functor, $Z$ a monoid)
\item $F^{A}\equiv Z+A\times W$ when $W$ and $Z$ are monoids (nontrivial
instance)
\item $F^{A}\equiv G^{H^{A}}$ when both $G$ and $H$ are applicative
\item $F^{A}\equiv G^{A}+H^{G^{A}}$ where $H$ is any functor and $G$
is applicative
\end{enumerate}
\end{frame}

\begin{frame}{All non-parameterized exp-poly types are monoids}
\begin{itemize}
\item \vspace{-0.1cm}Known monoid constructions (Chapter\ 7) implement
$X+Y$, $X\times Y$, $X\Rightarrow Y$ as monoids when $X$ and $Y$
are monoids
\item All primitive types have at least one monoid instance
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}Int}}, \texttt{\textcolor{blue}{\footnotesize{}Float}},
\texttt{\textcolor{blue}{\footnotesize{}Double}}, \texttt{\textcolor{blue}{\footnotesize{}Char}},
\texttt{\textcolor{blue}{\footnotesize{}Boolean}} are ``numeric''
monoids
\item \texttt{\textcolor{blue}{\footnotesize{}Unit}} is a trivial monoid
\item \texttt{\textcolor{blue}{\footnotesize{}Seq{[}A{]}}}, \texttt{\textcolor{blue}{\footnotesize{}Set{[}A{]}}},
\texttt{\textcolor{blue}{\footnotesize{}Map{[}K,V{]}}} are set-like
monoids
\item \texttt{\textcolor{blue}{\footnotesize{}String}} is equivalent to
a sequence of integers
\end{itemize}
\item Therefore, all exponential-polynomial types without type parameters
are monoids in at least one way
\item Example of an exp-poly type without type parameters: $\text{Int}+\text{String}\times\text{String}\times\left(\text{Int}\Rightarrow\text{Bool}\right)+\left(\text{Bool}\times\text{String}\Rightarrow1+\text{String}\right)$
\item Example of a type with parameters, which is not a monoid: $A\Rightarrow B$
\end{itemize}
Therefore, \emph{all} polynomial functors with monoidal parameters
are applicative
\begin{itemize}
\item $F^{A}=1+A\times A$ (this is not a monad!)
\item $F^{A}=A+A\times A\times Z$ where $Z$ is a monoid
\end{itemize}
Examples of non-polynomial functors that are not applicative:
\begin{itemize}
\item $F^{A}\equiv\left(A\Rightarrow R\right)\Rightarrow S$; $\quad F^{A}\equiv\left(R\Rightarrow A\right)+\left(S\Rightarrow A\right)$
\end{itemize}
\end{frame}

\begin{frame}{Definition and constructions of applicative contrafunctors}
\begin{itemize}
\item \vspace{-0.1cm}The applicative functor laws, if formulated via \texttt{\textcolor{blue}{\footnotesize{}zip}}
and \texttt{\textcolor{blue}{\footnotesize{}unit}}, do not use \texttt{\textcolor{blue}{\footnotesize{}map}}
and therefore can be used for contrafunctors
\item Define an \textbf{applicative contrafunctor} $C^{A}$ as having \texttt{\textcolor{blue}{\footnotesize{}zip}}
and \texttt{\textcolor{blue}{\footnotesize{}unit}}:{\footnotesize{}
\[
\text{zip}:C^{A}\times C^{B}\Rightarrow C^{A\times B};\quad\text{unit}:C^{1}
\]
}{\footnotesize \par}
\item Identity and associativity laws must hold for \texttt{\textcolor{blue}{\footnotesize{}zip}}
and \texttt{\textcolor{blue}{\footnotesize{}unit}} 
\begin{itemize}
\item Note: applying \texttt{\textcolor{blue}{\footnotesize{}contramap}}
to the function $a\times b\Rightarrow a$ will yield some $C^{A}\Rightarrow C^{A\times B}$,
but this will not give a valid implementation of \texttt{\textcolor{blue}{\footnotesize{}zip}}!
\end{itemize}
\item Naturality must hold for \texttt{\textcolor{blue}{\footnotesize{}zip}},
but with \texttt{\textcolor{blue}{\footnotesize{}contramap}} instead
of \texttt{\textcolor{blue}{\footnotesize{}map}} 
\end{itemize}
Applicative contrafunctor constructions:
\begin{enumerate}
\item $C^{A}\equiv Z$ (constant functor, $Z$ a monoid)
\item $C^{A}\equiv G^{A}\times H^{A}$ for any applicative contrafunctors
$G^{A}$ and $H^{A}$
\item $C^{A}\equiv G^{A}+H^{A}$ for any applicative contrafunctors $G^{A}$
and $H^{A}$
\item $C^{A}\equiv H^{A}\Rightarrow G^{A}$ for any functor $H^{A}$ and
applicative contrafunctor $G^{A}$
\item $C^{A}\equiv H^{G^{A}}$ for any functor $H^{A}$ and applicative
contrafunctor $G^{A}$
\end{enumerate}
\begin{itemize}
\item \emph{All} exponential-polynomial contrafunctors with monoidal parameters
are applicative!
\end{itemize}
\end{frame}

\begin{frame}{Definition and constructions of applicative profunctors}
\begin{itemize}
\item \textbf{Profunctors} have the type parameter in both covariant and
contravariant positions; they are neither functors nor contrafunctors
\item Examples of profunctors: $P^{A}\equiv\text{Int}\times A\Rightarrow A$;
$\quad P^{A}\equiv A+\left(A\Rightarrow R\right)$
\item \emph{All} exp-poly type constructors are profunctors since the type
parameter is always in either a covariant or a contravariant position
\item Definition of applicative profunctor: has \texttt{\textcolor{blue}{\footnotesize{}zip}}
and \texttt{\textcolor{blue}{\footnotesize{}unit}} with the laws
\end{itemize}
Applicative profunctor include all previous constructions, and additionally:
\begin{enumerate}
\item $C^{A}\equiv G^{A}\times H^{A}$ for any applicative profunctors $G^{A}$
and $H^{A}$
\item $C^{A}\equiv A+G^{A}$ for any applicative profunctor $G^{A}$
\item $C^{A}\equiv G^{A}+H^{G^{A}}$ for any functor $H^{A}$ and applicative
profunctor $G^{A}$
\item $C^{A}\equiv H^{A}\Rightarrow A$ for any profunctor $H^{A}$
\item $C^{A}\equiv H^{G^{A}}$ and $G^{H^{A}}$ for any functor $H^{A}$
and applicative profunctor $G^{A}$
\end{enumerate}
Examples of non-applicative profunctors:
\begin{itemize}
\item $F^{A}\equiv\left(A\Rightarrow A\right)+\left(R\Rightarrow A\right)$;
$\quad P^{A}\equiv\left(A\Rightarrow A\right)\Rightarrow1+A$
\end{itemize}
\end{frame}

\begin{frame}{Exercises}
\begin{enumerate}
\item Show that $F^{A}\equiv\left(Z\Rightarrow A\right)\Rightarrow1+A$
is not applicative.
\end{enumerate}
\end{frame}

\end{document}
