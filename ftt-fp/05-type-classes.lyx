#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 5: Type classes etc.]{Chapter 5: Type classes
 and their applications}
\subtitle{Pointed, co-pointed, and filtered functors}
\author{Sergei Winitzki}
\date{January 14, 2018}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{navigation symbols}{}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Motivation for type classes I: Restricting type arguments
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
We need different 
\family typewriter
\size footnotesize
\color blue
sum
\family default
\size default
\color inherit
 implementations for 
\family typewriter
\size footnotesize
\color blue
Seq[Int], Seq[Double]
\family default
\size default
\color inherit
, etc.
\end_layout

\begin_layout Itemize
But we cannot generalize 
\family typewriter
\size footnotesize
\color blue
sum
\family default
\size default
\color inherit
 to arbitrary types 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 like this:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
def sum[T](s: Seq[T]): T = ???
\end_layout

\begin_layout Itemize
This can work only for 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 that have a zero value and a 
\family typewriter
\size footnotesize
\color blue
+
\family default
\size default
\color inherit
 method
\end_layout

\begin_layout Standard
We cannot generalize 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 to arbitrary type constructors 
\family typewriter
\size footnotesize
\color blue
F[_]
\family default
\size default
\color inherit
:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
def fmap[F[_], A, B](f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B): F[A] 
\begin_inset Formula $\Rightarrow$
\end_inset

 F[B] = ???
\end_layout

\begin_layout Itemize
This can work only for type constructors 
\family typewriter
\size footnotesize
\color blue
F[_]
\family default
\size default
\color inherit
 that are functors
\end_layout

\begin_layout Standard
We would like to define functions whose type arguments, such as 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
F[_]
\family default
\size default
\color inherit
, are constrained to belong to a 
\emph on
certain subset
\emph default
 of possible types
\end_layout

\begin_layout Itemize
We could then use the guaranteed properties of these type arguments
\end_layout

\begin_layout Itemize
This is similar to 
\emph on
partial functions
\emph default
 â€“ but at type level
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Motivation for type classes II: Partial type-level functions
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Functions can be 
\series bold
total
\series default
 or 
\series bold
partial
\end_layout

\begin_deeper
\begin_layout Itemize
Total function: has a result for all argument values
\end_layout

\begin_layout Itemize
Partial function: has 
\emph on
no result
\emph default
 for some argument values
\end_layout

\end_deeper
\begin_layout Itemize
Also, functions can be, in principle, {from/to} {values/types}:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
functions:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
from value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
from type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
to value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def f(x:
\begin_inset space \space{}
\end_inset

Int):
\begin_inset space \space{}
\end_inset

Int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def point[A]: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 List[A]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
to type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
dependent types
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
type Data[A] = Either[Int, A]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
value to value = run time, type to type / to value = compile time
\end_layout

\begin_deeper
\begin_layout Itemize
if we use JVM reflection, type-to-* can become run-time (boo!)
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
designation:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
from value (PF)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
from type (PTTF; PTVF)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
example:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
{ case Some(x) 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...
\begin_inset space \space{}
\end_inset

}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GADTs; 
\family typewriter
\size footnotesize
\color blue
implicitly[T]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when misapplied:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
exception at run time
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
error at compile time
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Type classes are a systematic way of managing your PTFs
\end_layout

\begin_deeper
\begin_layout Itemize
It is safe to apply a PTF to type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 if 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 
\begin_inset Quotes eld
\end_inset

belongs to a certain type class
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example of uses of PFs: The caveats
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Filter a 
\family typewriter
\size footnotesize
\color blue
Seq[Either[Int, Boolean]]
\family default
\size default
\color inherit
, then apply 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 with a PF:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val s: Seq[Int] = Seq( Left(1), Right(true), Left(2) )
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  .filter(_.isLeft) 
\family roman
\color gray
// result here is still of type 
\family default
\color blue
Seq[Either[...]]
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  .map { case Left(x) 
\begin_inset Formula $\Rightarrow$
\end_inset

 x } 
\family roman
\color gray
// result is of type 
\family default
\color blue
Seq[Int]
\family roman
\color gray
 but unsafe
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

We know
\begin_inset Quotes erd
\end_inset

 it is okay to apply this PF here...
\end_layout

\begin_deeper
\begin_layout Itemize
But the types do not show this, â€“ compile-time checking doesn't help
\end_layout

\begin_layout Itemize
If refactored, the code may become wrong and break 
\emph on
at run time
\end_layout

\end_deeper
\begin_layout Itemize
The type-safe version uses 
\family typewriter
\size footnotesize
\color blue
.collect
\family default
\size default
\color inherit
 instead of 
\family typewriter
\size footnotesize
\color blue
.filter().map()
\family default
\size default
\color inherit
:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val s: Seq[Int] = Seq( Left(1), Right(true), Left(2) )
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  .collect { case Left(x) 
\begin_inset Formula $\Rightarrow$
\end_inset

 x }
\family roman
\color gray
  // result is safe, of type 
\family default
\color blue
Seq[Int]
\end_layout

\begin_layout Itemize
PFs are only safe to use in certain places, such as 
\family typewriter
\size footnotesize
\color blue
.collect()
\end_layout

\begin_deeper
\begin_layout Itemize
In all other cases, value-level functions should better be total
\end_layout

\begin_layout Itemize
Can use 
\begin_inset Quotes eld
\end_inset

refined
\begin_inset Quotes erd
\end_inset

 types such as 
\begin_inset Quotes eld
\end_inset

non-empty list
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

positive number
\begin_inset Quotes erd
\end_inset

 etc.
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
def f(xs: NonEmptyList[Int]) = {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  val h = xs.head
\family roman
\color gray
  // safe and checked at compile time
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
}
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Managing PTFs by hand I: GADTs
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
PTTFs: Partial Type-to-Type Functions
\end_layout

\begin_layout Itemize
A type constructor that accepts only certain types as parameters:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
sealed trait 
\family typewriter
MyTC
\family default
[Z] 
\family roman
\color gray
// 
\begin_inset Quotes eld
\end_inset

sealed
\begin_inset Quotes erd
\end_inset

 â€“ user code can't add cases
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
final case class Case1(d: Double) extends 
\family typewriter
MyTC
\family default
[Int]
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
final case class Case2() extends 
\family typewriter
MyTC
\family default
[String]
\family roman
\color gray
 // whatever
\end_layout

\begin_layout Itemize
It looks like we have defined 
\family typewriter
\size footnotesize
\color blue
MyTC[Z]
\family default
\size default
\color inherit
 for any type 
\family typewriter
\size footnotesize
\color blue
Z
\family default
\size default
\color inherit
 ?...
\end_layout

\begin_deeper
\begin_layout Itemize
no, we can only ever create values of 
\family typewriter
\size footnotesize
\color blue
MyTC[Int]
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
MyTC[String]
\end_layout

\end_deeper
\begin_layout Itemize
So 
\family typewriter
\size footnotesize
\color blue
MyTC[Z]
\family default
\size default
\color inherit
 is a PTTF defined only for 
\family typewriter
\size footnotesize
\color blue
Z = Int
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Z = String
\end_layout

\begin_layout Itemize
This type constraint is checked and enforced 
\emph on
at compile time
\emph default
!
\end_layout

\begin_layout Itemize
When to use GADTs:
\end_layout

\begin_deeper
\begin_layout Itemize
for domain modeling (e.g.
\begin_inset space \space{}
\end_inset

queries with a fixed set of result types)
\end_layout

\begin_layout Itemize
for DSLs that have typed expressions
\end_layout

\end_deeper
\begin_layout Itemize
Instead of GADTs, a PTTF can be a trait with implementation code
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
\color blue
trait MyPTTF[Z] {...} 
\family roman
\color gray
// not 
\begin_inset Quotes eld
\end_inset

sealed
\begin_inset Quotes erd
\end_inset

 â€“ user code may extend
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
class C1(...) extends MyPTTF[Int] {...}
\family roman
\color gray
 // arbitrary code
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Managing PTFs by hand II: 
\begin_inset Quotes eld
\end_inset

Type Evidence
\begin_inset Quotes erd
\end_inset

 arguments
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
PTVFs: Partial Type-to-Value Functions
\end_layout

\begin_layout Standard
To define a function 
\family typewriter
\size footnotesize
\color blue
def func[T](...)
\family default
\size default
\color inherit
 only for certain types 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Enumerate
Create a PTTF defined only for the relevant types 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
, e.g.
\begin_inset space \space{}
\end_inset


\family typewriter
\size footnotesize
\color blue
IsGood[T]
\end_layout

\begin_layout Enumerate
Add an extra argument of type 
\family typewriter
\size footnotesize
\color blue
IsGood[T]
\family default
\size default
\color inherit
 (
\series bold
type evidence
\series default
) to 
\family typewriter
\size footnotesize
\color blue
func[T]
\end_layout

\begin_layout Enumerate
Create some values of type 
\family typewriter
\size footnotesize
\color blue
IsGood[T]
\family default
\size default
\color inherit
 as needed, for relevant types 
\family typewriter
\size footnotesize
\color blue
T 
\end_layout

\begin_layout Standard
What we gained:
\end_layout

\begin_layout Itemize
it is now impossible to call 
\family typewriter
\size footnotesize
\color blue
func
\family default
\size default
\color inherit
 with an unsupported type 
\family typewriter
\size footnotesize
\color blue
T
\end_layout

\begin_layout Itemize
trying to do so will fail 
\emph on
at compile time
\emph default
, because TE won't type-check
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
IsGood[T]
\family default
\size default
\color inherit
 is not 
\family typewriter
\size footnotesize
\color blue
sealed
\family default
\size default
\color inherit
, more types 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 can be added via user code
\end_layout

\begin_layout Standard
The cost:
\end_layout

\begin_layout Itemize
all calls to 
\family typewriter
\size footnotesize
\color blue
func
\family default
\size default
\color inherit
 now need TE values as extra argument(s)
\end_layout

\begin_layout Itemize
we need to keep passing the TE values around the code
\end_layout

\begin_layout Itemize
the TE values need to be created for each supported type 
\family typewriter
\size footnotesize
\color blue
T
\end_layout

\begin_layout Standard
How we mitigate this problem in Scala: use 
\family typewriter
\size footnotesize
\color blue
implicit
\family default
\size default
\color inherit
 values
\end_layout

\begin_layout Itemize
TE arguments are needed only at declaration site of 
\family typewriter
\size footnotesize
\color blue
func
\end_layout

\begin_layout Itemize
Once defined as 
\family typewriter
\size footnotesize
\color blue
implicit
\family default
\size default
\color inherit
, TE values are passed around automatically
\end_layout

\begin_layout Itemize
New TE values can be often built up automatically (and recursively!)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Managing PTFs by hand III: Traits with inheritance
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
PTVFs: Partial Type-to-Value Functions, the object-oriented way
\end_layout

\begin_layout Itemize
A trait with methods and a few implementations:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
trait HasPlus[Z] {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  def plus(z1: Z, z2: Z): Z
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
}
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
object CaseInt extends HasPlus[Int] {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  def plus(z1: Int, z2: Int): Int = z1 + z2
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
}
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
object CaseString extends HasPlus[String] {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  def plus(z1: String, z2: String): String = z1 + z2
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize
Similar to having 
\family typewriter
\size footnotesize
\color blue
plus[Z]
\family default
\size default
\color inherit
 only for two types, 
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
String
\end_layout

\begin_deeper
\begin_layout Itemize
We can only access 
\family typewriter
\size footnotesize
\color blue
plus[Z]
\family default
\size default
\color inherit
 via a TE value of type 
\family typewriter
\size footnotesize
\color blue
HasPlus[Z]
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Scala's mechanism of 
\begin_inset Quotes eld
\end_inset


\family typewriter
implicit
\family default
 values
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Implicit values are:
\end_layout

\begin_layout Itemize
declared as 
\family typewriter
\size footnotesize
\color blue
implicit val x:
\begin_inset space \space{}
\end_inset

SomeType = ...
\end_layout

\begin_layout Itemize
automatically passed into functions that declare extra arguments as
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f(args...)(implicit x: SomeType) = ...
\end_layout

\begin_layout Itemize
searched in local scope, imports, companion objects, parent classes
\end_layout

\begin_layout Itemize
standard library has 
\family typewriter
\size footnotesize
\color blue
def implicitly[T](implicit t:
\begin_inset space \space{}
\end_inset

T):
\begin_inset space \space{}
\end_inset

T = t
\end_layout

\begin_layout Standard
Special syntax for declaring implicit TE arguments in a PTVF:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def func[T: MyTypeClass](args...) = ...
\end_layout

\begin_layout Standard
This is equivalent to
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def func[T](args...)(implicit ev: MyTypeClass[T]) = ...
\end_layout

\begin_layout Standard
We still need to:
\end_layout

\begin_layout Itemize
declare 
\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\family default
\size default
\color inherit
 as a PTTF elsewhere
\end_layout

\begin_layout Itemize
create TE values of various types and declare them as 
\family typewriter
\size footnotesize
\color blue
implicit
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type classes I: The definition
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
A 
\series bold
type class
\series default
 is a set of PTVFs that all have the same type domain
\end_layout

\begin_layout Itemize
In terms of specific code to be written, a type class is:
\end_layout

\begin_deeper
\begin_layout Enumerate
a PTTF, e.g.
\begin_inset space \space{}
\end_inset


\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\family default
\size default
\color inherit
, defining the type domain, 
\emph on
together with
\end_layout

\begin_layout Enumerate
some code (usually, library imports) that creates some TE values, 
\emph on
and
\end_layout

\begin_layout Enumerate
one or more PTVFs that use this PTTF for TE arguments
\end_layout

\begin_layout Itemize
for many important use cases, the PTVFs must satisfy certain laws
\end_layout

\end_deeper
\begin_layout Itemize
A type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 
\begin_inset Quotes eld
\end_inset


\series bold
belongs to
\series default
 the type class 
\family typewriter
\size footnotesize
\color blue
MyTypeClass
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 if a TE value exists
\end_layout

\begin_deeper
\begin_layout Itemize
i.e.
\begin_inset space \space{}
\end_inset

if 
\emph on
some
\emph default
 value of type 
\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\family default
\size default
\color inherit
 can be found
\end_layout

\begin_deeper
\begin_layout Itemize
(usually, as a library import)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
A function 
\family typewriter
\size footnotesize
\color blue
func[T]
\family default
\size default
\color inherit
 
\begin_inset Quotes eld
\end_inset

requires the type class 
\family typewriter
\size footnotesize
\color blue
MyTypeClass
\family default
\size default
\color inherit
 for 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 if one of 
\family typewriter
\size footnotesize
\color blue
func
\family default
\size default
\color inherit
's arguments is a value of type 
\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\end_layout

\begin_deeper
\begin_layout Itemize
that argument is the 
\series bold
type class instance
\series default
 for the type parameter 
\family typewriter
\size footnotesize
\color blue
T
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type classes II: Implementation in Scala
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
A type class is typically implemented in Scala as:
\end_layout

\begin_layout Itemize
a trait with a type parameter, e.g.
\begin_inset space \space{}
\end_inset


\family typewriter
\size footnotesize
\color blue
trait MyTypeClass[T]
\end_layout

\begin_layout Itemize
code that creates values of type 
\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\family default
\size default
\color inherit
 for various 
\family typewriter
\size footnotesize
\color blue
T
\end_layout

\begin_deeper
\begin_layout Itemize
these values must be defined as 
\family typewriter
\size footnotesize
\color blue
implicit
\family default
\size default
\color inherit
 and made available via imports or in the 
\emph on
companion objects
\emph default
 for the specific types 
\family typewriter
\size footnotesize
\color blue
T
\end_layout

\end_deeper
\begin_layout Itemize
some functions with an implicit argument of type 
\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\end_layout

\begin_deeper
\begin_layout Itemize
laws for these functions may need to be enforced by tests
\end_layout

\end_deeper
\begin_layout Standard
Usually, all information about the type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 is contained in the TE value
\end_layout

\begin_layout Itemize
the trait 
\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\family default
\size default
\color inherit
 contains all relevant PTVFs as 
\family typewriter
\size footnotesize
\color blue
def
\family default
\size default
\color inherit
's
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of type classes I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Some simple PTFs and their use cases
\end_layout

\begin_layout Itemize
The type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 is 
\begin_inset Quotes eld
\end_inset

summable
\begin_inset Quotes erd
\end_inset

 if there exist functions
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def zero[T]: T
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def plus[T](x: T, y: T): T
\end_layout

\begin_layout Itemize
such that the usual arithmetical laws hold
\end_layout

\begin_layout Standard
See test code for checking the functor laws
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of type classes II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Higher-order TFs and PTFs
\end_layout

\begin_layout Itemize
This is the only way to implement 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 that satisfies the functor laws!
\end_layout

\begin_layout Standard
See test code for checking the functor laws
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Functor as a type class I: By hand
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is the only way to implement 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 that satisfies the functor laws!
\end_layout

\begin_layout Standard
See test code for checking the functor laws
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Functor as a type class II: Using the 
\family typewriter
Cats
\family default
 library
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is the only way to implement 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 that satisfies the functor laws!
\end_layout

\begin_layout Standard
See test code for checking the functor laws
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Defining higher-order PTFs on functors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is the only way to implement 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 that satisfies the functor laws!
\end_layout

\begin_layout Standard
See test code for checking the functor laws
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked examples I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is the only way to implement 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 that satisfies the functor laws!
\end_layout

\begin_layout Standard
See test code for checking the functor laws
\end_layout

\begin_layout Enumerate
Rewrite this code in the short notation; identify covariant and contravariant
 type usages; verify that with covariance annotations:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Coi[A, B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Pa[A, B](b: (A, B), c: B
\begin_inset Formula $\Rightarrow$
\end_inset

Int)  extends Coi[A, B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Re[A, B](d: A, e: B, c: Int)    extends Coi[A, B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Ci[A, B](f: String
\begin_inset Formula $\Rightarrow$
\end_inset

A, g: B
\begin_inset Formula $\Rightarrow$
\end_inset

A) extends Coi[A, B]
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Define case classes for these types, decide if they are covariant or contravaria
nt, and implement 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
contrafmap
\family default
\size default
\color inherit
 as needed:
\end_layout

\begin_layout Enumerate
Rewrite this code in the short notation; identify covariant and contravariant
 type usages; verify that with covariance annotations:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Result[A,B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class P[A,B](a: A, b: B, c: Int)   extends Result[A,B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Q[A,B](d: Int
\begin_inset Formula $\Rightarrow$
\end_inset

A, e: Int
\begin_inset Formula $\Rightarrow$
\end_inset

B) extends Result[A,B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class R[A,B](f: A
\begin_inset Formula $\Rightarrow$
\end_inset

A, g: A
\begin_inset Formula $\Rightarrow$
\end_inset

B)     extends Result[A,B]
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Further applications I: Pointed functors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is the only way to implement 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 that satisfies the functor laws!
\end_layout

\begin_layout Standard
See test code for checking the functor laws
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Further applications II: Co-pointed functors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is the only way to implement 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 that satisfies the functor laws!
\end_layout

\begin_layout Standard
See test code for checking the functor laws
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Further applications III: Filtered functors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is the only way to implement 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 that satisfies the functor laws!
\end_layout

\begin_layout Standard
See test code for checking the functor laws
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked examples II: Checking the functor laws
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
To check that the 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 laws hold for 
\begin_inset Formula $F^{A}+G^{A}$
\end_inset

 if they hold for 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset


\end_layout

\begin_layout Itemize
From 
\begin_inset Formula $f:A\Rightarrow B$
\end_inset

, get 
\begin_inset Formula $\text{fmap}_{F}(f):F^{A}\Rightarrow F^{B}$
\end_inset

 and 
\begin_inset Formula $\text{fmap}_{G}(f):G^{A}\Rightarrow G^{B}$
\end_inset


\end_layout

\begin_layout Itemize
Define 
\begin_inset Formula $\text{fmap}_{F+G}(f)=(p^{F^{A}}+q^{G^{A}})\Rightarrow\text{fmap}_{F}(f)(p)+\text{fmap}_{G}(f)(q)$
\end_inset


\end_layout

\begin_layout Itemize
Identity law: 
\begin_inset Formula $f=id$
\end_inset

, so 
\begin_inset Formula $\text{fmap}_{F}(f)=id$
\end_inset

 and 
\begin_inset Formula $\text{fmap}_{G}(f)=id$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Hence we get 
\begin_inset Formula $\text{fmap}_{F+G}(id)(p+q)=id(p)+id(q)=p+q$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Composition law: 
\begin_inset Formula 
\begin{align*}
 & (\text{fmap}_{F+G}(f_{1})\circ\text{fmap}_{F+G}(f_{2}))(p+q)\\
=\  & \text{fmap}_{F+G}(f_{2})\left(\text{fmap}_{F}(f_{1})(p)+\text{fmap}_{G}(f_{1})(q)\right)\\
=\  & (\text{fmap}_{F}(f_{1})\circ\text{fmap}_{F}(f_{2}))(p)+\left(\text{fmap}_{G}(f_{1})\circ\text{fmap}_{G}(f_{2})\right)(q)\\
=\  & \text{fmap}_{F}(f_{1}\circ f_{2})(p)+\text{fmap}_{G}(f_{1}\circ f_{2})(q)\\
=\  & \text{fmap}_{F+G}(f_{1}\circ f_{2})(p+q)
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
Note how 
\begin_inset Formula $\text{fmap}_{F+G}(f)$
\end_inset

 works on each side of 
\begin_inset Formula $\left(p+q\right)$
\end_inset

 separately
\end_layout

\begin_layout Itemize
The laws would not hold if we mixed up some parts of 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked examples III: Checking the functor laws
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
To show that 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 is a functor, assuming that 
\begin_inset Formula $F^{A}$
\end_inset

 is a contrafunctor and 
\begin_inset Formula $G^{A}$
\end_inset

 is a functor
\end_layout

\begin_layout Itemize
For a given 
\begin_inset Formula $f:A\Rightarrow B$
\end_inset

, denote for brevity 
\begin_inset Formula $\gamma_{f}=\text{fmap}_{G}(f):G^{A}\Rightarrow G^{B}$
\end_inset

 and 
\begin_inset Formula $\phi_{f}=\text{contrafmap}_{F}(f):F^{B}\Rightarrow F^{A}$
\end_inset

 , then define 
\begin_inset Formula $\text{fmap}_{F\Rightarrow G}(f)(p:F^{A}\Rightarrow G^{A}):\left(F^{B}\Rightarrow G^{B}\right)=q\Rightarrow\gamma_{f}(p(\phi_{f}(q)))$
\end_inset


\end_layout

\begin_layout Itemize
Identity law: 
\begin_inset Formula $f=id$
\end_inset

, so 
\begin_inset Formula $\gamma_{f}=id$
\end_inset

 and 
\begin_inset Formula $\phi_{f}=id$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Hence we get 
\begin_inset Formula $\text{fmap}_{F\Rightarrow G}(id)(p^{F^{A}\Rightarrow G^{A}})=\left(q^{F^{A}}\Rightarrow p(q)\right)=p$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Composition law, assuming 
\begin_inset Formula $\gamma_{f_{1}}\circ\gamma_{f_{2}}=\gamma_{f_{1}\circ f_{2}}$
\end_inset

 and 
\begin_inset Formula $\phi_{f_{2}}\circ\phi_{f_{1}}=\phi_{f_{1}\circ f_{2}}$
\end_inset

: 
\begin_inset Formula 
\begin{align*}
 & (\text{fmap}_{F\Rightarrow G}(f_{1})\circ\text{fmap}_{F\Rightarrow G}(f_{2}))(p^{F^{A}\Rightarrow G^{A}})\\
=\  & \text{fmap}_{F\Rightarrow G}(f_{2})\left(q\Rightarrow\gamma_{f_{1}}(p(\phi_{f_{1}}(q)))\right)\\
=\  & q\Rightarrow\gamma_{f_{2}}(\gamma_{f_{1}}(p(\phi_{f_{1}}(\phi_{f_{2}}(q)))))\\
=\  & q\Rightarrow\gamma_{f_{1}\circ f_{2}}(p(\phi_{f_{1}\circ f_{2}}(q)))\\
=\  & \text{fmap}_{F\Rightarrow G}(f_{1}\circ f_{2})(p)
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
The order is reversed for 
\begin_inset Formula $\phi$
\end_inset

, so this wouldn't work if 
\begin_inset Formula $F$
\end_inset

 were a functor
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises II
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Check that the 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 laws hold for 
\begin_inset Formula $F^{A}\times G^{A}$
\end_inset

 if they hold for 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset


\end_layout

\begin_layout Enumerate
Show that 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 is, in general, neither a functor nor a contrafunctor when both 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset

 are functors or both are contrafunctors (an example of suitable 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset

 will be sufficient)
\end_layout

\begin_layout Enumerate
Show that 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 is a contrafunctor if 
\begin_inset Formula $F^{A}$
\end_inset

 is a functor and 
\begin_inset Formula $G^{A}$
\end_inset

 is a contrafunctor, by checking the 
\family typewriter
\size footnotesize
\color blue
contrafmap
\family default
\size default
\color inherit
 laws for 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Other topics:
\end_layout

\begin_layout Itemize
Implementing Functor instance using Cats and Scalaz
\end_layout

\begin_layout Itemize
Implementing Functor instance for recursive types 
\end_layout

\begin_layout Itemize
Functor typeclass derivation using Shapeless
\end_layout

\begin_layout Itemize
Functions that are parameterized by a Functor type constructor
\end_layout

\begin_layout Itemize
Examples of APIs that consume a functor, with type class constraint
\end_layout

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
