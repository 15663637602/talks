\batchmode
\makeatletter
\def\input@path{{/Users/sergei.winitzki/Code/talks/ftt-fp/}}
\makeatother
\documentclass[english]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{amstext}
\usepackage[all]{xy}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 % this default might be overridden by plain title style
 \newcommand\makebeamertitle{\frame{\maketitle}}%
 % (ERT) argument for the TOC
 \AtBeginDocument{%
   \let\origtableofcontents=\tableofcontents
   \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
   \def\gobbletableofcontents#1{\origtableofcontents}
 }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 9: Traversable (contra)functors]{Chapter 9: Traversable functors and contrafunctors}
%\subtitle{Part 2: Their laws and structure}
\author{Sergei Winitzki}
\date{2018-08-08}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy}
\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

\makeatother

\begin{document}
\frame{\titlepage}
\begin{frame}{Motivation for the \texttt{\textcolor{blue}{\footnotesize{}traverse}}
operation}
\begin{itemize}
\item Consider data of type $\text{List}^{A}$ and processing $f:A\Rightarrow\text{Future}^{B}$
\item Typically, we want to wait until the entire data set is processed
\item What we need is $\text{List}^{A}\Rightarrow\left(A\Rightarrow\text{Future}^{B}\right)\Rightarrow\text{Future}^{\text{List}^{B}}$
\item Generalize: $L^{A}\Rightarrow\left(A\Rightarrow F^{B}\right)\Rightarrow F^{L^{B}}$
for some type constructors $F$, $L$
\item This operation is called \texttt{\textcolor{blue}{\footnotesize{}traverse}} 
\begin{itemize}
\item How to implement it: for example, a 3-element list is $A\times A\times A$
\item Consider $L^{A}\equiv A\times A\times A$, apply $\text{map}\,f$
and get $F^{B}\times F^{B}\times F^{B}$
\item We will get $F^{L^{B}}\equiv F^{B\times B\times B}$ if we can apply
\texttt{\textcolor{blue}{\footnotesize{}zip}} as $F^{B}\times F^{B}\Rightarrow F^{B\times B}$
\end{itemize}
\item So we need to assume that $F$ is applicative
\item In Scala, we have \texttt{\textcolor{blue}{\footnotesize{}Future.traverse()}}
that assumes $L$ to be a sequence
\begin{itemize}
\item This is the iconic example that fixes the requirements
\end{itemize}
\item Questions:
\begin{itemize}
\item Which functors $L$ can have this operation?
\item Can we express \texttt{\textcolor{blue}{\footnotesize{}traverse}}
through a simpler operation?
\item What are the required laws for \texttt{\textcolor{blue}{\footnotesize{}traverse}}?
\item What about contrafunctors or profunctors?
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Deriving the \texttt{\textcolor{blue}{\footnotesize{}sequence}} operation}
\begin{itemize}
\item The type signature of \texttt{\textcolor{blue}{\footnotesize{}traverse}}
is a complicated ``lifting''
\item A ``lifting'' is always equivalent to a simpler natural transformation
\item To derive it, ask: what is missing from \texttt{\textcolor{blue}{\footnotesize{}map}}
to do the job of \texttt{\textcolor{blue}{\footnotesize{}traverse}}?{\footnotesize{}
\[
\text{fmap}:(A\Rightarrow F^{B})\Rightarrow L^{A}\Rightarrow L^{F^{B}}
\]
}{\footnotesize \par}
\item We need $F^{L^{B}}$ but the \texttt{\textcolor{blue}{\footnotesize{}traverse}}
operation gives us $L^{F^{B}}$ instead
\item What's missing is a natural transformation \texttt{\textcolor{blue}{\footnotesize{}sequence}}
$:L^{F^{B}}\Rightarrow F^{L^{B}}$
\item The functions \texttt{\textcolor{blue}{\footnotesize{}traverse}} and
\texttt{\textcolor{blue}{\footnotesize{}sequence}} are computationally
equivalent:{\footnotesize{}
\[
\text{trav}\,f^{\underline{A\Rightarrow F^{B}}}=\text{fmap}\,f\circ\text{seq}
\]
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & L^{F^{B}}\ar[rd]\sp(0.45){\text{seq}}\\
L^{A}\ar[ru]\sp(0.45){\text{fmap}\,f}\ar[rr]\sb(0.45){\text{trav}\,(f^{\underline{A\Rightarrow F^{B}}})} &  & F^{L^{B}}
}
\]
}Here $F$ is an arbitrary applicative functor
\end{itemize}
\end{frame}

\begin{frame}{Deriving the Categorical overview of ``regular'' functor classes}

\vspace{-0.15cm}The ``liftings'' show the types of category's morphisms
\begin{itemize}
\item The functions \texttt{\textcolor{blue}{\footnotesize{}fmap$_{2}$}}
and \texttt{\textcolor{blue}{\footnotesize{}ap}} are computationally
equivalent:{\footnotesize{}
\[
\text{fmap}_{2}\,f^{A\Rightarrow B\Rightarrow Z}=\text{fmap}\,f\circ\text{ap}
\]
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{B\Rightarrow Z}\ar[rd]\sp(0.45){\text{ap}}\\
F^{A}\ar[ru]\sp(0.45){\text{fmap}\,f}\ar[rr]\sb(0.45){\text{fmap}_{2}\,(f^{A\Rightarrow B\Rightarrow Z})} &  & \left(F^{B}\Rightarrow F^{Z}\right)
}
\]
}{\footnotesize \par}
\begin{itemize}
\item Note the pattern: a natural transformation is equivalent to a lifting
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Categorical overview of ``regular'' functor classes}

\vspace{-0.15cm}The ``liftings'' show the types of category's morphisms
\end{frame}

\begin{frame}{Categorical overview of ``regular'' functor classes}

\vspace{-0.15cm}The ``liftings'' show the types of category's morphisms
\end{frame}

\begin{frame}{Categorical overview of ``regular'' functor classes}

\vspace{-0.15cm}The ``liftings'' show the types of category's morphisms
\begin{center}
\vspace{-0.08cm}%
\begin{tabular}{|c|c|c|}
\hline 
\textbf{\scriptsize{}class name} &
\textbf{\scriptsize{}lifting's name and type signature} &
\textbf{\scriptsize{}category's morphism}\tabularnewline
\hline 
\hline 
{\scriptsize{}functor} &
{\scriptsize{}$\text{fmap}:\left(A\Rightarrow B\right)\Rightarrow F^{A}\Rightarrow F^{B}$} &
{\scriptsize{}$A\Rightarrow B$}\tabularnewline
\hline 
{\scriptsize{}filterable} &
{\scriptsize{}$\text{fmapOpt}:\left(A\Rightarrow1+B\right)\Rightarrow F^{A}\Rightarrow F^{B}$} &
{\scriptsize{}$A\Rightarrow1+B$}\tabularnewline
\hline 
{\scriptsize{}monad} &
{\scriptsize{}$\text{flm}:\left(A\Rightarrow F^{B}\right)\Rightarrow F^{A}\Rightarrow F^{B}$} &
{\scriptsize{}$A\Rightarrow F^{B}$}\tabularnewline
\hline 
{\scriptsize{}applicative} &
{\scriptsize{}$\text{ap}:F^{A\Rightarrow B}\Rightarrow F^{A}\Rightarrow F^{B}$} &
{\scriptsize{}$F^{A\Rightarrow B}$}\tabularnewline
\hline 
{\scriptsize{}contrafunctor} &
{\scriptsize{}$\text{contrafmap}:\left(B\Rightarrow A\right)\Rightarrow F^{A}\Rightarrow F^{B}$} &
{\scriptsize{}$B\Rightarrow A$}\tabularnewline
\hline 
{\scriptsize{}profunctor} &
{\scriptsize{}$\text{xmap}:\left(A\Rightarrow B\right)\times\left(B\Rightarrow A\right)\Rightarrow F^{A}\Rightarrow F^{B}$} &
{\scriptsize{}$\left(A\Rightarrow B\right)\times\left(B\Rightarrow A\right)$}\tabularnewline
\hline 
{\scriptsize{}contra-filterable} &
{\scriptsize{}$\text{contrafmapOpt}:\left(B\Rightarrow1+A\right)\Rightarrow F^{A}\Rightarrow F^{B}$} &
{\scriptsize{}$B\Rightarrow1+A$}\tabularnewline
\hline 
\multicolumn{1}{|c}{} &
\multicolumn{1}{c}{{\scriptsize{}Not yet considered:}} &
\tabularnewline
\hline 
{\scriptsize{}comonad} &
{\scriptsize{}$\text{coflm}:\left(F^{A}\Rightarrow B\right)\Rightarrow F^{A}\Rightarrow F^{B}$} &
{\scriptsize{}$F^{A}\Rightarrow B$scriptsize{}$F^{A}\Rightarrow B$}\tabularnewline
\hline 
\end{tabular}
\par\end{center}

Need to define each category's composition and identity morphism

Then impose the category laws, the naturality laws, and the functor
laws
\begin{itemize}
\item Obtained a systematic picture of the ``regular'' type classes
\item Some classes (e.g.\ contra-applicative) aren't covered by this scheme
\item Some of the possibilities (e.g.\ ``contramonad'') don't actually
work out
\end{itemize}
\end{frame}

\begin{frame}{Exercises}
\begin{enumerate}
\item {\footnotesize{}\vspace{-0.15cm}Show that }\texttt{\textcolor{blue}{\footnotesize{}pure}}{\footnotesize{}
will be automatically a natural transformation when it is defined
using }\texttt{\textcolor{blue}{\footnotesize{}wu}}{\footnotesize{}
as shown in the slides.}{\footnotesize \par}
\item {\footnotesize{}Use naturality of }\texttt{\textcolor{blue}{\footnotesize{}pure}}{\footnotesize{}
to show that $\text{pure}\,f\odot\text{pure}\,g=\text{pure}\left(f\circ g\right)$}{\footnotesize \par}
\item {\footnotesize{}Show that $F^{A}\equiv\left(A\Rightarrow Z\right)\Rightarrow\left(1+A\right)$
is a functor but not applicative.}{\footnotesize \par}
\item {\footnotesize{}Show that $P^{S}$ is a monoid if $S$ is a monoid
and $P$ is any applicative functor, contrafunctor, or profunctor.}{\footnotesize \par}
\item {\footnotesize{}Implement an applicative instance for $F^{A}=1+\text{Int}\times A+A\times A\times A$.}{\footnotesize \par}
\item {\footnotesize{}Using applicative constructions, show without lengthy
proofs that $F^{A}=G^{A}+H^{G^{A}}$ is applicative if $G$ and $H$
are applicative functors.}{\footnotesize \par}
\item {\footnotesize{}Explicitly implement contrafunctor construction 2
and prove the laws.}{\footnotesize \par}
\item {\footnotesize{}For any contrafunctor $H^{A}$, construction 5 says
that $F^{A}\equiv H^{A}\Rightarrow A$ is applicative. Implement the
code of }\texttt{\textcolor{blue}{\footnotesize{}zip(fa, fb)}}{\footnotesize{}
for this construction.}{\footnotesize \par}
\item {\footnotesize{}Show that the recursive functor $F^{A}\equiv1+G^{A\times F^{A}}$
is applicative if $G^{A}$ is applicative and $\text{wu}_{F}$ is
defined recursively as $0+\text{pure}_{G}\left(1\times\text{wu}_{F}\right)$.}{\footnotesize \par}
\item {\footnotesize{}Explicitly implement profunctor construction 5 and
prove the laws. }{\footnotesize \par}
\item {\footnotesize{}Prove rigorously that all exponential-polynomial type
constructors are profunctors.}{\footnotesize \par}
\item {\footnotesize{}Implement profunctor and applicative instances for
$P^{A}\equiv A+Z\times G^{A}$ where $G^{A}$ is a given applicative
profunctor and $Z$ is a monoid.}{\footnotesize \par}
\item {\footnotesize{}Show that, for any profunctor $P^{A}$, one can implement
a function of type $A\Rightarrow P^{B}\Rightarrow P^{A\times B}$
but not of type $A\Rightarrow P^{B}\Rightarrow P^{A}$. }{\footnotesize \par}
\end{enumerate}
\end{frame}

\end{document}
