\batchmode
\makeatletter
\def\input@path{{/Users/sergei.winitzki/Code/talks/ftt-fp/}}
\makeatother
\documentclass[english]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{wasysym}
\usepackage[all]{xy}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 % this default might be overridden by plain title style
 \newcommand\makebeamertitle{\frame{\maketitle}}%
 % (ERT) argument for the TOC
 \AtBeginDocument{%
   \let\origtableofcontents=\tableofcontents
   \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
   \def\gobbletableofcontents#1{\origtableofcontents}
 }
 \newenvironment{lyxcode}
   {\par\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \setlength{\listparindent}{0pt}% needed for AMS classes
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \normalfont\ttfamily}%
    \def\{{\char`\{}
    \def\}{\char`\}}
    \def\textasciitilde{\char`\~}
    \item[]}
   {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 7: Functor-lifted computations II]{Chapter 7: Computations lifted to a functor context II}
\subtitle{Part 1: Examples of monads and semimonads}
\author{Sergei Winitzki}
\date{2018-02-10}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy}
\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

\makeatother

\begin{document}
\frame{\titlepage}
\begin{frame}{Computations within a functor context: Semimonads}


\framesubtitle{Intuitions behind adding more ``generator arrows''}

Example: {\footnotesize{}
\[
\sum_{i=1}^{n}\sum_{j=1}^{n}\sum_{k=1}^{n}f(i,j,k)
\]
}{\footnotesize \par}

Using Scala's \texttt{\textcolor{blue}{\footnotesize{}for}}/\texttt{\textcolor{blue}{\footnotesize{}yield}}
syntax (``functor block'')

\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}(for~\{~i~$\leftarrow$~1~to~n}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~j~$\leftarrow$~1~to~n}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~k~$\leftarrow$~1~to~n}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~\}~yield~f(i,~j,~k)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}).sum}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}(1~to~m).flatMap~\{~i~$\Rightarrow$}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~(1~to~n).flatMap~\{~j~$\Rightarrow$}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~~(1~to~n).map~\{~k~$\Rightarrow$}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~~~~f(i,~j,~k)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~\}\}\}.sum}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\medskip{}
}}{\footnotesize \par}
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}map}} replaces the last left
arrow, \texttt{\textcolor{blue}{\footnotesize{}flatMap}} replaces
other left arrows
\begin{itemize}
\item When the functor is \emph{also} filterable, we can use ``\texttt{\textcolor{blue}{\footnotesize{}if}}''
as well
\end{itemize}
\item Standard library defines \texttt{\textcolor{blue}{\footnotesize{}flatMap()}}
as equivalent of \texttt{\textcolor{blue}{\footnotesize{}map() $\circ$
flatten}} 
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}(1 to n).flatMap(j $\Rightarrow$
...)}} is \texttt{\textcolor{blue}{\footnotesize{}(1 to n).map(j $\Rightarrow$
...).flatten}} 
\end{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}flatten:\ F{[}F{[}A{]}{]}
$\Rightarrow$ F{[}A{]}}} can be expressed through \texttt{\textcolor{blue}{\footnotesize{}flatMap}}
as well:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}(xss:\ Seq{[}Seq{[}A{]}{]}).flatten
= xss.flatMap \{ (xs:\ Seq{[}A{]}) $\Rightarrow$ xs \}}} 
\end{itemize}
\item Functors having \texttt{\textcolor{blue}{\footnotesize{}flatMap}}/\texttt{\textcolor{blue}{\footnotesize{}flatten}}
are ``flattenable'' or \textbf{semimonads}
\begin{itemize}
\item Most of them also have method \texttt{\textcolor{blue}{\footnotesize{}pure:\ A
$\Rightarrow$ F{[}A{]}}} and so are \textbf{monads}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{What is \texttt{\textcolor{blue}{\footnotesize{}flatMap}} doing with
the data in a collection?}

Consider this schematic code using \texttt{\textcolor{blue}{\footnotesize{}Seq}}
as the container type:\texttt{\textcolor{blue}{\footnotesize{} }}%
\begin{minipage}[t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~result~=~for~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~i~$\leftarrow$~1~to~m}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~j~$\leftarrow$~1~to~n}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~x~=~f(i,j)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~k~$\leftarrow$~1~to~p}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~y~=~g(i,j,k)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}~yield~h(x,y)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~result~=~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~(1~to~m).flatMap~\{~i~$\Rightarrow$}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~(1~to~n).flatMap~\{~j~$\Rightarrow$}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~~~val~x~=~f(i,j)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~~~(1~to~p).map~\{~k~$\Rightarrow$}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~~~~~val~y~=~g(i,j,k)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~~~~~h(x,y)~~\}~\}~\}~\}}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\medskip{}
}}{\footnotesize \par}

Computations are repeated for all $i$, for all $j$, etc., from each
collection
\begin{itemize}
\item All collections must have the same container type
\begin{itemize}
\item Each \emph{generator line} finally computes a container of the same
type
\item The total number of resulting data items is $\leq m*n*p$\texttt{\textcolor{blue}{\footnotesize{} }}{\footnotesize \par}
\item All the resulting data items must fit within \emph{the same} container
type!
\item {\footnotesize{}The set of }\emph{\footnotesize{}container capacity
counts}{\footnotesize{} must be closed under multiplication}{\footnotesize \par}
\end{itemize}
\item What container types have this property?
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}Seq,}} \texttt{\textcolor{blue}{\footnotesize{}NonEmptyList}}
\textendash{} can hold \emph{any} number of elements $\geq$ min.\ count
\item \texttt{\textcolor{blue}{\footnotesize{}Option}}, \texttt{\textcolor{blue}{\footnotesize{}Either}},
\texttt{\textcolor{blue}{\footnotesize{}Try}}, \texttt{\textcolor{blue}{\footnotesize{}Future}}
\textendash{} can hold $0$ or $1$ elements (``pass/fail'')
\item ``Tree-like'' containers, e.g.\ can hold only $3$, $6$, $9$,
$12$, ...\ elements
\item ``Non-standard'' containers: $F^{A}\equiv\text{String}\Rightarrow A$;
$F^{A}\equiv\left(A\Rightarrow\text{Int}\right)\Rightarrow\text{Int}$
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Working with list-like monads}


\framesubtitle{\texttt{\footnotesize{}Seq}, \texttt{\footnotesize{}NonEmptyList},
\texttt{\footnotesize{}Iterator}, \texttt{\footnotesize{}Stream}}

Typical tasks for ``list-like'' monads:
\begin{itemize}
\item Create a list of all combinations or all permutations of a sequence
\item Traverse a ``solution tree'' with DFS and filter out incorrect solutions
\begin{itemize}
\item Can use eager (\texttt{\textcolor{blue}{\footnotesize{}Seq}}) or lazy
(\texttt{\textcolor{blue}{\footnotesize{}Iterator}}, \texttt{\textcolor{blue}{\footnotesize{}Stream}})
evaluation strategies
\item Usually, list-like containers have many additional methods
\begin{itemize}
\item append, prepend, concat, fill, fold, scan, etc.
\end{itemize}
\end{itemize}
\end{itemize}
Examples: see code
\begin{enumerate}
\item All permutations of \texttt{\textcolor{blue}{\footnotesize{}Seq(\textquotedbl{}a\textquotedbl{},
\textquotedbl{}b\textquotedbl{}, \textquotedbl{}c\textquotedbl{})}} 
\item All subsets of \texttt{\textcolor{blue}{\footnotesize{}Set(\textquotedbl{}a\textquotedbl{},
\textquotedbl{}b\textquotedbl{}, \textquotedbl{}c\textquotedbl{})}} 
\item All subsequences of length 3 out of the sequence \texttt{\textcolor{blue}{\footnotesize{}(1
to m)}} 
\item All solutions of the ``8 queens'' problem
\item Generalize examples 1-3 to support arbitrary length $n$ instead of
3
\item Generalize example 4 to solve $n$-queens problem
\item Transform Boolean formulas between CNF and DNF 
\end{enumerate}
\end{frame}

\begin{frame}{Intuitions for pass/fail monads}


\framesubtitle{\texttt{\footnotesize{}Option}, \texttt{\footnotesize{}Either}, \texttt{\footnotesize{}Try},
\texttt{\footnotesize{}Future}}
\begin{itemize}
\item Container $F^{A}$ can hold $n=1$ or $n=0$ values of type $A$
\item Such containers will have methods to create ``pass'' and ``fail''
values
\end{itemize}
Schematic example of a functor block program using the \texttt{\textcolor{blue}{\footnotesize{}Try}}
functor:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~result:~Try{[}A{]}~=~for~\{~}\textrm{\textcolor{darkgray}{\footnotesize{}//~computations~in~the~}}\textcolor{darkgray}{\footnotesize{}Try}\textrm{\textcolor{darkgray}{\footnotesize{}~functor}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~x~$\leftarrow$~Try(...)~}\textrm{\textcolor{darkgray}{\footnotesize{}//~first~computation;~may~fail}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~y~=~f(x)~}\textrm{\textcolor{darkgray}{\footnotesize{}//~no~possibility~of~failure~in~this~line}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~if~p(y)~}\textrm{\textcolor{darkgray}{\footnotesize{}//~the~entire~expression~will~fail~if~this~is~false}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~z~$\leftarrow$~Try(g(x,~y))}\textrm{\textcolor{darkgray}{\footnotesize{}~//~may~fail~here}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~r~$\leftarrow$~Try(...)}\textrm{\textcolor{darkgray}{\footnotesize{}~//~may~fail~here~as~well}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}~yield~r~}\textrm{\textcolor{darkgray}{\footnotesize{}//~~}}\textcolor{darkgray}{\footnotesize{}r}\textrm{\textcolor{darkgray}{\footnotesize{}~is~of~type~}}\textcolor{darkgray}{\footnotesize{}A}\textrm{\textcolor{darkgray}{\footnotesize{},~so~}}\textcolor{darkgray}{\footnotesize{}result}\textrm{\textcolor{darkgray}{\footnotesize{}~is~of~type~}}\textcolor{darkgray}{\footnotesize{}Try{[}A{]}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Computations may yield a result ($n=1$), or may fail ($n=0$)
\item The functor block chains several such computations \emph{sequentially}
\begin{itemize}
\item Computations are sequential even if using the \texttt{\textcolor{blue}{\footnotesize{}Future}}
functor!
\item Once any computation fails, the entire functor block fails ($0*n=0$)
\item Only if \emph{all} computations succeed, the functor block returns
\emph{one} value
\item Filtering can also make the entire expression fail
\end{itemize}
\item ``Flat'' functor block replaces a chain of nested \texttt{\textcolor{blue}{\footnotesize{}if/else}}
or \texttt{\textcolor{blue}{\footnotesize{}match/case}}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Working with pass/fail monads}

Typical tasks for pass/fail monads:
\begin{itemize}
\item Perform a linear sequence of computations that may fail
\item Avoid crashing on failure, instead return an \emph{error value}
\end{itemize}
Examples: see code
\begin{enumerate}
\item Read values of Java properties, checking that they all exist
\item Obtain values from \texttt{\textcolor{blue}{\footnotesize{}Future}}
computations in sequence
\item Make arithmetic safe by returning error messages in \texttt{\textcolor{blue}{\footnotesize{}Either}} 
\item Fail less: allow up to 2 computations out of $n$ to throw an exception
\item Generalize example 3 to support up to $k$ failures instead of 2
\end{enumerate}
\end{frame}

\begin{frame}{Working with tree-like monads}

Typical tasks for tree-like monads:
\begin{itemize}
\item Traverse a syntax tree, substitute subexpressions
\item ???
\end{itemize}
Examples: see code
\begin{enumerate}
\item Implement variable substitution for a simple arithmetic language
\item ???
\end{enumerate}
\end{frame}

\begin{frame}{Single-value monads (non-standard containers)}


\framesubtitle{\texttt{\footnotesize{}Reader}, \texttt{\footnotesize{}Writer}, \texttt{\footnotesize{}Eval},
\texttt{\footnotesize{}Cont}, \texttt{\footnotesize{}State}}
\begin{itemize}
\item Container holds exactly $1$ value, together with a ``context''
\item Usually, methods exist to insert a value and to work with the ``context''
\end{itemize}
Typical tasks for single-value monads:
\begin{itemize}
\item Collecting extra information about computations along the way
\item Chaining computations with a nonstandard evaluation strategy
\end{itemize}
Examples: see code
\begin{enumerate}
\item Dependency injection with the \texttt{\textcolor{blue}{\footnotesize{}Reader}}
monad
\item Perform computations and log information about each step
\item Perform lazy or memoized computations in a sequence
\item A chain of asynchronous operations
\item A sequence of steps that update state while returning results
\end{enumerate}
\end{frame}

\begin{frame}{Semimonad laws I: The intuitions}

What properties of functor block programs do we expect to have?
\begin{itemize}
\item In \texttt{\textcolor{blue}{\footnotesize{}x $\leftarrow$ c}}, the
value of \texttt{\textcolor{blue}{\footnotesize{}x}} will \emph{go
over items} held in container \texttt{\textcolor{blue}{\footnotesize{}c}} 
\item Manipulating items in container is followed by a generator:
\end{itemize}
\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[c][1\totalheight][t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}x~$\leftarrow$~cont1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}y~=~f(x)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}z~$\leftarrow$~cont2(y)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}}}%
\begin{minipage}[c][1\totalheight][t]{0.4\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}y~$\leftarrow$~cont1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~~~.map(x~$\Rightarrow$~f(x))}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}z~$\leftarrow$~cont2(y)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}\medskip{}
}}{\footnotesize \par}

\texttt{\textcolor{blue}{\footnotesize{}cont1.flatMap(x $\Rightarrow$
cont2(f(x))) = cont1.map(f).flatMap(y $\Rightarrow$ cont2(y))}} 
\begin{itemize}
\item Manipulating items in container is preceded by a generator:
\end{itemize}
\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[c][1\totalheight][t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}x~$\leftarrow$~cont1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}y~$\leftarrow$~cont2(x)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}z~=~f(y)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}}}%
\begin{minipage}[c][1\totalheight][t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}x~$\leftarrow$~cont1}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}z~$\leftarrow$~cont2(x)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~~~~.map(f)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}\medskip{}
cont1.flatMap(cont2).map(f)}} \texttt{\textcolor{blue}{\footnotesize{}=
cont1.flatMap(x $\Rightarrow$ cont2(x).map(f))}} 
\begin{itemize}
\item After \texttt{\textcolor{blue}{\footnotesize{}x $\leftarrow$ c}},
further computations will use \emph{all those} \texttt{\textcolor{blue}{\footnotesize{}x}} 
\end{itemize}
\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[c][1\totalheight][t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}x~$\leftarrow$~cont}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}y~$\leftarrow$~p(x)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}z~$\leftarrow$~cont2(y)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}}}%
\begin{minipage}[c][1\totalheight][t]{0.49\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}y~$\leftarrow$~for~\{~x~$\leftarrow$~cont}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~~~~~~~~~~yy~$\leftarrow$~p(x)~\}~yield~yy}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}z~$\leftarrow$~cont2(y)}{\footnotesize \par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}\medskip{}
cont.flatMap(x $\Rightarrow$ p(x).flatMap(cont2)) = cont.flatMap(p).flatMap(cont2)}} 
\end{frame}

\begin{frame}{Semimonad laws II: The laws for \texttt{\textcolor{blue}{\footnotesize{}flatMap}} }

To use the concise notation, denote \texttt{\textcolor{blue}{\footnotesize{}flatMap}}
by {\footnotesize{}$\text{flm}$} 

A \textbf{semimonad} $S^{A}$ has {\footnotesize{}$\text{flm}^{\left[S,A,B\right]}:\left(A\Rightarrow S^{B}\right)\Rightarrow S^{A}\Rightarrow S^{B}$}
with 3 laws:
\begin{enumerate}
\item {\footnotesize{}$\text{flm}\,(f^{A\Rightarrow B}\circ g^{B\Rightarrow S^{C}})=\text{fmap}\,f\circ\text{flm}\,g$}
{\footnotesize{}(naturality in $A$)} {\footnotesize{}
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & S^{B}\ar[rd]\sp(0.5){\ \text{flm}\,g^{B\Rightarrow S^{C}}}\\
S^{A}\ar[ru]\sp(0.5){\text{fmap}\,f^{A\Rightarrow B}\ }\ar[rr]\sb(0.5){\text{flm}\,(f^{A\Rightarrow B}\circ\,g^{B\Rightarrow S^{C}})\,} &  & S^{C}
}
\]
}{\footnotesize \par}
\item {\footnotesize{}$\text{flm}\,\big(f^{A\Rightarrow S^{B}}\circ\text{fmap}\,g^{B\Rightarrow C}\big)=\text{flm}\,f\circ\text{fmap}\,g$}
{\footnotesize{}(naturality in $B$)} {\footnotesize{}
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & S^{B}\ar[rd]\sp(0.5){\ \text{fmap}\,g^{B\Rightarrow C}}\\
S^{A}\ar[ru]\sp(0.5){\text{flm}\,f^{A\Rightarrow S^{B}}\ }\ar[rr]\sb(0.5){\text{flm}\,(f^{A\Rightarrow S^{B}}\circ\,\text{fmap}\,g^{B\Rightarrow C})\,} &  & S^{C}
}
\]
}{\footnotesize \par}
\item {\footnotesize{}$\text{flm}\,\big(f^{A\Rightarrow S^{B}}\circ\text{flm}\,g^{B\Rightarrow S^{C}}\big)=\text{flm}\,f\circ\text{flm}\,g$}
{\footnotesize{}(composition)} {\footnotesize{}
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & S^{B}\ar[rd]\sp(0.5){\ \text{flm}\,g^{B\Rightarrow S^{C}}}\\
S^{A}\ar[ru]\sp(0.5){\text{flm}\,f^{A\Rightarrow S^{B}}\ }\ar[rr]\sb(0.5){\text{flm}\,\big(f^{A\Rightarrow S^{B}}\circ\,\text{flm}\,g^{B\Rightarrow S^{C}}\big)\,} &  & S^{C}
}
\]
}{\footnotesize \par}
\end{enumerate}
Is there a shorter formulation of the laws?
\end{frame}

\begin{frame}{Semimonad laws III: The laws for \texttt{\textcolor{blue}{\footnotesize{}flatten}} }

The methods \texttt{\textcolor{blue}{\footnotesize{}flatten}} (denoted
by {\footnotesize{}$\text{ftn}$}) and \texttt{\textcolor{blue}{\footnotesize{}flatMap}}
are equivalent:\texttt{\textcolor{blue}{\footnotesize{} }}%
\begin{minipage}[c][1\totalheight][t]{0.4\columnwidth}%
{\footnotesize{}
\begin{align*}
\text{ftn}^{\left[S,A\right]}:S^{S^{A}}\Rightarrow S^{A} & =\text{flm}^{\left[S,S^{A},A\right]}(m^{S^{A}}\Rightarrow m)\\
\text{flm}\,\big(f^{A\Rightarrow S^{B}}\big) & =\text{fmap}\,f\circ\text{ftn}
\end{align*}
}%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}}}%
\begin{minipage}[c][1\totalheight][t]{0.4\columnwidth}%
{\footnotesize{}
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & S^{S^{B}}\ar[rd]\sp(0.5){\ \text{ftn}\ }\\
S^{A}\ar[ru]\sp(0.5){\text{fmap}\,f^{A\Rightarrow S^{B}}\ }\ar[rr]\sb(0.5){\text{flm}\,\big(f^{A\Rightarrow S^{B}}\big)\,} &  & S^{B}
}
\]
}%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\  \  \ \hfill{}}}{\footnotesize \par}

It turns out that \texttt{\textcolor{blue}{\footnotesize{}flatten}}
has only 2 laws:
\begin{enumerate}
\item {\footnotesize{}$\text{fmap}\big(\text{fmap}\,f^{A\Rightarrow B}\big)\circ\text{ftn}^{\left[S,B\right]}=\text{ftn}^{\left[S,A\right]}\circ\text{fmap}\,f$}
{\footnotesize{}(naturality)
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{5pc} & S^{S^{B}}\ar[rd]\sp(0.5){\ \text{ftn}^{\left[S,B\right]}}\\
S^{S^{A}}\ar[ru]\sp(0.5){\text{fmap}\,\big(\text{fmap}\,f^{A\Rightarrow B}\big)\ \ }\ar[rd]\sb(0.5){\text{ftn}^{\left[S,A\right]}\,} &  & S^{B}\\
 & S^{A}\ar[ru]\sb(0.5){\text{fmap}\,f^{A\Rightarrow B}}
}
\]
}{\footnotesize \par}
\item {\footnotesize{}$\text{fmap}\,(\text{ftn}^{\left[S\right]})\circ\text{ftn}^{\left[S\right]}=\text{ftn}^{\left[S^{S}\right]}\circ\text{ftn}^{\left[S\right]}$}
{\footnotesize{}(associativity) 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{5pc} & S^{S^{A}}\ar[rd]\sp(0.5){\ \text{ftn}^{\left[S\right]}}\\
S^{S^{S^{A}}}\ar[ru]\sp(0.5){\text{fmap}\,(\text{ftn}^{\left[S\right]})\ }\ar[rd]\sb(0.5){\text{ftn}^{\left[S^{S}\right]}\,} &  & S^{A}\\
 & S^{S^{A}}\ar[ru]\sb(0.5){\text{ftn}^{\left[S\right]}}
}
\]
}{\footnotesize \par}
\end{enumerate}
\end{frame}

\begin{frame}{Semimonad laws III: Deriving the laws for \texttt{\textcolor{blue}{\footnotesize{}flatten}} }

Denote for brevity $q_{\uparrow}\equiv\text{fmap}^{\left[S\right]}\,q$
for any function $q$

Express $\text{flm}\,f=f_{\uparrow}\circ\text{ftn}$ and substitute
that into $\text{flm}$'s 3 laws:
\begin{enumerate}
\item $\text{flm}\left(f\circ g\right)=f_{\uparrow}\circ\text{flm}\,g$
gives $\left(f\circ g\right)_{\uparrow}\circ\text{ftn}=f_{\uparrow}\circ g_{\uparrow}\circ\text{ftn}$\\
\textendash{} this law holds automatically due to functor composition
law
\item $\text{flm}\left(f\circ g_{\uparrow}\right)=\text{flm}\,f\circ g_{\uparrow}$
gives $\left(f\circ h\right)_{\uparrow}\circ\text{ftn}=f_{\uparrow}\circ\text{ftn}\circ h$;\\
using the functor composition law, we reduce this to $h_{\uparrow}\circ\text{ftn}=\text{ftn}\circ h$\\
\textendash{} this is the naturality law for \texttt{\textcolor{blue}{\footnotesize{}flatten}} 
\item {\footnotesize{}$\text{flm}\left(f\circ\text{flm}\,g\right)=\text{flm}\,f\circ\text{flm}\,g$
}with functor composition law gives{\footnotesize{} $f_{\uparrow}\circ g_{\uparrow\uparrow}\circ\text{ftn}_{\uparrow}\circ\text{ftn}=f_{\uparrow}\circ\text{ftn}\circ g_{\uparrow}\circ\text{ftn}$;}
using $\text{ftn}$'s naturality and omitting the common factor{\footnotesize{}
$f_{\uparrow}\circ g_{\uparrow\uparrow}$}, we get $\text{ftn}$'s
associativity:{\footnotesize{} $\text{ftn}_{\uparrow}\circ\text{ftn}=\text{ftn}\circ\text{ftn}$}{\footnotesize \par}
\end{enumerate}
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}flatten}} has the simplest
type signature and the fewest laws
\item It is usually easy to check naturality!
\begin{itemize}
\item \textbf{Parametricity theorem}: Any \emph{fully parametric} code for
a function of type $F^{A}\Rightarrow G^{A}$ implements a natural
transformation $F\leadsto G$
\end{itemize}
\item Checking \texttt{\textcolor{blue}{\footnotesize{}flatten}}'s associativity
needs more work
\end{itemize}
The \texttt{\textcolor{blue}{\footnotesize{}cats}} library has a \texttt{\textcolor{blue}{\footnotesize{}FlatMap}}
type class, defining \texttt{\textcolor{blue}{\footnotesize{}flatten}}
via \texttt{\textcolor{blue}{\footnotesize{}flatMap}} 
\end{frame}

\begin{frame}{Semimonad laws IV: Checking the laws of \texttt{\textcolor{blue}{\footnotesize{}flatten}} }
\begin{itemize}
\item Implement \texttt{\textcolor{blue}{\footnotesize{}flatten}} for these
functors and check the laws (see code):
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}Option}} monad: $F^{A}\equiv1+A$;
$\text{ftn}:1+\left(1+A\right)\Rightarrow1+A$
\item \texttt{\textcolor{blue}{\footnotesize{}Either}} monad: $F^{A}\equiv Z+A$;
$\text{ftn}:Z+\left(Z+A\right)\Rightarrow Z+A$
\item \texttt{\textcolor{blue}{\footnotesize{}List}} monad: $F^{A}\equiv\text{List}^{A}$;
$\text{ftn}:\text{List}^{\text{List}^{A}}\Rightarrow\text{List}^{A}$
\item Writer monad: $F^{A}\equiv A\times W$; $\text{ftn}:\left(A\times W\right)\times W\Rightarrow A\times W$
\item Reader monad: $F^{A}\equiv R\Rightarrow A$; $\text{ftn}:\left(R\Rightarrow\left(R\Rightarrow A\right)\right)\Rightarrow R\Rightarrow A$
\item State: $F^{A}\equiv S\Rightarrow A\times S$; $\text{ftn}:\left(S\Rightarrow\left(S\Rightarrow A\times S\right)\times S\right)\Rightarrow S\Rightarrow A\times S$
\item Continuation monad: $F^{A}\equiv\left(A\Rightarrow R\right)\Rightarrow R$;
$\text{ftn}:\left(\left(\left(\left(A\Rightarrow R\right)\Rightarrow R\right)\Rightarrow R\right)\Rightarrow R\right)\Rightarrow\left(A\Rightarrow R\right)\Rightarrow R$
\end{itemize}
\item Code implementing these \texttt{\textcolor{blue}{\footnotesize{}flatten}}
functions is \emph{fully parametric} in $A$
\begin{itemize}
\item Naturality of these functions follows from parametricity theorem
\end{itemize}
\item Associativity needs to be checked for each monad!
\item Example of a useful semimonad that is \emph{not} a full monad:
\begin{itemize}
\item $F^{A}\equiv A\times V\times W$; $\text{ftn}\left(\left(a\times v_{1}\times w_{1}\right)\times v_{2}\times w_{2}\right)=a\times v_{1}\times w_{2}$
\end{itemize}
\item Examples of \emph{non-associative} (i.e.\ wrong) implementations
of \texttt{\textcolor{blue}{\footnotesize{}flatten}}:
\begin{itemize}
\item $F^{A}\equiv A\times W\times W$; $\text{ftn}\left(\left(a\times v_{1}\times v_{2}\right)\times w_{1}\times w_{2}\right)=a\times w_{2}\times w_{1}$
\item $F^{A}\equiv\text{List}^{A}$, but \texttt{\textcolor{blue}{\footnotesize{}flatten}}
concatenates the nested lists in reverse order
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Exercises I}
\begin{enumerate}
\item Confucius gave wisdom on each of the 7 days of a week. Sometimes the
wise proverbs were hard to remember. If Confucius forgets what he
said on a given day, he also forgets what he said on all the previous
days of the week. Is this setup described by a filterable functor?
\item Define \texttt{\textcolor{blue}{\footnotesize{}evenFilter(p)}} on
an \texttt{\textcolor{blue}{\footnotesize{}IndexedSeq{[}T{]}}} such
that a value \texttt{\textcolor{blue}{\footnotesize{}x:\ T}} is retained
if \texttt{\textcolor{blue}{\footnotesize{}p(x)=true}} \emph{and}
only if the sequence has an \emph{even} number of elements \texttt{\textcolor{blue}{\footnotesize{}y}}
for which \texttt{\textcolor{blue}{\footnotesize{}p(y)=false}}. Does
this define a filterable functor?\\
\ \\
Implement \texttt{\textcolor{blue}{\footnotesize{}filter}} for these
functors if possible (law checking optional):
\item $F^{A}\equiv\text{Int}+\text{String}\times A\times A\times A$
\item \texttt{\textcolor{blue}{\footnotesize{}final case class Q{[}A, Z{]}(id:\ Long,
user1:\ Option{[}(A, Z){]}, user2:\ Option{[}(A, Z){]}) }}\textendash{}
with respect to the type parameter $A$
\item $F^{A}=\text{MyTree}^{A}$ defined recursively as $F^{A}\equiv1+A\times F^{A}\times F^{A}$
\item \texttt{\textcolor{blue}{\footnotesize{}final case class R{[}A{]}(x:\ Int,\ y: Int,
z:\ A, data:\ List{[}A{]})}}, where the standard functor $\text{List}$
already has \texttt{\textcolor{blue}{\footnotesize{}withFilter}} defined
\item {*} Show that $C^{A}\equiv A+A\times A\Rightarrow1+Z$ is a filterable
contrafunctor
\end{enumerate}
\end{frame}

\begin{frame}{Filterable functors: The laws in depth I}

Is there a shorter formulation of the laws that is easier to remember?
\begin{itemize}
\item Intuition: When \texttt{\textcolor{blue}{\footnotesize{}p(x) = false}},
replace \texttt{\textcolor{blue}{\footnotesize{}x:\ A}} by \texttt{\textcolor{blue}{\footnotesize{}1:\ Unit}}
in \texttt{\textcolor{blue}{\footnotesize{}F{[}A{]}}} 
\begin{itemize}
\item (1) How to replace \texttt{\textcolor{blue}{\footnotesize{}x}} by
\texttt{\textcolor{blue}{\footnotesize{}1}} in \texttt{\textcolor{blue}{\footnotesize{}F{[}A{]}}}
without breaking the types?
\item (2) How to transform the resulting type back to \texttt{\textcolor{blue}{\footnotesize{}F{[}A{]}}}?
\end{itemize}
\item We could do (1) if instead of $F^{A}$ we had $F^{1+A}$ i.e.~\texttt{\textcolor{blue}{\footnotesize{}F{[}Option{[}A{]}{]}}} 
\begin{itemize}
\item Now use \texttt{\textcolor{blue}{\footnotesize{}filter}} to replace
$A$ by $1$ in each item of type $1+A$
\item Get $F^{1+A}$ from $F^{A}$ using $\text{inflate}:F^{A}\Rightarrow F^{1+A}=\text{fmap}\,(\text{Some}^{A\Rightarrow1+A})$ 
\item Filter $F^{1+A}\Rightarrow F^{1+A}$ using $\text{fmap}\left(x^{1+A}\Rightarrow\text{filter}_{\text{Opt}}(p^{A\Rightarrow\text{Boolean}})(x)\right)$
\end{itemize}
\[
\text{filter}\,p:\xymatrix{\xyScaleX{5pc}F^{A}\ar[r]\sb(0.45){\text{inflate}} & F^{1+A}\ar[r]_{\text{fmap}\left(\text{filter}_{\text{Opt}}p\right)} & F^{1+A}\ar[r]\sb(0.55){\text{deflate}} & F^{A}}
\]

\item Doing (2) means \emph{defining} a function \texttt{\textcolor{blue}{\footnotesize{}deflate:\ F{[}Option{[}A{]}{]}
$\Rightarrow$ F{[}A{]}}} 
\begin{itemize}
\item standard library already has \texttt{\textcolor{blue}{\footnotesize{}flatten{[}T{]}:\ Seq{[}Option{[}T{]}{]}
$\Rightarrow$ Seq{[}T{]}}} 
\end{itemize}
\item Simplify{\footnotesize{} $\text{fmap}(\text{Some}^{A\Rightarrow1+A})\circ\text{fmap}\left(\text{filter}_{\text{Opt}}p\right)=\text{fmap}\left(\text{bop}\left(p\right)\right)$}
where we defined {\footnotesize{}$\text{{\color{blue}bop}}\left(p\right):\left(A\Rightarrow1+A\right)\equiv$}
\texttt{\textcolor{blue}{\footnotesize{}x $\Rightarrow$ Some(x).filter(p)}} 
\item In this way, express \texttt{\textcolor{blue}{\footnotesize{}filter}}
through \texttt{\textcolor{blue}{\footnotesize{}deflate}} (see example
code)
\begin{itemize}
\item $\text{filter}\,p=\text{fmap}\left(\text{bop}\,p\right)\circ\text{deflate}$.
\textendash{} Notation: $\text{bop}\,p$ is $\text{bop}\left(p\right)$,
like $\cos x$
\end{itemize}
\[
\text{filter}\:p:\xymatrix{\xyScaleX{5pc}F^{A}\ar[r]\sb(0.45){\text{fmap}\left(\text{bop}\,p\right)} & F^{1+A}\ar[r]\sb(0.55){\text{deflate}} & F^{A}}
\]

\end{itemize}
\end{frame}

\begin{frame}{Filterable functors: Using \texttt{\textcolor{blue}{\footnotesize{}deflate}}}

\begin{itemize}
\item So far we have expressed \texttt{\textcolor{blue}{\footnotesize{}filter}}
through \texttt{\textcolor{blue}{\footnotesize{}deflate}} 
\item We can also express \texttt{\textcolor{blue}{\footnotesize{}deflate}}
through \texttt{\textcolor{blue}{\footnotesize{}filter}} (assuming
law 4 holds):

\[
\text{deflate}:\xymatrix{\xyScaleX{5pc}F^{1+A}\ar[r]\sb(0.5){\text{filter}\left(\text{.nonEmpty}\right)} & F^{1+A}\ar[r]\sb(0.5){\text{fmap}\left(\text{.get}\right)} & F^{A}}
\]

\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~deflate{[}F{[}\_{]},A{]}(foa:~F{[}Option{[}A{]}{]}):~F{[}A{]}~=}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~foa.filter(\_.nonEmpty).map(\_.get)~}\textrm{\textcolor{gray}{\footnotesize{}//~}}\textcolor{gray}{\footnotesize{}\_.get}\textrm{\textcolor{gray}{\footnotesize{}~is~$0+x^{A}\Rightarrow x^{A}$}}{\footnotesize \par}

\textrm{\textcolor{gray}{\footnotesize{}//~for~}}\textcolor{gray}{\footnotesize{}F~=~Seq}\textrm{\textcolor{gray}{\footnotesize{},~this~would~be~}}\textcolor{gray}{\footnotesize{}foa.collect~\{~case~Some(x)~$\Rightarrow$~x~\}}{\footnotesize \par}

\textrm{\textcolor{gray}{\footnotesize{}//~for~arbitrary~functor~}}\textcolor{gray}{\footnotesize{}F}\textrm{\textcolor{gray}{\footnotesize{}~we~need~to~use~the~partial~function,~}}\textcolor{gray}{\footnotesize{}\_.get}{\footnotesize \par}
\end{lyxcode}
\item This means \texttt{\textcolor{blue}{\footnotesize{}deflate}} and \texttt{\textcolor{blue}{\footnotesize{}filter}}
are \textbf{computationally equivalent}
\begin{itemize}
\item We could specify filterable functors by implementing \texttt{\textcolor{blue}{\footnotesize{}deflate}} 
\begin{itemize}
\item The implementation of \texttt{\textcolor{blue}{\footnotesize{}filter}}
would then be derived by library
\end{itemize}
\end{itemize}
\item Use \texttt{\textcolor{blue}{\footnotesize{}deflate}} to verify that
some functors are certainly not filterable:
\begin{itemize}
\item $F^{A}=A+A\times A$. Write $F^{1+A}=1+A+(1+A)\times(1+A)$ 
\begin{itemize}
\item cannot map $F^{1+A}\Rightarrow F^{A}$ because we do not have $1\rightarrow A$
\end{itemize}
\item $F^{A}=\text{Int}\Rightarrow A$. Write $F^{1+A}=\text{Int}\Rightarrow1+A$ 
\begin{itemize}
\item type signature of \texttt{\textcolor{blue}{\footnotesize{}deflate}}
would be $\left(\text{Int}\Rightarrow1+A\right)\Rightarrow\text{Int}\Rightarrow A$
\item cannot map $F^{1+A}\Rightarrow F^{A}$ because we do not have $1+A\rightarrow A$
\end{itemize}
\end{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}deflate}} is easier to implement
and to reason about
\end{itemize}
\end{frame}

\begin{frame}{{*} Filterable functors: The laws in depth II}

\begin{itemize}
\item We were able to define \texttt{\textcolor{blue}{\footnotesize{}deflate}}
only by assuming that law 4 holds
\item Now, law 4 is satisfied \emph{automatically} if \texttt{\textcolor{blue}{\footnotesize{}filter}}
is defined via \texttt{\textcolor{blue}{\footnotesize{}deflate}}!
\begin{itemize}
\item Denote {\footnotesize{}$\psi_{p}^{F^{A}\Rightarrow F^{1+A}}\equiv\text{fmap}\left(\text{bop}\:p\right)$
for brevity, then $\text{filter}\,p=\psi_{p}\circ\text{deflate}$}{\footnotesize \par}
\item Law 4 then becomes: {\footnotesize{}$\psi_{p}\circ\text{deflate}\circ\text{fmap}\:f^{A\Rightarrow B}=\psi_{p}\circ\text{deflate}\circ\text{fmap}\:f_{|p}$
\[
\xymatrix{\xyScaleY{0.1pc}\xyScaleX{3pc} & F^{1+A}\ar[r]\sp(0.5){\text{deflate}} & F^{A}\ar[rd]\sp(0.5){\text{ fmap}\:f^{A\Rightarrow B}}\\
F^{A}\ar[ru]\sp(0.5){\psi_{p}}\ar[rd]\sb(0.5){\psi_{p}} &  &  & F^{B}\\
 & F^{1+A}\ar[r]\sb(0.5){\text{deflate}} & F^{A}\ar[ru]\sb(0.5){\text{fmap}\:f_{|p}^{A\Rightarrow B}}
}
\]
}{\footnotesize \par}
\end{itemize}
\item We would like to interchange \texttt{\textcolor{blue}{\footnotesize{}deflate}}
and \texttt{\textcolor{blue}{\footnotesize{}fmap}} in both sides
\begin{itemize}
\item We need a \emph{naturality} law; let's express law 1 through \texttt{\textcolor{blue}{\footnotesize{}deflate}}:
\end{itemize}
\end{itemize}
{\footnotesize{}
\[
\text{fmap}\:f^{A\Rightarrow B}\circ\psi_{p}\circ\text{deflate}^{F,B}=\psi_{f\circ p}\circ\text{deflate}^{F,A}\circ\text{fmap}\:f^{A\Rightarrow B}
\]
\[
\xymatrix{\xyScaleY{0.1pc}\xyScaleX{3pc} & F^{B}\ar[r]\sp(0.5){\psi_{p}} & F^{1+B}\ar[rd]\sp(0.5){\text{ deflate}^{F,B}}\\
F^{A}\ar[ru]\sp(0.5){\text{fmap}\:f^{A\Rightarrow B}}\ar[rd]\sb(0.5){\psi_{f\circ p}} &  &  & F^{B}\\
 & F^{1+A}\ar[r]\sb(0.5){\text{deflate}^{F,A}} & F^{A}\ar[ru]\sb(0.5){\text{fmap}\:f^{A\Rightarrow B}}
}
\]
Can we simplify $\text{fmap}\:f\circ\psi_{p}=\text{fmap}\:f\circ\text{fmap}\left(\text{bop}\,p\right)=\text{fmap}\left(f\circ\text{bop}\,p\right)$?}{\footnotesize \par}
\end{frame}

\begin{frame}{{*} Filterable functors: The laws in depth III}

\begin{itemize}
\item {\footnotesize{}Have property: $f^{A\Rightarrow B}\circ\text{bop}\left(p^{B\Rightarrow\text{Boolean}}\right)=\text{bop}\left(f\circ p\right)\circ\text{fmap}^{\text{Opt}}\,f$
(see code)
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & B\ar[rd]\sp(0.5){\text{bop}\,p}\\
A\ar[ru]\sp(0.5){f^{A\Rightarrow B}}\ar[rd]\sb(0.4){\text{bop}\left(f\circ p\right)\,} &  & 1+B\\
 & 1+A\ar[ru]\sb(0.6){\text{fmap}^{\text{Opt}}f}
}
\]
We can now rewrite Law 1 as
\[
\text{fmap}\,(\text{bop}\left(f\circ p\right))\circ\text{fmap}\,(\text{fmap}^{\text{Opt}}f)\circ\text{deflate}=\text{fmap}\left(\text{bop}\left(f\circ p\right)\right)\circ\text{deflate}\circ\text{fmap}\,f
\]
Remove common prefix $\text{fmap}\left(\text{bop}\left(f\circ p\right)\right)\circ...$
from both sides:
\[
\text{fmap}\,(\text{fmap}^{\text{Opt}}f^{A\Rightarrow B})\circ\text{deflate}^{F,B}=\text{deflate}^{F,A}\circ\text{fmap}\,f^{A\Rightarrow B}\ \ -\text{ \textbf{law 1 for deflate}}
\]
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{1+B}\ar[rd]\sp(0.5){\ \text{deflate}^{F,B}}\\
F^{1+A}\ar[ru]\sp(0.5){\text{fmap}\,(\text{fmap}\,f)\ }\ar[rd]\sb(0.5){\text{deflate}^{F,A}\,} &  & F^{B}\\
 & F^{A}\ar[ru]\sb(0.5){\text{fmap\,}f^{A\Rightarrow B}}
}
\]
}{\footnotesize \par}
\item \texttt{\textcolor{blue}{\footnotesize{}deflate}}{\footnotesize{}$:F^{1+A}\Rightarrow F^{A}$}
 is a \textbf{natural transformation} (has naturality law)
\begin{itemize}
\item Example:{\footnotesize{} $F^{A}=1+A\times A$}{\footnotesize \par}
\item {\footnotesize{}$F^{1+A}=1+(1+A)\times(1+A)=1+1\times1+A\times1+1\times A+A\times A$}{\footnotesize \par}
\end{itemize}
\item {\footnotesize{}natural transformations map containers $G^{A}\Rightarrow H^{A}$
by rearranging data in them}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{{*} Filterable functors: The laws in depth IV}

\begin{itemize}
\item The naturality law for \texttt{\textcolor{blue}{\footnotesize{}deflate}}:{\footnotesize{}
\[
\text{fmap}\,(\text{fmap}^{\text{Opt}}f^{A\Rightarrow B})\circ\text{deflate}^{F,B}=\text{deflate}^{F,A}\circ\text{fmap}\,f^{A\Rightarrow B}
\]
}Law 4 expressed via \texttt{\textcolor{blue}{\footnotesize{}deflate}}:{\footnotesize{}
\[
\xymatrix{\xyScaleY{0.1pc}\xyScaleX{3pc} & F^{1+A}\ar[r]\sp(0.5){\text{deflate}} & F^{A}\ar[rd]\sp(0.5){\text{ fmap}\:f^{A\Rightarrow B}}\\
F^{A}\ar[ru]\sp(0.5){\psi_{p}}\ar[rd]\sb(0.5){\psi_{p}} &  &  & F^{B}\\
 & F^{1+A}\ar[r]\sb(0.5){\text{deflate}} & F^{A}\ar[ru]\sb(0.5){\text{fmap}\:f_{|p}^{A\Rightarrow B}}
}
\]
\[
\psi_{p}\circ\text{deflate}^{F,A}\circ\text{fmap}\:f^{A\Rightarrow B}=\psi_{p}\circ\text{deflate}^{F,A}\circ\text{fmap}\:f_{|p}
\]
}{\footnotesize \par}
\item Use naturality to interchange \texttt{\textcolor{blue}{\footnotesize{}deflate}}
and \texttt{\textcolor{blue}{\footnotesize{}fmap}} in both sides of
law 4:{\footnotesize{}
\begin{align*}
\psi_{p}\circ\text{fmap}\,(\text{fmap}^{\text{Opt}}f)\circ\text{deflate}^{F,B} & =\psi_{p}\circ\text{fmap}\,(\text{fmap}^{\text{Opt}}f_{|p})\circ\text{deflate}^{F,B}\\
\text{[omit }\text{deflate}^{F,B}\text{ from} & \ \text{both sides; expand }\psi_{p}\text{]}\\
\text{bop}\,p\circ\text{fmap}^{\text{Opt}}f & =\text{bop}\,p\circ\text{fmap}^{\text{Opt}}f_{|p}\ \ -\text{ check this by hand:}
\end{align*}
}{\footnotesize \par}
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}x~$\Rightarrow$~Some(x).filter(p).map(f)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}x~$\Rightarrow$~Some(x).filter(p).map~\{~x~if~p(x)~$\Rightarrow$).map~\{~x~if~p(x)~$\Rightarrow$~f(x)~\}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item These functions are equivalent because law 4 holds for \texttt{\textcolor{blue}{\footnotesize{}Option}}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Filterable functors: The laws in depth V}

Maybe $\psi_{p}\circ\text{deflate}$ is easier to handle than \texttt{\textcolor{blue}{\footnotesize{}deflate}}?
Let us define {\footnotesize{}
\[
\text{{\color{blue}fmapOpt}}^{F,A,B}(f^{A\Rightarrow1+B}):F^{A}\Rightarrow F^{B}=\text{fmap}\:f\circ\text{deflate}^{F,B}
\]
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{1+B}\ar[rd]\sp(0.5){\ \text{deflate}^{F,B}}\\
F^{A}\ar[ru]\sp(0.5){\text{fmap}\,f^{A\Rightarrow1+B}\ }\ar[rr]\sb(0.5){\text{fmapOpt}\:f^{A\Rightarrow1+B}\,} &  & F^{B}
}
\]
}{\footnotesize \par}
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}fmapOpt}} and \texttt{\textcolor{blue}{\footnotesize{}deflate}}
are \emph{equivalent}: {\footnotesize{}$\text{deflate}^{F,A}=\text{fmapOpt}^{F,1+A,A}(\text{id}^{1+A\Rightarrow1+A})$ }{\footnotesize \par}
\item Express laws 1 \textendash{} 3 in terms of \texttt{\textcolor{blue}{\footnotesize{}fmapOpt}}:
do they get simpler?
\begin{itemize}
\item Express \texttt{\textcolor{blue}{\footnotesize{}filter}} through \texttt{\textcolor{blue}{\footnotesize{}fmapOpt}}:
{\footnotesize{}$\text{filter}\,p=\text{fmapOpt}^{F,A,A}\left(\text{bop}\,p\right)$}{\footnotesize \par}
\item Consider the expression needed for law 2: $x\Rightarrow p_{1}(x)\wedge p_{2}(x)$
\item {\footnotesize{}$\text{bop}\left(x\Rightarrow p_{1}(x)\wedge p_{2}(x)\right)=x^{A}\Rightarrow\left(\text{bop}\,p_{1}\right)(x)\text{.flatMap}\left(\text{bop}\,p_{2}\right)$
}\textendash{} see code
\begin{itemize}
\item Denote this computation by $\diamond_{\text{Opt}}$ and write{\footnotesize{}
\[
q_{1}^{A\Rightarrow1+B}\diamond_{\text{Opt}}q_{2}^{B\Rightarrow1+C}\equiv x^{A}\Rightarrow q_{1}(x).\text{flatMap}\left(q_{2}\right)
\]
}{\footnotesize \par}
\end{itemize}
\item Similar to composition of functions, except the types are $A\Rightarrow1+B$
\begin{itemize}
\item This is a particular case of \textbf{Kleisli composition}; the general
case: {\footnotesize{}$\diamond_{M}:(A\Rightarrow M^{B})\Rightarrow(B\Rightarrow M^{C})\Rightarrow(A\Rightarrow M^{C})$};
we set $M^{A}\equiv1+A$
\item The \textbf{Kleisli identity} function: $\text{id}_{\diamond_{\text{Opt}}}^{A\Rightarrow1+A}\equiv x^{A}\Rightarrow\text{Some}\left(x\right)$
\item Kleisli composition $\diamond_{\text{Opt}}$ is associative and respects
the Kleisli identity!
\item \texttt{\textcolor{blue}{\footnotesize{}fmapOpt}} lifts a Kleisli$_{\text{Opt}}$
function $f^{A\Rightarrow1+B}$ into the functor $F$
\end{itemize}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Filterable functors: The laws in depth VI}


\framesubtitle{Simplifying down to two laws}
\begin{itemize}
\item Only \emph{two} laws are necessary for \texttt{\textcolor{blue}{\footnotesize{}fmapOpt}}!
\end{itemize}
\begin{enumerate}
\item \textbf{Identity law} (covers old law 3): {\footnotesize{}
\[
\text{fmapOpt}\,(\text{id}_{\diamond_{\text{Opt}}}^{A\Rightarrow1+A})=\text{id}^{F^{A}\Rightarrow F^{A}}
\]
}{\footnotesize \par}
\item \textbf{Composition law} (covers old laws 1 and 2): {\footnotesize{}
\[
\text{fmapOpt}\,(f^{A\Rightarrow1+B})\circ\text{fmapOpt}\,(g^{B\Rightarrow1+C})=\text{fmapOpt}\left(f\diamond_{\text{\textbf{Opt}}}g\right)
\]
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc} & F^{B}\ar[rd]\sp(0.55){\ \text{fmapOpt}\,(g^{B\Rightarrow1+C})}\\
F^{A}\ar[ru]\sp(0.45){\text{fmapOpt}\,(f^{A\Rightarrow1+B})\ }\ar[rr]\sb(0.5){\text{fmapOpt}\left(f\diamond_{\text{Opt}}g\right)} &  & F^{C}
}
\]
}{\footnotesize \par}
\end{enumerate}
\begin{itemize}
\item The two laws for \texttt{\textcolor{blue}{\footnotesize{}fmapOpt}}
are very similar to the two functor laws
\begin{itemize}
\item Both of them use more complicated types than the old laws
\item Conceptually, the new laws are simpler (lift $f^{A\Rightarrow1+B}$
into $F^{A}\Rightarrow F^{B}$)
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{{*} Filterable functors: The laws in depth VII}


\framesubtitle{Showing that old laws 1 \textendash{} 3 follow from the identity
and composition laws for \texttt{\footnotesize{}fmapOpt}}
\begin{itemize}
\item Old law 3 is \emph{equivalent} to the identity law for \texttt{\textcolor{blue}{\footnotesize{}fmapOpt}}:{\footnotesize{}
\[
\text{filter}\,(x^{A}\Rightarrow\text{true})=\text{fmap}\,(x^{A}\Rightarrow0+x)\circ\text{deflate}=\text{fmapOpt}\,(\text{id}_{\diamond_{\text{Opt}}})=\text{id}^{F^{A}\Rightarrow F^{A}}
\]
}{\footnotesize \par}
\item Derive old law 2: need to work with{\footnotesize{} $q_{1,2}\equiv\text{bop}\left(p_{1,2}\right):A\Rightarrow1+A$ }{\footnotesize \par}
\begin{itemize}
\item The Boolean conjunction {\footnotesize{}$x\Rightarrow p_{1}(x)\wedge p_{2}(x)$
}corresponds to {\footnotesize{}$q_{1}\diamond_{\text{\textbf{Opt}}}q_{2}$}{\footnotesize \par}
\item Apply the composition law to Kleisli functions of types {\footnotesize{}$A\Rightarrow1+A$
}:{\footnotesize{}
\begin{align*}
\text{filter}\,p_{1}\circ\text{filter}\,p_{2} & =\text{fmapOpt}\,q_{1}\circ\text{fmapOpt}\,q_{2}\\
=\text{fmapOpt}\left(q_{1}\diamond_{\text{\textbf{Opt}}}q_{2}\right) & =\text{fmapOpt}\left(\text{bop}\left(x\Rightarrow p_{1}(x)\wedge p_{2}(x)\right)\right)
\end{align*}
}{\footnotesize \par}
\end{itemize}
\item Derive old law 1:
\begin{itemize}
\item express \texttt{\textcolor{blue}{\footnotesize{}filter}} through \texttt{\textcolor{blue}{\footnotesize{}fmapOpt}};
old law 1 becomes{\footnotesize{}
\[
\text{fmap}\:f\circ\text{fmapOpt}\left(\text{bop}\,p\right)=\text{fmapOpt}\left(\text{bop}\left(f\circ p\right)\right)\circ\text{fmap}\:f\ \text{ \textendash\ eq. (*)}
\]
}{\footnotesize \par}
\item lift $f^{A\Rightarrow B}$ to Kleisli$_{\text{Opt}}$ by defining
{\footnotesize{}$k_{f}^{A\Rightarrow1+B}=f\circ\text{id}_{\diamond_{\text{\textbf{Opt}}}}$;}
then we have $\text{fmapOpt}\left(k_{f}\right)=\text{fmap}\,k_{f}\circ\text{deflate}=\text{fmap}\:f\circ\text{fmap}\,\text{id}_{\diamond_{\text{\textbf{Opt}}}}\circ\text{deflate}=\text{fmap}\,f$
\item rewrite eq.\ ({*}) as {\footnotesize{}$\text{fmapOpt}\left(k_{f}\diamond_{\text{\textbf{Opt}}}\text{bop}\,p\right)=\text{fmapOpt}\left(\text{bop}\left(f\circ p\right)\diamond_{\text{\textbf{Opt}}}k_{f}\right)$ }{\footnotesize \par}
\item it remains to show that {\footnotesize{}$k_{f}\diamond_{\text{\textbf{Opt}}}\text{bop}\,p=\text{bop}\left(f\circ p\right)\diamond_{\text{\textbf{Opt}}}k_{f}$ }{\footnotesize \par}
\item use the properties {\footnotesize{}$k_{f}\diamond_{\text{\textbf{Opt}}}q=f\circ q$
and $q\diamond_{\text{\textbf{Opt}}}k_{f}=q\circ\text{fmap}^{\text{Opt}}f$,
and $f\circ\text{bop}\,p=\text{bop}\left(f\circ p\right)\circ\text{fmap}^{\text{Opt}}\,f$
(property from slide 11)}{\footnotesize \par}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Summary: The methods and the laws}

Filterable functors can be defined via \texttt{\textcolor{blue}{\footnotesize{}filter}},
\texttt{\textcolor{blue}{\footnotesize{}deflate}}, or \texttt{\textcolor{blue}{\footnotesize{}fmapOpt}} 
\begin{itemize}
\item All three methods are \emph{equivalent} but have different roles:
\begin{itemize}
\item The easiest to use in program code is \texttt{\textcolor{blue}{\footnotesize{}filter}}
/ \texttt{\textcolor{blue}{\footnotesize{}withFilter}} 
\item The easiest type signature to implement and reason about is \texttt{\textcolor{blue}{\footnotesize{}deflate}} 
\item Conceptually, the laws are easiest to remember with \texttt{\textcolor{blue}{\footnotesize{}fmapOpt}} 
\end{itemize}
\item {*} The 2 laws for \texttt{\textcolor{blue}{\footnotesize{}fmapOpt}}
are the 2 functor laws with a Kleisli ``twist''
\item {*} Category theory accommodates this via a generalized definition
of functors as liftings between ``twisted'' types. Compare:
\begin{itemize}
\item $\text{fmap}:\left(A\Rightarrow B\right)\Rightarrow F^{A}\Rightarrow F^{B}$
\textendash{} ordinary container (``endofunctor'')
\item $\text{contrafmap}:\left(B\Rightarrow A\right)\Rightarrow F^{A}\Rightarrow F^{B}$
\textendash{} lifting from reversed functions
\item $\text{fmapOpt}:\left(A\Rightarrow1+B\right)\Rightarrow F^{A}\Rightarrow F^{B}$
\textendash{} lifting from Kleisli$_{\text{Opt}}$-functions 
\end{itemize}
\item CT gives us some \emph{intuitions} about how to derive better laws:
\begin{itemize}
\item look for type signatures that resemble a generalized sort of ``lifting''
\item look for natural transformations and use the naturality law
\end{itemize}
\item However, CT does not directly provide any derivations for the laws
\begin{itemize}
\item you will not find the laws for \texttt{\textcolor{blue}{\footnotesize{}filter}}
or \texttt{\textcolor{blue}{\footnotesize{}deflate}} in any CT book
\item CT is abstract, only gives hints about possible further directions
\begin{itemize}
\item investigate functors having ``liftings'' with different type signatures
\item replace \texttt{\textcolor{blue}{\footnotesize{}Option}} in the Kleisli$_{\text{Opt}}$
construction by another functor
\end{itemize}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Structure of filterable functors}


\framesubtitle{How to recognize a filterable functor by its type?}

Intuition from \texttt{\textcolor{blue}{\footnotesize{}deflate}}:
reshuffle data in $F^{A}$ after replacing some $A$'s by $1$
\begin{itemize}
\item ``reshuffling'' usually means reusing different parts of a disjunction
\end{itemize}
Some constructions of exponential-polynomial filterable functors 
\begin{enumerate}
\item $F^{A}=Z$ (constant functor) for a fixed type $Z$ (define $\text{fmapOpt}\,f=\text{id}$)
\begin{itemize}
\item Note: $F^{A}=A$ (identity functor) is \emph{not} filterable
\end{itemize}
\item $F^{A}\equiv G^{A}\times H^{A}$ for any filterable functors $G^{A}$
and $H^{A}$
\item $F^{A}\equiv G^{A}+H^{A}$ for any filterable functors $G^{A}$ and
$H^{A}$
\item $F^{A}\equiv G^{H^{A}}$ for \emph{any} functor $G^{A}$ and filterable
functor $H^{A}$
\item $F^{A}\equiv1+A\times G^{A}$ for a filterable functor $G^{A}$
\begin{itemize}
\item Note: \emph{pointed} types $P$ are isomorphic to $1+Z$ for some
type $Z$
\begin{itemize}
\item Example of non-trivial pointed type: $A\Rightarrow A$
\item Example of non-pointed type: $A\Rightarrow B$ when $A$ is different
from $B$
\end{itemize}
\item So $F^{A}\equiv P+A\times G^{A}$ where $P$ is a pointed type and
$G^{A}$ is filterable
\item Also have $F^{A}\equiv P+A\times A\times...\times A\times G^{A}$
similarly
\end{itemize}
\item $F^{A}\equiv G^{A}+A\times F^{A}$ (recursive) for a filterable functor
$G^{A}$
\item $F^{A}\equiv G^{A}\Rightarrow H^{A}$ if\emph{ }contrafunctor $G^{A}$
and functor $H^{A}$ \emph{both} \emph{filterable}
\begin{itemize}
\item Note: the functor $F^{A}\equiv G^{A}\Rightarrow A$ is not filterable
\end{itemize}
\end{enumerate}
\end{frame}

\begin{frame}{{*} Worked examples II: Constructions of filterable functors I}

(2) The \texttt{\textcolor{blue}{\footnotesize{}fmapOpt}} laws hold
for $F^{A}\times G^{A}$ if they hold for $F^{A}$ and $G^{A}$
\begin{itemize}
\item For $f^{A\Rightarrow1+B}$, get {\footnotesize{}$\text{fmapOpt}_{F}(f):F^{A}\Rightarrow F^{B}$
}and {\footnotesize{}$\text{fmapOpt}_{G}(f):G^{A}\Rightarrow G^{B}$}{\footnotesize \par}
\item Define {\footnotesize{}$\text{fmapOpt}_{F\times G}f\equiv p^{F^{A}}\times q^{G^{A}}\Rightarrow\text{fmapOpt}_{F}(f)(p)\times\text{fmapOpt}_{G}(f)(q)$}{\footnotesize \par}
\item Identity law: $f=\text{id}_{\diamond_{\text{Opt}}}$, so {\footnotesize{}$\text{fmapOpt}_{F}f=\text{id}$}
and {\footnotesize{}$\text{fmapOpt}_{G}f=\text{id}$}{\footnotesize \par}
\begin{itemize}
\item Hence we get $\text{fmapOpt}_{F+G}(f)(p\times q)=\text{id}(p)\times\text{id}(q)=p\times q$
\end{itemize}
\item Composition law:{\footnotesize{}
\begin{align*}
 & (\text{fmapOpt}_{F\times G}\,f_{1}\circ\text{fmapOpt}_{F+G}\,f_{2})(p\times q)\\
=\  & \text{fmapOpt}_{F\times G}(f_{2})\left(\text{fmapOpt}_{F}(f_{1})(p)\times\text{fmapOpt}_{G}(f_{1})(q)\right)\\
=\  & (\text{fmapOpt}_{F}\,f_{1}\circ\text{fmapOpt}_{F}\,f_{2})(p)\times\left(\text{fmapOpt}_{G}\,f_{1}\circ\text{fmapOpt}_{G}\,f_{2}\right)(q)\\
=\  & \text{fmapOpt}_{F}(f_{1}\diamond_{\text{Opt}}f_{2})(p)\times\text{fmapOpt}_{G}(f_{1}\diamond f_{2})(q)\\
=\  & \text{fmapOpt}_{F\times G}(f_{1}\diamond_{\text{Opt}}f_{2})(p\times q)
\end{align*}
}{\footnotesize \par}
\item Exactly the same proof as that for functor property for $F^{A}\times G^{A}$
\begin{itemize}
\item this is because \texttt{\textcolor{blue}{\footnotesize{}fmapOpt}}
corresponds to a generalized functor
\end{itemize}
\item New proofs are necessary only when using non-filterable functors
\begin{itemize}
\item these are used in constructions 4 \textendash{} 6
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{{*} Worked examples II: Constructions of filterable functors II}

(5) The \texttt{\textcolor{blue}{\footnotesize{}fmapOpt}} laws hold
for $F^{A}\equiv1+A\times G^{A}$ if they hold for $G^{A}$
\begin{itemize}
\item For $f^{A\Rightarrow1+B}$, get {\footnotesize{}$\text{fmapOpt}_{G}(f):G^{A}\Rightarrow G^{B}$}{\footnotesize \par}
\item {\footnotesize{}Define $\text{fmapOpt}_{F}(f)(1+a^{A}\times q^{G^{A}})$
by returning $0+b\times\text{fmapOpt}_{G}(f)(q)$ if the argument
is $0+a\times q$ and $f(a)=0+b$, and returning $1+0$ otherwise}{\footnotesize \par}
\item Identity law: {\footnotesize{}$f=\text{id}_{\diamond_{\text{Opt}}}$,
so $f(a)=0+a$ and $\text{fmapOpt}_{G}f=\text{id}$}{\footnotesize \par}
\begin{itemize}
\item Hence we get{\footnotesize{} $\text{fmapOpt}_{F}(\text{id}_{\diamond_{\text{Opt}}})(1+a\times q)=1+a\times q$}{\footnotesize \par}
\end{itemize}
\item Composition law: {\footnotesize{}need only to check for arguments
$0+a\times q$, and only when $f_{1}(a)=0+b$ and $f_{2}(b)=0+c$,
in which case $(f_{1}\diamond_{\text{Opt}}f_{2})(a)=0+c$; then 
\begin{align*}
 & (\text{fmapOpt}_{F}\,f_{1}\circ\text{fmapOpt}_{F}\,f_{2})(0+a\times q)\\
=\  & \text{fmapOpt}_{F}(f_{2})\left(\text{fmapOpt}_{F}(f_{1})(0+a\times q)\right)\\
=\  & \text{fmapOpt}_{F}(f_{2})\left(0+b\times\text{fmapOpt}_{G}(f_{1})(q)\right)\\
=\  & 0+c\times(\text{fmapOpt}_{G}\,f_{1}\circ\text{fmapOpt}_{G}\,f_{2})(q)\\
=\  & 0+c\times\text{fmapOpt}_{G}(f_{1}\diamond_{\text{Opt}}f_{2})(q)\\
=\  & \text{fmapOpt}_{F}(f_{1}\diamond_{\text{Opt}}f_{2})(0+a\times q)
\end{align*}
}{\footnotesize \par}
\end{itemize}
This is a ``greedy filter'': if $f(a)$ is empty, will delete all
data in $G^{A}$
\end{frame}

\begin{frame}{{*} Worked examples II: Constructions of filterable functors III}

(6) The \texttt{\textcolor{blue}{\footnotesize{}fmapOpt}} laws hold
for $F^{A}\equiv G^{A}+A\times F^{A}$ if they hold for $G^{A}$
\begin{itemize}
\item {\footnotesize{}For $f^{A\Rightarrow1+B}$, we have $\text{fmapOpt}_{G}(f):G^{A}\Rightarrow G^{B}$
and $\text{fmapOpt}_{F}^{\prime}(f):F^{A}\Rightarrow F^{B}$ (for
use in recursive arguments as the inductive assumption)}{\footnotesize \par}
\item {\footnotesize{}Define $\text{fmapOpt}_{F}(f)(q^{G^{A}}+a^{A}\times p^{F^{A}})$
by returning $0+\text{fmapOpt}_{F}^{\prime}(f)(p)$ if $f(a)=1+0$,
and $\text{fmapOpt}_{G}(f)(q)+b\times\text{fmapOpt}_{F}^{\prime}(f)(p)$
otherwise}{\footnotesize \par}
\item Identity law: {\footnotesize{}$\text{id}_{\diamond_{\text{Opt}}}(x)\neq1+0$},
so {\footnotesize{}$\text{fmapOpt}_{F}(\text{id}_{\diamond_{\text{Opt}}})(q+a\times p)=q+a\times p$ }{\footnotesize \par}
\item Composition law: {\footnotesize{}$(\text{fmapOpt}_{F}(f_{1})\circ\text{fmapOpt}_{F}(f_{2}))(q+a\times p)=\text{fmapOpt}_{F}(f_{1}\diamond_{\text{Opt}}f_{2})(q+a\times p)$}{\footnotesize \par}
\item {\footnotesize{}For arguments $q+0$, the laws for $G^{A}$ hold;
so assume arguments $0+a\times p$. When $f_{1}(a)=0+b$ and $f_{2}(b)=0+c$,
the proof of the previous example will go through. So we need to consider
the two cases $f_{1}(a)=1+0$ and $f_{1}(a)=0+b$, $f_{2}(b)=1+0$ }{\footnotesize \par}
\item {\footnotesize{}If $f_{1}(a)=1+0$ then $(f_{1}\diamond_{\text{Opt}}f_{2})(a)=1+0$;
to show $\text{fmapOpt}_{F}^{\prime}(f_{2})(\text{fmapOpt}_{F}^{\prime}(f_{1})(p))$
$=\text{fmapOpt}_{F}^{\prime}(f_{1}\diamond_{\text{Opt}}f_{2})(p)$,
use the inductive assumption about $\text{fmapOpt}_{F}^{\prime}$
on $p$}{\footnotesize \par}
\item {\footnotesize{}If $f_{1}(a)=0+b$ and $f_{2}(b)=1+0$ then $(f_{1}\diamond_{\text{Opt}}f_{2})(a)=1+0$;
to show $\text{fmapOpt}_{F}(f_{2})(0+b\times\text{fmapOpt}_{F}^{\prime}(f_{1})(p))$
$=\text{fmapOpt}_{F}^{\prime}(f_{1}\diamond_{\text{Opt}}f_{2})(p)$,
rewrite $\text{fmapOpt}_{F}(f_{2})(0+b\times\text{fmapOpt}_{F}^{\prime}(f_{1})(p))$
$=\text{fmapOpt}_{F}^{\prime}(f_{2})(\text{fmapOpt}_{F}^{\prime}(f_{1})(p))$
and again use the inductive assumption about $\text{fmapOpt}_{F}^{\prime}$
on $p$}{\footnotesize \par}
\end{itemize}
This is a ``list-like filter'': if $f(a)$ is empty, will recurse
into nested $F^{A}$ data
\end{frame}

\begin{frame}{Worked examples II: Constructions of filterable functors IV}

Use known filterable constructions to show that{\footnotesize{} $F^{A}\equiv(\text{Int}\times\text{String})\Rightarrow\left(1+\text{Int}\times A+A\times\left(1+A\right)+\left(\text{Int}\Rightarrow1+A+A\times A\times\text{String}\right)\right)$
}is a filterable functor
\begin{itemize}
\item Instead of implementing \texttt{\textcolor{blue}{\footnotesize{}Filterable}}
and verifying laws by hand, we analyze the structure of this data
type and use known constructions
\item Define some auxiliary functors that are parts of the structure of
$F^{A}$,
\begin{itemize}
\item $R_{1}^{A}=\left(\text{Int}\times\text{String}\right)\Rightarrow A$
and $R_{2}^{A}=\text{Int}\Rightarrow A$ 
\item $G^{A}=1+\text{Int}\times A+A\times\left(1+A\right)$ and $H^{A}=1+A+A\times A\times\text{String}$
\end{itemize}
\item Now we can rewrite {\footnotesize{}$F^{A}=R_{1}\left[G^{A}+R_{2}\left[H^{A}\right]\right]$}{\footnotesize \par}
\begin{itemize}
\item $G^{A}$ is filterable by construction 5 because it is of the form
$G^{A}=1+A\times K^{A}$ with filterable functor $K^{A}=1+\text{Int}+A$
\item $K^{A}$ is of the form $1+A+X$ with constant type $X$, so it is
filterable by constructions 1 and 3 with the \texttt{\textcolor{blue}{\footnotesize{}Option}}
functor $1+A$
\item $H^{A}$ is filterable by construction 5 with $H^{A}=1+A\times\left(1+A\times\text{String}\right)$,
while $1+A\times\text{String}$ is filterable by constructions 5 and
1
\end{itemize}
\item Constructions 3 and 4 show that $R_{1}\left[G^{A}+R_{2}\left[H^{A}\right]\right]$
is filterable
\end{itemize}
Note that there are more than one way of implementing \texttt{\textcolor{blue}{\footnotesize{}Filterable}}
here
\end{frame}

\begin{frame}{{*} Exercises II}
\begin{enumerate}
\item Implement a \texttt{\textcolor{blue}{\footnotesize{}Filterable}} instance
for \texttt{\textcolor{blue}{\footnotesize{}type F{[}T{]} = G{[}H{[}T{]}{]}}}
assuming that the functor \texttt{\textcolor{blue}{\footnotesize{}H{[}T{]}}}
already has a \texttt{\textcolor{blue}{\footnotesize{}Filterable}}
instance (construction 4). Verify the laws rigorously (i.e.\ by calculations,
not tests).
\item For \texttt{\textcolor{blue}{\footnotesize{}type F{[}T{]} = Option{[}Int
$\Rightarrow$ Option{[}(T, T){]}{]}}}, implement a \texttt{\textcolor{blue}{\footnotesize{}Filterable}}
instance. Show that the filterable laws hold by using known filterable
constructions (avoiding explicit proofs or tests).
\item Implement a \texttt{\textcolor{blue}{\footnotesize{}Filterable}} instance
for $F^{A}\equiv G^{A}+\text{Int}\times A\times A\times F^{A}$ (recursive)
for a filterable functor $G^{A}$. Verify the laws rigorously.
\item Show that $F^{A}=1+A\times G^{A}$ is in general \emph{not} filterable
if $G^{A}$ is an arbitrary (non-filterable) functor; it is enough
to give an example.
\item Show that $F^{A}=1+G^{A}+H^{A}$ is filterable if $1+G^{A}$ and $1+H^{A}$
are filterable (even when $G^{A}$ and $H^{A}$ are by themselves
not filterable).
\item Show that the functor $F^{A}=A+\left(\text{Int}\Rightarrow A\right)$
is not filterable.
\item Show that one can define \texttt{\textcolor{blue}{\footnotesize{}deflate}}$:C^{1+A}\Rightarrow C^{A}$
for any contrafunctor $C^{A}$ (not necessarily filterable), similarly
to how one can define \texttt{\textcolor{blue}{\footnotesize{}inflate}}$:F^{A}\Rightarrow F^{1+A}$
for any functor $F^{A}$ (not necessarily filterable). 
\end{enumerate}
\end{frame}

\end{document}
