\batchmode
\makeatletter
\def\input@path{{/Users/sergei.winitzki/Code/talks/ftt-fp/}}
\makeatother
\documentclass[english]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{amstext}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 % this default might be overridden by plain title style
 \newcommand\makebeamertitle{\frame{\maketitle}}%
 % (ERT) argument for the TOC
 \AtBeginDocument{%
   \let\origtableofcontents=\tableofcontents
   \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
   \def\gobbletableofcontents#1{\origtableofcontents}
 }
 \newenvironment{lyxcode}
   {\par\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \setlength{\listparindent}{0pt}% needed for AMS classes
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \normalfont\ttfamily}%
    \def\{{\char`\{}
    \def\}{\char`\}}
    \def\textasciitilde{\char`\~}
    \item[]}
   {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 5: Type classes]{Chapter 5: Type classes
 and their applications}
\author{Sergei Winitzki}
\date{January 14, 2018}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom

\makeatother

\begin{document}
\frame{\titlepage}
\begin{frame}{Motivation for type classes I: Restricting type arguments}

We need different \texttt{\textcolor{blue}{\footnotesize{}sum}} implementations
for \texttt{\textcolor{blue}{\footnotesize{}Seq{[}Int{]}, Seq{[}Double{]}}},
etc.
\begin{itemize}
\item but we cannot generalize \texttt{\textcolor{blue}{\footnotesize{}sum}}
to arbitrary types \texttt{\textcolor{blue}{\footnotesize{}T}} like
this:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~sum{[}T{]}(s:~Seq{[}T{]}):~T~=~???}{\footnotesize \par}
\end{lyxcode}
\item this can work only for \texttt{\textcolor{blue}{\footnotesize{}T}}
that have a zero value and a \texttt{\textcolor{blue}{\footnotesize{}+}}
method
\end{itemize}
Suppose we want to define \texttt{\textcolor{blue}{\footnotesize{}fmap}}
in addition to \texttt{\textcolor{blue}{\footnotesize{}map}} for functors
\begin{itemize}
\item but we cannot generalize \texttt{\textcolor{blue}{\footnotesize{}fmap}}
to arbitrary type constructors \texttt{\textcolor{blue}{\footnotesize{}F{[}\_{]}}}:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~fmap{[}F{[}\_{]},~A,~B{]}(f:~A~$\Rightarrow$~B):~F{[}A{]}~$\Rightarrow$~F{[}B{]}~=~???}{\footnotesize \par}
\end{lyxcode}
\item this can work only for type constructors \texttt{\textcolor{blue}{\footnotesize{}F{[}\_{]}}}
that are functors
\end{itemize}
We would like to define functions whose type arguments, such as \texttt{\textcolor{blue}{\footnotesize{}T}}
or \texttt{\textcolor{blue}{\footnotesize{}F{[}\_{]}}}, are assumed
to belong to a \emph{certain subset} of possible types
\begin{itemize}
\item We could then use the known properties of these type arguments
\item We would also like to add new supported types as needed
\begin{itemize}
\item This is similar to \emph{partial functions} \textendash{} but at type
level
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Motivation for type classes II: Partial type-level functions}

\begin{itemize}
\item Functions can be \textbf{total} or \textbf{partial}
\begin{itemize}
\item Total function: has a result for all argument values
\item Partial function: has \emph{no result} for \emph{some} argument values
\end{itemize}
\item Also, functions can be, in principle, \{from/to\} \{values/types\}:
\end{itemize}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline 
function: &
from value &
from type\tabularnewline
\hline 
\hline 
to value &
\texttt{\textcolor{blue}{\footnotesize{}def f(x:\ Int):\ Int}} &
\texttt{\textcolor{blue}{\footnotesize{}def point{[}A{]}: A $\Rightarrow$
List{[}A{]}}}\tabularnewline
\hline 
to type &
\emph{dependent type} &
\texttt{\textcolor{blue}{\footnotesize{}type Data{[}A{]} = Either{[}Int,
A{]}}}\tabularnewline
\hline 
\end{tabular}
\par\end{center}
\begin{itemize}
\item value-to-value = run time, type-to-{*} = compile time
\begin{itemize}
\item if we use JVM reflection, type-to-{*} can become run-time (\emph{yuck!})
\end{itemize}
\end{itemize}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline 
partial function: &
from value (PF) &
from type (PTTF; PTVF)\tabularnewline
\hline 
\hline 
example: &
\texttt{\textcolor{blue}{\footnotesize{}\{ case Some(x) $\Rightarrow$
x-1 \}}} &
GADTs; \texttt{\textcolor{blue}{\footnotesize{}implicitly{[}T{]}}}\tabularnewline
\hline 
when misapplied: &
exception at run time &
error at compile time\tabularnewline
\hline 
\end{tabular}
\par\end{center}
\begin{itemize}
\item \textbf{Type classes} are a systematic way of managing our PTFs
\begin{itemize}
\item It is safe to apply a PTF to type \texttt{\textcolor{blue}{\footnotesize{}T}}
if \texttt{\textcolor{blue}{\footnotesize{}T}} ``belongs to a certain
type class''
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Example of using value-level PFs: The caveats}

\begin{itemize}
\item Filter a \texttt{\textcolor{blue}{\footnotesize{}Seq{[}Either{[}Int,
Boolean{]}{]}}}, then apply \texttt{\textcolor{blue}{\footnotesize{}map}}
with a PF:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~s:~Seq{[}Int{]}~=~Seq(~Left(1),~Right(true),~Left(2)~)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~.filter(\_.isLeft)~}\textrm{\textcolor{gray}{\footnotesize{}//~result~here~is~still~of~type~}}\textcolor{blue}{\footnotesize{}Seq{[}Either{[}...{]}{]}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~.map~\{~case~Left(x)~$\Rightarrow$~x~\}~}\textrm{\textcolor{gray}{\footnotesize{}//~result~is~of~type~}}\textcolor{blue}{\footnotesize{}Seq{[}Int{]}}\textrm{\textcolor{gray}{\footnotesize{}~but~unsafe}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item ``We know'' it is okay to apply this PF here...
\begin{itemize}
\item but the types do not show this, \textendash{} compile-time checking
doesn't help
\item if refactored, the code may become wrong and break \emph{at run time}
\end{itemize}
\item The type-safe version uses \texttt{\textcolor{blue}{\footnotesize{}.collect}}
instead of \texttt{\textcolor{blue}{\footnotesize{}.filter().map()}}:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~s:~Seq{[}Int{]}~=~Seq(~Left(1),~Right(true),~Left(2)~)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~.collect~\{~case~Left(x)~$\Rightarrow$~x~\}}\textrm{\textcolor{gray}{\footnotesize{}~~//~result~is~safe,~of~type~}}\textcolor{blue}{\footnotesize{}Seq{[}Int{]}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item PFs are only safe to use in certain places, such as \texttt{\textcolor{blue}{\footnotesize{}.collect()}}{\footnotesize \par}
\begin{itemize}
\item in all other cases, value-level functions should better be total
\item can use ``refined'' types such as ``non-empty list'', ``positive
number'' etc.
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~f(xs:~NonEmptyList{[}Int{]})~=~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~val~h~=~xs.head}\textrm{\textcolor{gray}{\footnotesize{}~~//~safe~and~checked~at~compile~time}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize \par}
\end{lyxcode}
\end{itemize}
\end{frame}

\begin{frame}{Managing PTFs by hand I: GADTs}


\framesubtitle{PTTFs: Partial Type-to-Type Functions}
\begin{itemize}
\item A type constructor that accepts only certain types as parameters:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~MyTC{[}A{]}~}\textrm{\textcolor{gray}{\footnotesize{}//~``sealed''~\textendash{}~user~code~can't~add~cases}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~class~Case1(d:~Double)~extends~MyTC{[}Int{]}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~class~Case2()~extends~MyTC{[}String{]}}\textrm{\textcolor{gray}{\footnotesize{}~//~whatever}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item It looks like we have defined \texttt{\textcolor{blue}{\footnotesize{}MyTC{[}}}\textcolor{blue}{\footnotesize{}A}\texttt{\textcolor{blue}{\footnotesize{}{]}}}
for any type \textcolor{blue}{\footnotesize{}A} ?...
\begin{itemize}
\item actually, we can only ever create values of \texttt{\textcolor{blue}{\footnotesize{}MyTC{[}Int{]}}}
or \texttt{\textcolor{blue}{\footnotesize{}MyTC{[}String{]}}}{\footnotesize \par}
\end{itemize}
\item Effectively, $\text{MyTC}^{A}$ is a PTTF defined only for $A\in\left\{ \text{Int};\,\text{String}\right\} $
\begin{itemize}
\item This \textbf{type domain} is enforced \emph{at compile time}!
\end{itemize}
\item When to use GADTs (they are \emph{not} functors!):
\begin{itemize}
\item for domain modeling (e.g.\ queries with a fixed set of result types)
\item for DSLs that represent typed expressions
\end{itemize}
\item Alternatively, a PTTF can be a \texttt{\textcolor{blue}{\footnotesize{}trait}}
with some implementation code:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}trait~MyPTTF{[}A{]}~\{...\}~}\textrm{\textcolor{gray}{\footnotesize{}//~not~``sealed''~\textendash{}~user~code~may~extend}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}class~C1(...)~extends~MyPTTF{[}Int{]}~\{...\}}\textrm{\textcolor{gray}{\footnotesize{}~//~arbitrary~code}}{\footnotesize \par}
\end{lyxcode}
\end{itemize}
\end{frame}

\begin{frame}{Managing PTFs by hand II: Traits with inheritance}


\framesubtitle{PTVFs: Partial Type-to-Value Functions \textendash{} the object-oriented
way}
\begin{itemize}
\item A trait with methods and a few created values (as \texttt{\textcolor{blue}{\footnotesize{}object}}):
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}trait~HasPlus{[}A{]}~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~def~plus(a1:~A,~a2:~A):~Z}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}object~CaseInt~extends~HasPlus{[}Int{]}~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~def~plus(a1:~Int,~a2:~Int):~Int~=~a1~+~a2}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}object~CaseString~extends~HasPlus{[}String{]}~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~def~plus(a1:~String,~a2:~String):~String~=~a1~+~a2}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize \par}
\end{lyxcode}
\item \emph{Similar} to having defined \texttt{\textcolor{blue}{\footnotesize{}plus{[}A{]}}}
only for $A\in\left\{ \text{Int};\,\text{String}\right\} $
\item Limitations:
\begin{itemize}
\item We can only access \texttt{\textcolor{blue}{\footnotesize{}plus()
}}via a value of type \texttt{\textcolor{blue}{\footnotesize{}HasPlus{[}A{]}}}
\ 
\item All PTVFs must be declared up front in the trait
\begin{itemize}
\item Not extensible \textendash{} cannot add new PTVFs later
\item Not compositional \textendash{} cannot use this in other PTVFs defined
later
\end{itemize}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Managing PTFs by hand III: ``Type Evidence'' arguments}


\framesubtitle{PTVFs: Partial Type-to-Value Functions \textendash{} the general
case}

To define a function \texttt{\textcolor{blue}{\footnotesize{}def func{[}A{]}(...)}}
only for certain types \texttt{\textcolor{blue}{\footnotesize{}A}}:
\begin{enumerate}
\item create a PTTF defined only for the relevant types \texttt{\textcolor{blue}{\footnotesize{}A}},
e.g.\ \texttt{\textcolor{blue}{\footnotesize{}IsGood{[}A{]}}} \ 
\item add an \emph{extra argument} of type \texttt{\textcolor{blue}{\footnotesize{}IsGood{[}A{]}}}
(\textbf{type evidence}) to \texttt{\textcolor{blue}{\footnotesize{}func{[}A{]}}}\ 
\item create some values of types \texttt{\textcolor{blue}{\footnotesize{}IsGood{[}A{]}}}
for relevant types \texttt{\textcolor{blue}{\footnotesize{}A}} as
needed
\end{enumerate}
What we gained:
\begin{itemize}
\item it is now impossible to call \texttt{\textcolor{blue}{\footnotesize{}func{[}A{]}}}
with an unsupported type \texttt{\textcolor{blue}{\footnotesize{}A}}{\footnotesize \par}
\begin{itemize}
\item trying to do so will fail \emph{at compile time} \ \textendash{}
TE values won't type-check
\end{itemize}
\item new supported types can be added in user code if \texttt{\textcolor{blue}{\footnotesize{}IsGood}}
is not \texttt{\textcolor{blue}{\footnotesize{}sealed}}{\footnotesize \par}
\end{itemize}
The cost:
\begin{itemize}
\item all calls to \texttt{\textcolor{blue}{\footnotesize{}func{[}A{]}(...)}}
will now need TE values as extra argument(s)
\item we need to keep passing the TE values around the code
\item one TE value needs to be created for \emph{each} supported type \texttt{\textcolor{blue}{\footnotesize{}A}}
\ 
\end{itemize}
How we mitigate this problem in Scala: use \texttt{\textcolor{blue}{\footnotesize{}implicit}}
values
\begin{itemize}
\item TE arguments are explicit only at \texttt{\textcolor{blue}{\footnotesize{}func}}
declaration site
\item once defined as \texttt{\textcolor{blue}{\footnotesize{}implicit}},
TE values are passed around automatically
\item new \texttt{\textcolor{blue}{\footnotesize{}implicit}} values can
be built up automatically (and recursively!)
\end{itemize}
\end{frame}

\begin{frame}{Scala's mechanism of ``\texttt{implicit} values''}

Implicit values are:
\begin{itemize}
\item declared as \texttt{\textcolor{blue}{\footnotesize{}implicit val x:\ SomeType
= ...}}{\footnotesize \par}
\begin{itemize}
\item also have \texttt{\textcolor{blue}{\footnotesize{}implicit def f{[}T{]}(...)\ =
...}} and \texttt{\textcolor{blue}{\footnotesize{}implicit class(...)}}{\footnotesize \par}
\end{itemize}
\item automatically passed into functions that declare extra arguments as
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~f(args...)(implicit~x:~SomeType)~=~...}{\footnotesize \par}
\end{lyxcode}
\item searched in local scope, imports, companion objects, parent classes
\begin{itemize}
\item having $\geq2$ \texttt{\textcolor{blue}{\footnotesize{}implicit}}
values of the same type is a compile-time error!
\end{itemize}
\item standard library has \texttt{\textcolor{blue}{\footnotesize{}def implicitly{[}A{]}(implicit
x:\ A):\ A = x}}{\footnotesize \par}
\end{itemize}
Special short syntax for declaring implicit TE arguments in a PTVF:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~func{[}A:~MyTypeClass{]}(args...)~=~...}{\footnotesize \par}
\end{lyxcode}
This is equivalent to
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~func{[}A{]}(args...)(implicit~ev:~MyTypeClass{[}A{]})~=~...}{\footnotesize \par}
\end{lyxcode}
We still need to:
\begin{itemize}
\item declare \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass{[}A{]}}}
as a PTTF elsewhere
\item create TE values of various types and declare them as \texttt{\textcolor{blue}{\footnotesize{}implicit}}
\ 
\end{itemize}
\end{frame}

\begin{frame}{Type classes I: The general definition}

A \textbf{type class} is a set of PTVFs that all have the same type
domain
\begin{itemize}
\item In terms of specific code to be written, a type class is:
\begin{enumerate}
\item a PTTF, e.g.\ \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass{[}T{]}}}
with some code that creates TE values, \emph{and}
\item the desired PTVFs that use this PTTF to define their type domain
\end{enumerate}
\begin{itemize}
\item for many important use cases, the PTVFs must also satisfy certain
laws
\end{itemize}
\item A type \texttt{\textcolor{blue}{\footnotesize{}T}} ``\textbf{belongs
to} the type class \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass}}''
if a TE value exists
\begin{itemize}
\item i.e.\ if \emph{some} value of type \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass{[}T{]}}}
can be found
\end{itemize}
\item A function \texttt{\textcolor{blue}{\footnotesize{}func{[}T{]}}} ``requires
the type class \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass}}
for \texttt{\textcolor{blue}{\footnotesize{}T}}'' if one of \texttt{\textcolor{blue}{\footnotesize{}func}}'s
arguments is a value of PTTF type \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass{[}T{]}}}{\footnotesize \par}
\begin{itemize}
\item that argument is the \textbf{type class instance} for the type parameter
\texttt{\textcolor{blue}{\footnotesize{}T}}{\footnotesize \par}
\item this \textbf{constrains} the type parameter \texttt{\textcolor{blue}{\footnotesize{}T}}
to \textbf{belong to} the type class
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Type classes II: Implementation in Scala}

A type class is typically implemented in Scala as:
\begin{itemize}
\item trait with a type parameter, e.g.\ \texttt{\textcolor{blue}{\footnotesize{}trait
MyTypeClass{[}T{]}}}{\footnotesize \par}
\item code that creates values of type \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass{[}T{]}}}
for various \texttt{\textcolor{blue}{\footnotesize{}T}}{\footnotesize \par}
\begin{itemize}
\item these values are declared as \texttt{\textcolor{blue}{\footnotesize{}implicit}}
and made available via imports or in the companion objects for the
specific types \texttt{\textcolor{blue}{\footnotesize{}T}}{\footnotesize \par}
\end{itemize}
\item some functions with implicit argument(s) of type \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass{[}T{]}}}{\footnotesize \par}
\begin{itemize}
\item these functions are usually \texttt{\textcolor{blue}{\footnotesize{}def}}
methods in a trait, but don't have to be
\item laws for these functions may need to be enforced by property tests
\end{itemize}
\end{itemize}
Usually, all information about the type \texttt{\textcolor{blue}{\footnotesize{}T}}
is contained in the TE value
\begin{itemize}
\item the trait \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass{[}T{]}}}
contains all relevant PTVFs as \texttt{\textcolor{blue}{\footnotesize{}def}}'s
\item in simpler cases, TE can be a data type (not a trait with \texttt{\textcolor{blue}{\footnotesize{}def}}
methods)
\begin{itemize}
\item a trait with \texttt{\textcolor{blue}{\footnotesize{}def}} methods
is necessary for \emph{higher-order} type functions
\end{itemize}
\end{itemize}
See example code
\end{frame}

\begin{frame}{Examples of type classes I}


\framesubtitle{Some simple PTFs and their use cases}
\begin{itemize}
\item A type \texttt{\textcolor{blue}{\footnotesize{}T}} is a \textbf{semigroup}
if it has an \emph{associative} binary operation
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~op(x:~T,~y:~T):~T}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item a bare-bones operation, no inverse \textendash{} just ``can combine'' 
\end{itemize}
\item A type \texttt{\textcolor{blue}{\footnotesize{}T}} is \textbf{pointed}
if there exists a function \texttt{\textcolor{blue}{\footnotesize{}point:\ T}}{\footnotesize \par}
\begin{itemize}
\item This is a special, somehow ``naturally'' selected value of that
type
\begin{itemize}
\item Examples: \texttt{\textcolor{blue}{\footnotesize{}0:\ Int}}; \texttt{\textcolor{blue}{\footnotesize{}\textquotedbl{}\textquotedbl{}:\ String}};
\texttt{\textcolor{blue}{\footnotesize{}identity{[}A{]}:\ A $\Rightarrow$
A}}{\footnotesize \par}
\end{itemize}
\end{itemize}
\item A type \texttt{\textcolor{blue}{\footnotesize{}T}} is a \textbf{monoid}
if there exist functions
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~empty{[}T{]}:~T}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}def~combine{[}T{]}(x:~T,~y:~T):~T}{\footnotesize \par}
\end{lyxcode}
such that the usual algebraic laws hold:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}combine}} is associative
\item \texttt{\textcolor{black}{\footnotesize{}$\forall x:\text{combine}(\text{empty},x)=\text{combine}(x,\text{empty})=x$ }}{\footnotesize \par}
\end{itemize}
\item Monoids are an abstraction for any sort of data aggregation
\end{itemize}
See example code for implementing the \texttt{\textcolor{blue}{\footnotesize{}Monoid}}
type class:
\begin{itemize}
\item by using a case class as a PTTF (instance from scratch)
\item by assuming \texttt{\textcolor{blue}{\footnotesize{}Pointed}} and
\texttt{\textcolor{blue}{\footnotesize{}Semigroup}} (``derived''
instance)
\end{itemize}
\end{frame}

\begin{frame}{Examples of type classes II}


\framesubtitle{Higher-order PTFs}
\begin{itemize}
\item A type constructor $F^{A}$ is a functor if it has a \texttt{\textcolor{blue}{\footnotesize{}map}}
operation
\begin{itemize}
\item or, equivalently, \texttt{\textcolor{blue}{\footnotesize{}fmap}} 
\item that satisfies the functor laws (identity law, composition law)
\end{itemize}
\item We would like to write a generic function that tests the functor laws
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~checkFunctorLaws{[}F{[}\_{]},~A,~B,~C{]}():~Assertion~=~???}{\footnotesize \par}
\end{lyxcode}
\item Need to get access to the function \texttt{\textcolor{blue}{\footnotesize{}map}}
defined for the given \texttt{\textcolor{blue}{\footnotesize{}F}}{\footnotesize \par}
\item We treat \texttt{\textcolor{blue}{\footnotesize{}map}} as a PTVF whose
type domain is all functors \texttt{\textcolor{blue}{\footnotesize{}F}}:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~map{[}F{[}\_{]},~A,~B{]}(fa:~F{[}A{]},~f:~A~$\Rightarrow$~B):~F{[}B{]}}{\footnotesize \par}
\end{lyxcode}
\item We constrain \texttt{\textcolor{blue}{\footnotesize{}F}} to belong
to the \texttt{\textcolor{blue}{\footnotesize{}Functor}} type class
\begin{itemize}
\item by adding \texttt{\textcolor{blue}{\footnotesize{}implicit ev:\ Functor{[}F{]}}}
as extra argument to \texttt{\textcolor{blue}{\footnotesize{}map}}{\footnotesize \par}
\begin{itemize}
\item note: \texttt{\textcolor{blue}{\footnotesize{}Functor}} is a \emph{higher-order}
PTTF \textendash{} its type argument is \texttt{\textcolor{blue}{\footnotesize{}F{[}\_{]}}}{\footnotesize \par}
\end{itemize}
\end{itemize}
\end{itemize}
See test code for implementation and functor laws
\end{frame}

\begin{frame}{Types and kinds}

Compare value-to-value functions (VVFs) vs.\ type-to-value functions:
\begin{itemize}
\item the \textbf{domain} of a VVF is the set of admissible argument values
\begin{itemize}
\item a ``value domain'' is called a \textbf{type}
\item the VVF can be applied safely if its argument is of the right \textbf{type}
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~f(x:~Option{[}Int{]})~=~...}{\footnotesize \par}
\end{lyxcode}
\item the \textbf{type domain} of a PTVF is the set of admissible argument
types
\begin{itemize}
\item a ``type domain'' is called a \textbf{kind}
\item the PTVF can be applied safely if its type argument is of the right
\textbf{kind}
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~func{[}T{]}(args...)(implicit~ev:~MyTypeClass{[}T{]})~=~...}{\footnotesize \par}
\end{lyxcode}
\item In both cases, the function call safety is guaranteed \emph{at compile
time}
\end{itemize}
Kinds are the ``type system for types''
\begin{itemize}
\item a type class \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass}}
defines a new kind (as a set of types)
\begin{itemize}
\item suggested \textbf{kind} notation:{\footnotesize{} $(*:\text{MyTypeClass})$}{\footnotesize \par}
\end{itemize}
\item another available kind is the \textbf{type constructor} kind, e.g.:
\texttt{\textcolor{blue}{\footnotesize{}F{[}\_{]}}}{\footnotesize \par}
\begin{itemize}
\item in \texttt{\textcolor{blue}{\footnotesize{}F{[}T{]}}}, the \texttt{\textcolor{blue}{\footnotesize{}F}}
and the \texttt{\textcolor{blue}{\footnotesize{}T}} are types of different
\textbf{kinds}
\item define \texttt{\textcolor{blue}{\footnotesize{}type Ap{[}F{[}\_{]},
T{]} = F{[}T{]}}}, then wrong kinds will fail in \texttt{\textcolor{blue}{\footnotesize{}Ap{[}A,
B{]}}}{\footnotesize \par}
\begin{itemize}
\item suggested \textbf{kind} notation:{\footnotesize{} $\text{Ap}:(*\rightarrow*,\,*)\rightarrow*$}{\footnotesize \par}
\end{itemize}
\item See test code
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Scala's syntax for ``implicit methods''}

Two sorts of available syntax for Scala functions:
\begin{enumerate}
\item as in ordinary math: \texttt{\textcolor{blue}{\footnotesize{}func(x,
y)}} or \texttt{\textcolor{blue}{\footnotesize{}func(x, y)(z)}} etc.
\item as ``method'': \texttt{\textcolor{blue}{\footnotesize{}x.func(y)}}
or equivalently \texttt{\textcolor{blue}{\footnotesize{}x func y}}
\ ue}{\footnotesize{}x func y}}
\ 
\begin{itemize}
\item this is similar to \texttt{\textcolor{blue}{\footnotesize{}func(x)(y)}}
but is implemented differently
\end{itemize}
\end{enumerate}
It is often convenient to use functions syntactically as methods
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~+++{[}T:~MyTypeClass{]}(t:~T,~arg:...)~=~...}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}val~t:~T~=~...}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}+++(t,~arg)~}\textrm{\textcolor{gray}{\footnotesize{}//~that's~how~we~have~to~call~this~function}}{\footnotesize \par}

\textrm{\textcolor{gray}{\footnotesize{}//~but~instead~we~want~to~be~able~to~write~}}\textcolor{gray}{\footnotesize{}t~+++~arg}{\footnotesize \par}
\end{lyxcode}
To implement the ``method syntax'' for a PTVF \texttt{\textcolor{blue}{\footnotesize{}func}}:
\begin{itemize}
\item declare \texttt{\textcolor{blue}{\footnotesize{}func}} as a method
on a new trait or class, say \texttt{\textcolor{blue}{\footnotesize{}MyTCMethods{[}T{]}}}{\footnotesize \par}
\item declare an \emph{implicit conversion }function from \texttt{\textcolor{blue}{\footnotesize{}T}}
to \texttt{\textcolor{blue}{\footnotesize{}MyTCMethods{[}T{]}}}{\footnotesize \par}
\begin{itemize}
\item to reduce the necessary coding, use an \texttt{\textcolor{blue}{\footnotesize{}implicit
class}}{\footnotesize \par}
\end{itemize}
\end{itemize}
What we gained:
\begin{itemize}
\item the PTVF appears as a method \emph{only} on values of the relevant
types
\item the new syntax is defined automatically on \emph{all} the relevant
types \texttt{\textcolor{blue}{\footnotesize{}T}}{\footnotesize \par}
\end{itemize}
See example code
\end{frame}

\begin{frame}{Worked examples}

\begin{enumerate}
\item Define a PTVF \texttt{\textcolor{blue}{\footnotesize{}def bitsize{[}T{]}
= ...}} such that \texttt{\textcolor{blue}{\footnotesize{}bitsize{[}Int{]}}}
returns $32$ and \texttt{\textcolor{blue}{\footnotesize{}bitsize{[}Long{]}}}
returns $64$; otherwise \texttt{\textcolor{blue}{\footnotesize{}bitsize{[}T{]}}}
is undefined
\item Define a monoid instance for the type $1+\left(\text{String}\Rightarrow\text{String}\right)$
\item Assuming that $A$ and $B$ are monoids, define monoid instance for
$A\times B$
\item Show: If $A$ is a monoid and $B$ is a semigroup then $A+B$ is a
monoid
\item Define a functor instance for \texttt{\textcolor{blue}{\footnotesize{}type
F{[}T{]} = Seq{[}Try{[}T{]}{]}}}{\footnotesize \par}
\item Define a Cats' \texttt{\textcolor{blue}{\footnotesize{}Bifunctor}}
instance for $Q^{X,Y}\equiv X+X\times Y$
\item Define a \texttt{\textcolor{blue}{\footnotesize{}ContraFunctor}} type
class having \texttt{\textcolor{blue}{\footnotesize{}contrafmap}}:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~contrafmap{[}A,~B{]}(f:~B~$\Rightarrow$~A):~C{[}A{]}~$\Rightarrow$~C{[}B{]}}{\footnotesize \par}
\end{lyxcode}
Define a \texttt{\textcolor{blue}{\footnotesize{}ContraFunctor}} instance
for type constructor $C^{A}\equiv A\Rightarrow\text{Int}$
\item Define functor instance for recursive type $Q^{A}\equiv\left(\text{Int}\Rightarrow A\right)+\text{Int}+Q^{A}$
\item {*} If $F^{A}$ and $G^{A}$ are functors, define functor instance
for $F^{A}+G^{A}$
\end{enumerate}
\end{frame}

\begin{frame}{Exercises}

\begin{enumerate}
\item Define a PTVF \texttt{\textcolor{blue}{\footnotesize{}def isLong{[}T{]}:\ Boolean}}
that returns \texttt{\textcolor{blue}{\footnotesize{}true}} for \texttt{\textcolor{blue}{\footnotesize{}Long}}
and \texttt{\textcolor{blue}{\footnotesize{}Double}}; returns \texttt{\textcolor{blue}{\footnotesize{}false}}
for \texttt{\textcolor{blue}{\footnotesize{}Int}}, \texttt{\textcolor{blue}{\footnotesize{}Short}},
and \texttt{\textcolor{blue}{\footnotesize{}Float}}; otherwise undefined
\item Define a monoid instance for the type $\text{String}\times(1+\text{Int})$
\item If $A$ is a monoid and $R$ any type, define monoid instance for
$R\Rightarrow A$
\item Show: If \texttt{\textcolor{blue}{\footnotesize{}S}} is a semigroup
then \texttt{\textcolor{blue}{\footnotesize{}Option{[}S{]}}} is a
monoid
\item Define a functor instance for \texttt{\textcolor{blue}{\footnotesize{}type
F{[}T{]} = Future{[}Seq{[}T{]}{]}}}{\footnotesize \par}
\item Define a Cats' \texttt{\textcolor{blue}{\footnotesize{}Bifunctor}}
instance for $B^{X,Y}\equiv\left(\text{Int}\Rightarrow X\right)+Y\times Y$
\item Define a \texttt{\textcolor{blue}{\footnotesize{}ProFunctor}} type
class having \texttt{\textcolor{blue}{\footnotesize{}dimap}}:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~dimap{[}A,~B{]}(f:~A~$\Rightarrow$~B,~g:~B~$\Rightarrow$~A):~F{[}A{]}~$\Rightarrow$~F{[}B{]}}{\footnotesize \par}
\end{lyxcode}
Define a \texttt{\textcolor{blue}{\footnotesize{}ProFunctor}} instance
for $P^{A}\equiv A\Rightarrow\left(\text{Int}\times A\right)$
\item Define a functor instance for recursive type $Q^{A}\equiv\text{String}+A\times Q^{A}$
\item {*} If $F^{A}$ and $G^{A}$ are functors, define functor instance
for $F^{A}\times G^{A}$ 
\item {*} Define a functor instance for $F^{A}\Rightarrow G^{A}$ where
$F^{A}$ is a contrafunctor (use Cats' \texttt{\textcolor{blue}{\footnotesize{}Contravariant}}
type class for $F^{A}$) and $G^{A}$ is a functor
\end{enumerate}
\end{frame}

\end{document}
