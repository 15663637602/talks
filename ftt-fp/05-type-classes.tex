%% LyX 2.2.0 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{amstext}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 % this default might be overridden by plain title style
 \newcommand\makebeamertitle{\frame{\maketitle}}%
 % (ERT) argument for the TOC
 \AtBeginDocument{%
   \let\origtableofcontents=\tableofcontents
   \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
   \def\gobbletableofcontents#1{\origtableofcontents}
 }
 \newenvironment{lyxcode}
   {\par\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \setlength{\listparindent}{0pt}% needed for AMS classes
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \normalfont\ttfamily}%
    \def\{{\char`\{}
    \def\}{\char`\}}
    \def\textasciitilde{\char`\~}
    \item[]}
   {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 5: Type classes etc.]{Chapter 5: Type classes
 and their applications}
\subtitle{Pointed, co-pointed, and filtered functors}
\author{Sergei Winitzki}
\date{January 14, 2018}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{navigation symbols}{}

\makeatother

\begin{document}
\frame{\titlepage}
\begin{frame}{Motivation for type classes I: Restricting type arguments}

We need different \texttt{\textcolor{blue}{\footnotesize{}sum}} implementations
for \texttt{\textcolor{blue}{\footnotesize{}Seq{[}Int{]}, Seq{[}Double{]}}},
etc.
\begin{itemize}
\item But we cannot generalize \texttt{\textcolor{blue}{\footnotesize{}sum}}
to arbitrary types \texttt{\textcolor{blue}{\footnotesize{}T}} like
this:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~sum{[}T{]}(s:~Seq{[}T{]}):~T~=~???}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item This can work only for \texttt{\textcolor{blue}{\footnotesize{}T}}
that have a zero value and a \texttt{\textcolor{blue}{\footnotesize{}+}}
method
\end{itemize}
We cannot generalize \texttt{\textcolor{blue}{\footnotesize{}fmap}}
to arbitrary type constructors \texttt{\textcolor{blue}{\footnotesize{}F{[}\_{]}}}:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~fmap{[}F{[}\_{]},~A,~B{]}(f:~A~$\Rightarrow$~B):~F{[}A{]}~$\Rightarrow$~F{[}B{]}~=~???}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item This can work only for type constructors \texttt{\textcolor{blue}{\footnotesize{}F{[}\_{]}}}
that are functors
\end{itemize}
We would like to define functions whose type arguments, such as \texttt{\textcolor{blue}{\footnotesize{}T}}
or \texttt{\textcolor{blue}{\footnotesize{}F{[}\_{]}}}, are constrained
to belong to a \emph{certain subset} of possible types
\begin{itemize}
\item We could then use the guaranteed properties of these type arguments
\item This is similar to \emph{partial functions} \textendash{} but at type
level
\end{itemize}
\end{frame}

\begin{frame}{Motivation for type classes II: Partial type-level functions}

\begin{itemize}
\item Functions can be \textbf{total} or \textbf{partial}
\begin{itemize}
\item Total function: has a result for all argument values
\item Partial function: has \emph{no result} for some argument values
\end{itemize}
\item Also, functions can be, in principle, \{from/to\} \{values/types\}:
\end{itemize}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline 
functions: & from value & from type\tabularnewline
\hline 
\hline 
to value & \texttt{\textcolor{blue}{\footnotesize{}def f(x:\ Int):\ Int}} & \texttt{\textcolor{blue}{\footnotesize{}def point{[}A{]}: A $\Rightarrow$
List{[}A{]}}}\tabularnewline
\hline 
to type & \emph{dependent types} & \texttt{\textcolor{blue}{\footnotesize{}type Data{[}A{]} = Either{[}Int,
A{]}}}\tabularnewline
\hline 
\end{tabular}
\par\end{center}
\begin{itemize}
\item value to value = run time, type to type / to value = compile time
\begin{itemize}
\item if we use JVM reflection, type-to-{*} can become run-time (boo!)
\end{itemize}
\end{itemize}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline 
designation: & from value (PF) & from type (PTTF; PTVF)\tabularnewline
\hline 
\hline 
example: & \texttt{\textcolor{blue}{\footnotesize{}\{ case Some(x) $\Rightarrow$
...\ \}}} & GADTs; \texttt{\textcolor{blue}{\footnotesize{}implicitly{[}T{]}}}\tabularnewline
\hline 
when misapplied: & exception at run time & error at compile time\tabularnewline
\hline 
\end{tabular}
\par\end{center}
\begin{itemize}
\item Type classes are a systematic way of managing your PTFs
\begin{itemize}
\item It is safe to apply a PTF to type \texttt{\textcolor{blue}{\footnotesize{}T}}
if \texttt{\textcolor{blue}{\footnotesize{}T}} ``belongs to a certain
type class''
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Example of uses of PFs: The caveats}

\begin{itemize}
\item Filter a \texttt{\textcolor{blue}{\footnotesize{}Seq{[}Either{[}Int,
Boolean{]}{]}}}, then apply \texttt{\textcolor{blue}{\footnotesize{}map}}
with a PF:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~s:~Seq{[}Int{]}~=~Seq(~Left(1),~Right(true),~Left(2)~)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~.filter(\_.isLeft)~}\textrm{\textcolor{gray}{\footnotesize{}//~result~here~is~still~of~type~}}\textcolor{blue}{\footnotesize{}Seq{[}Either{[}...{]}{]}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~.map~\{~case~Left(x)~$\Rightarrow$~x~\}~}\textrm{\textcolor{gray}{\footnotesize{}//~result~is~of~type~}}\textcolor{blue}{\footnotesize{}Seq{[}Int{]}}\textrm{\textcolor{gray}{\footnotesize{}~but~unsafe}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item ``We know'' it is okay to apply this PF here...
\begin{itemize}
\item But the types do not show this, \textendash{} compile-time checking
doesn't help
\item If refactored, the code may become wrong and break \emph{at run time}
\end{itemize}
\item The type-safe version uses \texttt{\textcolor{blue}{\footnotesize{}.collect}}
instead of \texttt{\textcolor{blue}{\footnotesize{}.filter().map()}}:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~s:~Seq{[}Int{]}~=~Seq(~Left(1),~Right(true),~Left(2)~)}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~.collect~\{~case~Left(x)~$\Rightarrow$~x~\}}\textrm{\textcolor{gray}{\footnotesize{}~~//~result~is~safe,~of~type~}}\textcolor{blue}{\footnotesize{}Seq{[}Int{]}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item PFs are only safe to use in certain places, such as \texttt{\textcolor{blue}{\footnotesize{}.collect()}}{\footnotesize \par}
\begin{itemize}
\item In all other cases, value-level functions should better be total
\item Can use ``refined'' types such as ``non-empty list'', ``positive
number'' etc.
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~f(xs:~NonEmptyList{[}Int{]})~=~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~val~h~=~xs.head}\textrm{\textcolor{gray}{\footnotesize{}~~//~safe~and~checked~at~compile~time}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize \par}
\end{lyxcode}
\end{itemize}
\end{frame}

\begin{frame}{Managing PTFs by hand I: GADTs}


\framesubtitle{PTTFs: Partial Type-to-Type Functions}
\begin{itemize}
\item A type constructor that accepts only certain types as parameters:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~MyTC{[}Z{]}~}\textrm{\textcolor{gray}{\footnotesize{}//~``sealed''~\textendash{}~user~code~can't~add~cases}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~class~Case1(d:~Double)~extends~MyTC{[}Int{]}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}final~case~class~Case2()~extends~MyTC{[}String{]}}\textrm{\textcolor{gray}{\footnotesize{}~//~whatever}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item It looks like we have defined \texttt{\textcolor{blue}{\footnotesize{}MyTC{[}Z{]}}}
for any type \texttt{\textcolor{blue}{\footnotesize{}Z}} ?...
\begin{itemize}
\item no, we can only ever create values of \texttt{\textcolor{blue}{\footnotesize{}MyTC{[}Int{]}}}
or \texttt{\textcolor{blue}{\footnotesize{}MyTC{[}String{]}}}{\footnotesize \par}
\end{itemize}
\item So \texttt{\textcolor{blue}{\footnotesize{}MyTC{[}Z{]}}} is a PTTF
defined only for \texttt{\textcolor{blue}{\footnotesize{}Z = Int}}
and \texttt{\textcolor{blue}{\footnotesize{}Z = String}}{\footnotesize \par}
\item This type constraint is checked and enforced \emph{at compile time}!
\item When to use GADTs:
\begin{itemize}
\item for domain modeling (e.g.\ queries with a fixed set of result types)
\item for DSLs that have typed expressions
\end{itemize}
\item Instead of GADTs, a PTTF can be a trait with implementation code
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}trait~MyPTTF{[}Z{]}~\{...\}~}\textrm{\textcolor{gray}{\footnotesize{}//~not~``sealed''~\textendash{}~user~code~may~extend}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}class~C1(...)~extends~MyPTTF{[}Int{]}~\{...\}}\textrm{\textcolor{gray}{\footnotesize{}~//~arbitrary~code}}{\footnotesize \par}
\end{lyxcode}
\end{itemize}
\end{frame}

\begin{frame}{Managing PTFs by hand II: ``Type Evidence'' arguments}


\framesubtitle{PTVFs: Partial Type-to-Value Functions}

To define a function \texttt{\textcolor{blue}{\footnotesize{}def func{[}T{]}(...)}}
only for certain types \texttt{\textcolor{blue}{\footnotesize{}T}}:
\begin{enumerate}
\item Create a PTTF defined only for the relevant types \texttt{\textcolor{blue}{\footnotesize{}T}},
e.g.\ \texttt{\textcolor{blue}{\footnotesize{}IsGood{[}T{]}}}{\footnotesize \par}
\item Add an extra argument of type \texttt{\textcolor{blue}{\footnotesize{}IsGood{[}T{]}}}
(\textbf{type evidence}) to \texttt{\textcolor{blue}{\footnotesize{}func{[}T{]}}}{\footnotesize \par}
\item Create some values of type \texttt{\textcolor{blue}{\footnotesize{}IsGood{[}T{]}}}
as needed, for relevant types \texttt{\textcolor{blue}{\footnotesize{}T }}{\footnotesize \par}
\end{enumerate}
What we gained:
\begin{itemize}
\item it is now impossible to call \texttt{\textcolor{blue}{\footnotesize{}func}}
with an unsupported type \texttt{\textcolor{blue}{\footnotesize{}T}}{\footnotesize \par}
\item trying to do so will fail \emph{at compile time}, because TE won't
type-check
\item If \texttt{\textcolor{blue}{\footnotesize{}IsGood{[}T{]}}} is not
\texttt{\textcolor{blue}{\footnotesize{}sealed}}, more types \texttt{\textcolor{blue}{\footnotesize{}T}}
can be added via user code
\end{itemize}
The cost:
\begin{itemize}
\item all calls to \texttt{\textcolor{blue}{\footnotesize{}func}} now need
TE values as extra argument(s)
\item we need to keep passing the TE values around the code
\item the TE values need to be created for each supported type \texttt{\textcolor{blue}{\footnotesize{}T}}{\footnotesize \par}
\end{itemize}
How we mitigate this problem in Scala: use \texttt{\textcolor{blue}{\footnotesize{}implicit}}
values
\begin{itemize}
\item TE arguments are needed only at declaration site of \texttt{\textcolor{blue}{\footnotesize{}func}}{\footnotesize \par}
\item Once defined as \texttt{\textcolor{blue}{\footnotesize{}implicit}},
TE values are passed around automatically
\item New TE values can be often built up automatically (and recursively!)
\end{itemize}
\end{frame}

\begin{frame}{Scala's mechanism of ``\texttt{implicit} values''}

Implicit values are:
\begin{itemize}
\item declared as \texttt{\textcolor{blue}{\footnotesize{}implicit val x:\ SomeType
= ...}}{\footnotesize \par}
\item automatically passed into functions that declare extra arguments as
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~f(args...)(implicit~x:~SomeType)~=~...}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item searched in local scope, imports, companion objects, parent classes
\item standard library has \texttt{\textcolor{blue}{\footnotesize{}def implicitly{[}T{]}(implicit
t:\ T):\ T = t}}{\footnotesize \par}
\end{itemize}
Special syntax for declaring implicit TE arguments in a PTVF:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~func{[}T:~MyTypeClass{]}(args...)~=~...}{\footnotesize \par}
\end{lyxcode}
This is equivalent to
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~func{[}T{]}(args...)(implicit~ev:~MyTypeClass{[}T{]})~=~...}{\footnotesize \par}
\end{lyxcode}
We still need to:
\begin{itemize}
\item declare \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass{[}T{]}}}
as a PTTF elsewhere
\item create TE values of various types and declare them as \texttt{\textcolor{blue}{\footnotesize{}implicit}}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Managing PTFs by hand III: Traits with inheritance}


\framesubtitle{PTVFs: Partial Type-to-Value Functions, the object-oriented way}
\begin{itemize}
\item A trait with methods and a few implementations:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}trait~HasPlus{[}Z{]}~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~def~plus(z1:~Z,~z2:~Z):~Z}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}implicit~object~CaseInt~extends~HasPlus{[}Int{]}~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~def~plus(z1:~Int,~z2:~Int):~Int~=~z1~+~z2}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}implicit~object~CaseString~extends~HasPlus{[}String{]}~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~def~plus(z1:~String,~z2:~String):~String~=~z1~+~z2}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Similar to having \texttt{\textcolor{blue}{\footnotesize{}plus{[}Z{]}}}
only for two types, \texttt{\textcolor{blue}{\footnotesize{}Int}}
and \texttt{\textcolor{blue}{\footnotesize{}String}}{\footnotesize \par}
\begin{itemize}
\item We can only access \texttt{\textcolor{blue}{\footnotesize{}plus{[}Z{]}}}
via a TE value of type \texttt{\textcolor{blue}{\footnotesize{}HasPlus{[}Z{]}}}{\footnotesize \par}
\end{itemize}
\end{itemize}
See example code
\end{frame}

\begin{frame}{Type classes I: The definition}

A \textbf{type class} is a set of PTVFs that all have the same type
domain
\begin{itemize}
\item In terms of specific code to be written, a type class is:
\begin{enumerate}
\item a PTTF, e.g.\ \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass{[}T{]}}},
defining the type domain, \emph{together with}
\item some code (usually, library imports) that creates some TE values,
\emph{and}
\item one or more PTVFs that use this PTTF for TE arguments
\end{enumerate}
\begin{itemize}
\item for many important use cases, the PTVFs must satisfy certain laws
\end{itemize}
\item A type \texttt{\textcolor{blue}{\footnotesize{}T}} ``\textbf{belongs
to} the type class \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass}}''
if a TE value exists
\begin{itemize}
\item i.e.\ if \emph{some} value of type \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass{[}T{]}}}
can be found
\begin{itemize}
\item (usually, as a library import)
\end{itemize}
\end{itemize}
\item A function \texttt{\textcolor{blue}{\footnotesize{}func{[}T{]}}} ``requires
the type class \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass}}
for \texttt{\textcolor{blue}{\footnotesize{}T}}'' if one of \texttt{\textcolor{blue}{\footnotesize{}func}}'s
arguments is a value of type \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass{[}T{]}}}{\footnotesize \par}
\begin{itemize}
\item that argument is the \textbf{type class instance} for the type parameter
\texttt{\textcolor{blue}{\footnotesize{}T}}{\footnotesize \par}
\item this \textbf{constrains} the type parameter \texttt{\textcolor{blue}{\footnotesize{}T}}
to belong to the type class
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Type classes II: Implementation in Scala}

A type class is typically implemented in Scala as:
\begin{itemize}
\item a trait with a type parameter, e.g.\ \texttt{\textcolor{blue}{\footnotesize{}trait
MyTypeClass{[}T{]}}}{\footnotesize \par}
\item code that creates values of type \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass{[}T{]}}}
for various \texttt{\textcolor{blue}{\footnotesize{}T}}{\footnotesize \par}
\begin{itemize}
\item these values must be defined as \texttt{\textcolor{blue}{\footnotesize{}implicit}}
and made available via imports or in the \emph{companion objects}
for the specific types \texttt{\textcolor{blue}{\footnotesize{}T}}{\footnotesize \par}
\end{itemize}
\item some functions with an implicit argument of type \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass{[}T{]}}}{\footnotesize \par}
\begin{itemize}
\item laws for these functions may need to be enforced by tests
\end{itemize}
\end{itemize}
Usually, all information about the type \texttt{\textcolor{blue}{\footnotesize{}T}}
is contained in the TE value
\begin{itemize}
\item the trait \texttt{\textcolor{blue}{\footnotesize{}MyTypeClass{[}T{]}}}
contains all relevant PTVFs as \texttt{\textcolor{blue}{\footnotesize{}def}}'s
\item in simpler cases, TE can be a data type (not a trait with \texttt{\textcolor{blue}{\footnotesize{}def}}
methods)
\begin{itemize}
\item a trait with \texttt{\textcolor{blue}{\footnotesize{}def}} methods
is necessary for higher-order type functions
\end{itemize}
\end{itemize}
See example code
\end{frame}

\begin{frame}{Examples of type classes I}


\framesubtitle{Some simple PTFs and their use cases}
\begin{itemize}
\item A type \texttt{\textcolor{blue}{\footnotesize{}T}} is \textbf{pointed}
if there exists a function \texttt{\textcolor{blue}{\footnotesize{}point:\ T}}{\footnotesize \par}
\begin{itemize}
\item There is a special, somehow naturally selected value of that type
\end{itemize}
\item A type \texttt{\textcolor{blue}{\footnotesize{}T}} is a \textbf{semigroup}
if it has an associative binary operation
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~op(x:~T,~y:~T):~T}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item A type \texttt{\textcolor{blue}{\footnotesize{}T}} is a \textbf{monoid}
if there exist functions
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~zero{[}T{]}:~T}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}def~append{[}T{]}(x:~T,~y:~T):~T}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item such that the usual algebraic laws hold:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}append}} is associative
\item \texttt{\textcolor{blue}{\footnotesize{}append(zero, x) == append(x,
zero) == x}}{\footnotesize \par}
\end{itemize}
\end{itemize}
See examples of implementing the \texttt{\textcolor{blue}{\footnotesize{}Monoid}}
type class in various ways
\begin{itemize}
\item by using a case class as a PTTF
\item by combining \texttt{\textcolor{blue}{\footnotesize{}Pointed}} and
\texttt{\textcolor{blue}{\footnotesize{}Semigroup}}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Examples of type classes II}


\framesubtitle{Higher-order PTFs}
\begin{itemize}
\item A type constructor $F^{A}$ is a functor if it has a \texttt{\textcolor{blue}{\footnotesize{}map}} 
\begin{itemize}
\item or, equivalently, \texttt{\textcolor{blue}{\footnotesize{}fmap}} 
\item that satisfies the functor laws
\end{itemize}
\item We would like to write a generic function that tests the functor laws
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~checkFunctorLaws{[}F{[}\_{]},~A,~B,~C{]}():~Assertion~=~???}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item Need to get access to the function \texttt{\textcolor{blue}{\footnotesize{}map{[}A,
B{]}}} for \texttt{\textcolor{blue}{\footnotesize{}F{[}\_{]}}}{\footnotesize \par}
\item We treat \texttt{\textcolor{blue}{\footnotesize{}map}} as a PTVF whose
type domain is all functors \texttt{\textcolor{blue}{\footnotesize{}F{[}\_{]}}}:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~map{[}F{[}\_{]},~A,~B{]}(fa:~F{[}A{]},~f:~A~$\Rightarrow$~B):~F{[}B{]}~=~???}{\footnotesize \par}
\end{lyxcode}
\begin{itemize}
\item We constrain \texttt{\textcolor{blue}{\footnotesize{}F{[}\_{]}}} to
belong to the \texttt{\textcolor{blue}{\footnotesize{}Functor}} type
class
\begin{itemize}
\item by adding \texttt{\textcolor{blue}{\footnotesize{}implicit ev: Functor{[}F{]}}}{\footnotesize \par}
\begin{itemize}
\item here \texttt{\textcolor{blue}{\footnotesize{}Functor{[}F{]}}} is a
\emph{higher-order} PTTF
\end{itemize}
\end{itemize}
\end{itemize}
See test code for implementation and functor laws checking
\end{frame}

\begin{frame}{Worked examples I}

\begin{enumerate}
\item Define a PTVF \texttt{\textcolor{blue}{\footnotesize{}def bitsize{[}T{]}: Int}}
such that \texttt{\textcolor{blue}{\footnotesize{}bitsize{[}Int{]}}}
returns $32$ and \texttt{\textcolor{blue}{\footnotesize{}bitsize{[}Long{]}}}
returns $64$, but undefined on other types $T$
\item Define a monoid instance for the type $1+\left(\text{Int}\Rightarrow\text{Int}\right)$
\item If $A$ and $B$ are monoids, define monoid instance for $A\times B$
\item If $A$ is a monoid and $B$ is a semigroup then $A+B$ is a monoid
\item Define a functor instance for \texttt{\textcolor{blue}{\footnotesize{}type
F{[}T{]} = Seq{[}Try{[}T{]}{]}}}{\footnotesize \par}
\item If $F^{A}$ and $G^{A}$ are functors, define functor instance for
$F^{A}+G^{A}$ 
\item Define a \texttt{\textcolor{blue}{\footnotesize{}ContraFunctor}} type
class having \texttt{\textcolor{blue}{\footnotesize{}contrafmap}}:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~contrafmap{[}A,~B{]}(f:~B~$\Rightarrow$~A):~F{[}A{]}~$\Rightarrow$~F{[}B{]}~=~???}{\footnotesize \par}
\end{lyxcode}
Define a \texttt{\textcolor{blue}{\footnotesize{}ContraFunctor}} instance
for type constructor $C^{A}\equiv A\Rightarrow\text{Int}$\texttt{\textcolor{blue}{\footnotesize{} }}{\footnotesize \par}
\end{enumerate}
\end{frame}

\begin{frame}{Exercises I}

\begin{enumerate}
\item Define a PTVF \texttt{\textcolor{blue}{\footnotesize{}def isLong{[}T{]}: Boolean}}
that returns \texttt{\textcolor{blue}{\footnotesize{}true}} for \texttt{\textcolor{blue}{\footnotesize{}Long}}
and \texttt{\textcolor{blue}{\footnotesize{}Double}}, returns \texttt{\textcolor{blue}{\footnotesize{}false}}
for \texttt{\textcolor{blue}{\footnotesize{}Int}}, \texttt{\textcolor{blue}{\footnotesize{}Short}},
and \texttt{\textcolor{blue}{\footnotesize{}Float}}, otherwise undefined
\item Define a monoid instance for the type $\text{String}\times(1+\text{Int})$
\item If $A$ is a monoid and $R$ any type, define monoid instance for
$R\Rightarrow A$
\item If \texttt{\textcolor{blue}{\footnotesize{}S}} is a semigroup then
\texttt{\textcolor{blue}{\footnotesize{}Option{[}S{]}}} is a monoid
\item Define a functor instance for \texttt{\textcolor{blue}{\footnotesize{}type
F{[}T{]} = Future{[}Seq{[}T{]}{]}}}{\footnotesize \par}
\item If $F^{A}$ and $G^{A}$ are functors, define functor instance for
$F^{A}\times G^{A}$ 
\item Define a \texttt{\textcolor{blue}{\footnotesize{}ProFunctor}} type
class having \texttt{\textcolor{blue}{\footnotesize{}bimap}}:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~bimap{[}A,~B{]}(f:~A~$\Rightarrow$~B,~g:~B~$\Rightarrow$~A):~F{[}A{]}~$\Rightarrow$~F{[}B{]}~=~???}{\footnotesize \par}
\end{lyxcode}
Define a \texttt{\textcolor{blue}{\footnotesize{}ProFunctor}} instance
for type constructor $P^{A}\equiv A\Rightarrow\left(\text{Int}\Rightarrow A\right)$
\item Define a \texttt{\textcolor{blue}{\footnotesize{}Functor}} instance
for $F^{A}\Rightarrow G^{A}$ where $F^{A}$ is a contrafunctor and
$G^{A}$ is a functor\texttt{\textcolor{blue}{\footnotesize{} }}{\footnotesize \par}
\end{enumerate}
\end{frame}

\end{document}
