%% LyX 2.2.0 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{amsmath}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 % this default might be overridden by plain title style
 \newcommand\makebeamertitle{\frame{\maketitle}}%
 % (ERT) argument for the TOC
 \AtBeginDocument{%
   \let\origtableofcontents=\tableofcontents
   \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
   \def\gobbletableofcontents#1{\origtableofcontents}
 }
 \newenvironment{lyxcode}
   {\par\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \setlength{\listparindent}{0pt}% needed for AMS classes
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \normalfont\ttfamily}%
    \def\{{\char`\{}
    \def\}{\char`\}}
    \def\textasciitilde{\char`\~}
    \item[]}
   {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 4: Functors]{Chapter 4: Functors}
\subtitle{The Curry-Howard correspondence}
\author{Sergei Winitzki}
\date{December 24, 2017}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{navigation symbols}{}

\makeatother

\begin{document}
\frame{\titlepage}
\begin{frame}{``Container-like'' type constructors}

\begin{itemize}
\item Visualize \texttt{\textcolor{blue}{\footnotesize{}Seq{[}T{]}}} as
a container with some items of type \texttt{\textcolor{blue}{\footnotesize{}T}}{\footnotesize \par}
\begin{itemize}
\item How to formalize this idea as a property of \texttt{\textcolor{blue}{\footnotesize{}Seq}}?
\end{itemize}
\item Another example of a container: \texttt{\textcolor{blue}{\footnotesize{}Future{[}T{]}}}{\footnotesize \par}
\begin{itemize}
\item a value of type \texttt{\textcolor{blue}{\footnotesize{}T}} will be
available later, or may fail to arrive
\end{itemize}
\end{itemize}
Let us separate the ``bare container'' functionality from other
functionality
\begin{itemize}
\item A ``bare container'' will allow us to:
\begin{itemize}
\item manipulate items held within the container
\begin{itemize}
\item In FP, to ``manipulate items'' means to apply functions to values
\end{itemize}
\end{itemize}
\item ``Container holds items'' = we can apply a function to the items
\begin{itemize}
\item but the new items \emph{remain} within the same container!
\item need \texttt{\textcolor{blue}{\footnotesize{}map:\ Container{[}A{]}
$\Rightarrow$ (A $\Rightarrow$ B) $\Rightarrow$ Container{[}B{]}}}{\footnotesize \par}
\end{itemize}
\item A ``bare container'' will \emph{not} allow us to:
\begin{itemize}
\item make a new container out of a given set of items
\item read values out of the container
\item add more items into container, delete items from container
\item wait until items are available in container, etc.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{\texttt{Option{[}T{]}} as a container I}

\begin{itemize}
\item In the short notation: $\text{Option}^{A}=1+A$
\item The \texttt{\textcolor{blue}{\footnotesize{}map}} function is required
to have the type
\[
\text{map}^{A,B}:1+A\Rightarrow\left(A\Rightarrow B\right)\Rightarrow1+B
\]
\end{itemize}
Main questions:
\begin{itemize}
\item How to avoid ``information loss'' in this function?
\item Does this \texttt{\textcolor{blue}{\footnotesize{}map}} allow us to
``manipulate values within the container''?
\end{itemize}
\end{frame}

\begin{frame}{\texttt{Option{[}T{]}} as a container II}

Avoiding ``information loss'' means:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}map{[}A,A{]}(opt)(x$\Rightarrow$x)
== opt}} \textendash{} ``\textbf{identity law}'' for \texttt{\textcolor{blue}{\footnotesize{}map}}{\footnotesize \par}
\item We have two implementations of the type: 
\[
\text{map}^{[A,B]}=(1+a^{A})\Rightarrow(f^{A\Rightarrow B})=1+f(a)
\]
and
\[
\text{map}^{[A,B]}=(1+a^{A})\Rightarrow(f^{A\Rightarrow B})=1+0^{B}
\]
The second implementation has ``information loss''!
\item Short notation for code (type annotations are optional):
\end{itemize}
\begin{center}
\begin{tabular}{|c|c|}
\hline 
\textbf{Short notation} & \textbf{Scala code}\tabularnewline
\hline 
\hline 
$a^{A}$ & \texttt{\textcolor{blue}{\footnotesize{}val a: A}}\tabularnewline
\hline 
$f^{[A]\,B\Rightarrow C}$ & \texttt{\textcolor{blue}{\footnotesize{}def f{[}A{]}: B $\Rightarrow$
C ...}}\tabularnewline
\hline 
$a^{A}+b^{B}$ & \texttt{\textcolor{blue}{\footnotesize{}x: Either{[}A, B{]} match
\{...\}}}\tabularnewline
\hline 
$a^{A}+0^{B}$ & \texttt{\textcolor{blue}{\footnotesize{}Left(a):\ Either{[}A, B{]}}}\tabularnewline
\hline 
$1$ & \texttt{\textcolor{blue}{\footnotesize{}()}}\tabularnewline
\hline 
\end{tabular}
\par\end{center}

\end{frame}

\begin{frame}{\texttt{Option{[}T{]}} as a container III}

\begin{itemize}
\item Flip the two arguments in the type signature of \texttt{\textcolor{blue}{\footnotesize{}map}}:{\footnotesize{}
\[
\text{fmap}^{[A,B]}:\left(A\Rightarrow B\right)\Rightarrow\text{Option}^{A}\Rightarrow\text{Option}^{B}
\]
}{\footnotesize \par}
\item A function is ``\textbf{lifted}'' from $A\Rightarrow B$ to $\text{Option}^{A}\Rightarrow\text{Option}^{B}$
by \texttt{\textcolor{blue}{\footnotesize{}fmap}}:{\footnotesize{}
\[
\text{fmap}\left(f^{A\Rightarrow B}\right):\text{Option}^{A}\Rightarrow\text{Option}^{B}
\]
}{\footnotesize \par}
\item Being able to manipulate values means that functions behave normally
when lifted, i.e.\ when applied within the container
\item The standard properties of function composition are{\footnotesize{}
\begin{align*}
f^{A\Rightarrow B}\circ id^{B\Rightarrow B} & =f^{A\Rightarrow B}\\
id^{A\Rightarrow A}\circ f^{A\Rightarrow B} & =f^{A\Rightarrow B}\\
f^{A\Rightarrow B}\circ(g^{B\Rightarrow C}\circ h^{C\Rightarrow D}) & =(f^{A\Rightarrow B}\circ g^{B\Rightarrow C})\circ h^{C\Rightarrow D}
\end{align*}
}and should hold for the ``lifted'' functions as well!
\item The ``identity law'' already requires that {\footnotesize{}$\text{fmap}(\text{id}^{A\Rightarrow A})=\text{id}^{\text{Option}^{A}\Rightarrow\text{Option}^{A}}$}{\footnotesize \par}
\item It remains to require that \texttt{\textcolor{blue}{\footnotesize{}fmap}}
should preserve function composition:{\footnotesize{}
\[
\text{fmap}\left(f^{A\Rightarrow B}\circ g^{B\Rightarrow C}\right)=\text{fmap}\left(f^{A\Rightarrow B}\right)\circ\text{fmap}\left(g^{B\Rightarrow C}\right)
\]
}{\footnotesize \par}
\end{itemize}
\end{frame}

\begin{frame}{Functor: the definition}


\framesubtitle{An abstraction for ``bare container'' functionality}

A \textbf{functor} is:
\begin{itemize}
\item a type constructor with a type parameter, e.g.\ \texttt{\textcolor{blue}{\footnotesize{}MyType{[}T{]}}}{\footnotesize \par}
\item such that a function \texttt{\textcolor{blue}{\footnotesize{}map}}
or, equivalently, \texttt{\textcolor{blue}{\footnotesize{}fmap}} is
available:{\footnotesize{}
\begin{align*}
\text{map}^{[A,B]}: & \text{MyType}^{A}\Rightarrow\left(A\Rightarrow B\right)\Rightarrow\text{MyType}^{B}\\
\text{fmap}^{[A,B]}: & \left(A\Rightarrow B\right)\Rightarrow\text{MyType}^{A}\Rightarrow\text{MyType}^{B}
\end{align*}
}{\footnotesize \par}
\item such that the identity law and the composition law hold for any type
\texttt{\textcolor{blue}{\footnotesize{}T}}{\footnotesize \par}
\begin{itemize}
\item The laws are easier to formulate in terms of \texttt{\textcolor{blue}{\footnotesize{}fmap}}:\texttt{\textcolor{blue}{\footnotesize{}
\begin{align*}
\text{fmap}\left(\text{id}\right) & =\text{id}\\
\text{fmap}\left(f\circ g\right) & =\text{fmap}\left(f\right)\circ\text{fmap}\left(g\right)
\end{align*}
}}{\footnotesize \par}
\end{itemize}
\item Verify the laws for \texttt{\textcolor{blue}{\footnotesize{}Option{[}A{]}}}:
see test code
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~fmap{[}A,B{]}:~(A~$\Rightarrow$~B)~$\Rightarrow$~Option{[}A{]}~$\Rightarrow$~Option{[}B{]}~=~f~$\Rightarrow$~\{}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~Some(a)~$\Rightarrow$~Some(f(a))}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}~~case~None~$\Rightarrow$~None}{\footnotesize \par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize \par}
\end{lyxcode}
\end{frame}

\begin{frame}{Functor: examples}


\framesubtitle{(Almost) everything that has a ``\texttt{map}'' is a functor}
\begin{itemize}
\item Need to verify the laws!
\end{itemize}
Examples of functors in the Scala standard library:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}Option{[}T{]}}}{\footnotesize \par}
\item \texttt{\textcolor{blue}{\footnotesize{}Either{[}L, R{]} with respect
to R}}{\footnotesize \par}
\item \texttt{\textcolor{blue}{\footnotesize{}Seq{[}T{]} and Iterator{[}T{]} }}{\footnotesize \par}
\item \texttt{\textcolor{blue}{\footnotesize{}the many subtypes of Seq (Range,
List, Vector, IndexedSeq, etc.)}}{\footnotesize \par}
\item \texttt{\textcolor{blue}{\footnotesize{}Future{[}T{]}}}{\footnotesize \par}
\item \texttt{\textcolor{blue}{\footnotesize{}Try{[}T{]}}}{\footnotesize \par}
\item \texttt{\textcolor{blue}{\footnotesize{}Map{[}K, V{]} with respect
to V (using mapValues)}}{\footnotesize \par}
\end{itemize}
Example of non-functor that has a \texttt{\textcolor{blue}{\footnotesize{}map}}
in the standard library:
\begin{itemize}
\item \texttt{\textcolor{blue}{\footnotesize{}Set{[}T{]}}}{\footnotesize \par}
\end{itemize}
See example code
\end{frame}

\begin{frame}{Functors: the roadmap}

Specific functors will have methods for creating them, reading values
out of them, adding / removing items, waiting for items to arrive,
etc.

Main questions:
\begin{itemize}
\item Given a type, how to recognize whether it is a functor?
\item If so, how to implement the \texttt{\textcolor{blue}{\footnotesize{}map}}
function that satisfies the laws?
\item Can we build new functors out of given ones?
\end{itemize}
Other topics:
\begin{itemize}
\item Contrafunctors, profunctors, and type constructors that are neither
\item Implementing Functor instance using Cats
\item Implementing Functor instance for recursive types 
\item Functor typeclass derivation using Shapeless
\item Functions that are parameterized by a Functor type constructor
\item Examples of APIs that consume a functor, with type class constraint
\end{itemize}
\end{frame}

\begin{frame}{Worked examples}

\begin{enumerate}
\item Define 
\end{enumerate}
\end{frame}

\begin{frame}{Exercises}

\begin{enumerate}
\item Define type
\end{enumerate}
\end{frame}

\end{document}
