#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 6: Functor-lifted computations I]{Chapter 6: Computations lifted to a functor context I}
\subtitle{Filterable functors}
\author{Sergei Winitzki}
\date{January 21, 2018}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Itemize
Consider these possibly useful properties of containers 
\begin_inset Formula $C^{A}$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Can create an empty container
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{empty}^{A}:1\Rightarrow C^{A}$
\end_inset

 – 
\series bold
fillable
\end_layout

\begin_layout Itemize
Can create a container that holds a given value
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{wrap}^{A}:A\Rightarrow C^{A}$
\end_inset

 – 
\series bold
pointed
\end_layout

\begin_layout Itemize
Can extract an element from container
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{get}^{A}:C^{A}\Rightarrow A$
\end_inset

 – 
\series bold
co-pointed
\end_layout

\begin_layout Itemize
Can extract an element safely (even if the container is empty)
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{toOption}^{A}:C^{A}\Rightarrow1+A$
\end_inset

 – 
\series bold
extractable
\end_layout

\begin_layout Itemize
Can select element(s) satisfying a condition
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{withFilter}^{A}:C^{A}\Rightarrow\left(A\Rightarrow\text{Boolean}\right)\Rightarrow C^{A}$
\end_inset

 – 
\series bold
filterable
\end_layout

\end_deeper
\begin_layout Itemize
to formulate such properties, use fully type-parametric functions
\end_layout

\begin_deeper
\begin_layout Itemize
note: 
\begin_inset Formula $\text{Boolean}\equiv1+1$
\end_inset


\end_layout

\begin_layout Itemize
all functions have the form 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 with some functors 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $G$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
functions of this sort are called 
\series bold
natural transformations
\end_layout

\begin_layout Itemize
parametricity (naturality) is the property that holds automatically for
 all such functions
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Computations within a functor context
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula 
\[
\sum_{x\in\mathbb{Z};\:0\leq x\leq100;\:\cos x>0}\cos^{3}x\approx21.8
\]

\end_inset

Scala code:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
(0 to 100).map(math.cos(_)).filter(_ > 0).map(math.pow(_, 3)).sum
\end_layout

\end_deeper
\begin_layout Itemize
Using Scala's 
\family typewriter
\size footnotesize
\color blue
for
\family default
\size default
\color inherit
/
\family typewriter
\size footnotesize
\color blue
yield
\family default
\size default
\color inherit
 syntax (
\begin_inset Quotes eld
\end_inset

functor block
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size footnotesize
\color blue
for
\family default
\size default
\color inherit
 comprehension
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
(for { x 
\begin_inset Formula $\leftarrow$
\end_inset

 0 to 100
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    y = math.cos(x)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    if y > 0
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  } yield { math.pow(y, 3) }
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
).sum
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
(0 to 100).map { x 
\begin_inset Formula $\Rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   math.cos(x) }.filter { y 
\begin_inset Formula $\Rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   y > 0 }.map { y 
\begin_inset Formula $\Rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
     math.pow(y, 3)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  }.sum
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Functor block
\begin_inset Quotes erd
\end_inset

 is a syntax for manipulating data within a container
\end_layout

\begin_layout Itemize
A functor is a type constructor that has 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 such that the laws hold
\end_layout

\begin_layout Itemize
A 
\series bold
filterable functor
\series default
 is a functor that has a 
\family typewriter
\size footnotesize
\color blue
withFilter
\family default
\size default
\color inherit
 method
\end_layout

\begin_layout Itemize
Function type: 
\family typewriter
\size footnotesize
\color blue
withFilter(p:
\begin_inset space \space{}
\end_inset

A 
\begin_inset Formula $\Rightarrow$
\end_inset

 Boolean):
\begin_inset space \space{}
\end_inset

F[A] 
\begin_inset Formula $\Rightarrow$
\end_inset

 F[A]
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
What are the required laws for 
\family typewriter
\size footnotesize
\color blue
withFilter
\family default
\size default
\color inherit
?
\end_layout

\begin_layout Itemize
What data types are filterable functors?
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Filterable functors: Intuitions I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Itemize
Consider these possibly useful properties of containers 
\begin_inset Formula $C^{A}$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Can create an empty container
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{empty}^{A}:1\Rightarrow C^{A}$
\end_inset

 – 
\series bold
fillable
\end_layout

\begin_layout Itemize
Can create a container that holds a given value
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{wrap}^{A}:A\Rightarrow C^{A}$
\end_inset

 – 
\series bold
pointed
\end_layout

\begin_layout Itemize
Can extract an element from container
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{get}^{A}:C^{A}\Rightarrow A$
\end_inset

 – 
\series bold
co-pointed
\end_layout

\begin_layout Itemize
Can extract an element safely (even if the container is empty)
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{toOption}^{A}:C^{A}\Rightarrow1+A$
\end_inset

 – 
\series bold
extractable
\end_layout

\begin_layout Itemize
Can select element(s) satisfying a condition
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{withFilter}^{A}:C^{A}\Rightarrow\left(A\Rightarrow\text{Boolean}\right)\Rightarrow C^{A}$
\end_inset

 – 
\series bold
filterable
\end_layout

\end_deeper
\begin_layout Itemize
to formulate such properties, use fully type-parametric functions
\end_layout

\begin_deeper
\begin_layout Itemize
note: 
\begin_inset Formula $\text{Boolean}\equiv1+1$
\end_inset


\end_layout

\begin_layout Itemize
all functions have the form 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 with some functors 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $G$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
functions of this sort are called 
\series bold
natural transformations
\end_layout

\begin_layout Itemize
parametricity (naturality) is the property that holds automatically for
 all such functions
\end_layout

\end_inset

Intuition: a container that can hold 
\emph on
more or fewer
\emph default
 data items of type 
\begin_inset Formula $T$
\end_inset


\end_layout

\begin_layout Itemize
the 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 operation 
\emph on
may decrease
\emph default
 the number of data items held
\end_layout

\begin_layout Standard
Examples:
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
Option[T]
\family default
\size default
\color inherit
 
\begin_inset Formula $=1+T$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
Some(123).filter(_ > 0)
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
Some(123)
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
Some(123).filter(_ == 1)
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
None
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
Some(123).withFilter(_ == 1).map(identity)
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
None
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
List[T]
\family default
\size default
\color inherit
 
\begin_inset Formula $=1+T+T\times T+T\times T\times T+...$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
List(10, 20, 30).filter(_ > 10)
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
List(20, 30)
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
List(10, 20, 30).filter(_ == 1)
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
List()
\end_layout

\end_deeper
\begin_layout Standard
What we can learn from these examples:
\end_layout

\begin_layout Itemize
The data type must contain a 
\emph on
disjunction
\emph default
 having different counts of 
\begin_inset Formula $T$
\end_inset


\end_layout

\begin_layout Itemize
When the predicate 
\family typewriter
\size footnotesize
\color blue
p
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
false
\family default
\size default
\color inherit
 on some 
\begin_inset Formula $T$
\end_inset

 values, the remaining data goes to a part of the disjunction that has fewer
 
\begin_inset Formula $T$
\end_inset

 values
\end_layout

\begin_layout Itemize
Values 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
 are 
\emph on
algebraically
\emph default
 replaced by 
\begin_inset Formula $1$
\end_inset

 (a 
\family typewriter
\size footnotesize
\color blue
Unit
\family default
\size default
\color inherit
) when 
\family typewriter
\size footnotesize
\color blue
p(x) = false
\end_layout

\begin_layout Itemize
The container can become 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset

 as a result of filtering
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of filterable functors I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Consider these business requirements:
\end_layout

\begin_deeper
\begin_layout Itemize
One order can be placed on Tuesday and/or on Friday
\end_layout

\begin_layout Itemize
An order is approved if requested amount is less than $1,000
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class Orders[A](tue: Option[A], fri: Option[A]) {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  def withFilter(p: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 Boolean): Orders[A] = 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    Orders(tue.filter(p), fri.filter(p))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
Orders(Some(500), Some(2000)).withFilter(_ < 1000)
\end_layout

\begin_layout LyX-Code

\family roman
\size footnotesize
\color darkgray
// returns 
\family default
Orders(Some(500), None)
\end_layout

\begin_layout Itemize
The functor is 
\begin_inset Formula $F^{A}=(1+A)\times(1+A)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
When a value does not pass the filter, the 
\begin_inset Formula $A$
\end_inset

 is replaced by 
\begin_inset Formula $1$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Filtering is applied to both parts of the product type independently
\end_layout

\begin_layout Itemize
What if additional business requirements were given:
\end_layout

\begin_deeper
\begin_layout Itemize
(a) both orders must be approved, or else no orders can be placed
\begin_inset Newline newline
\end_inset

or
\end_layout

\begin_layout Itemize
(b) both orders can be placed if at least one of them is approved
\end_layout

\end_deeper
\begin_layout Itemize
Does this still qualify as 
\begin_inset Quotes eld
\end_inset

filtering
\begin_inset Quotes erd
\end_inset

?
\end_layout

\begin_deeper
\begin_layout Itemize
Need some laws to decide
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Filterable functors: Intuitions II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Intuition: computations in the functor block should 
\begin_inset Quotes eld
\end_inset

make sense
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
we should be able to reason correctly by looking at the program text
\end_layout

\end_deeper
\begin_layout Itemize
A schematic example of a functor block program:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
for { 
\family roman
\color darkgray
// computations under the 
\family default
List
\family roman
 functor
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  x 
\begin_inset Formula $\leftarrow$
\end_inset

 List(...) 
\family roman
\color darkgray
// the first line has 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\leftarrow$
\end_inset


\begin_inset Quotes erd
\end_inset

, other lines do not
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  y = f(x) 
\family roman
\color darkgray
// will become a 
\begin_inset Quotes eld
\end_inset


\family default
map(f)
\family roman

\begin_inset Quotes erd
\end_inset

 after compilation
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  if p1(y) 
\family roman
\color darkgray
// will become a 
\begin_inset Quotes eld
\end_inset


\family default
withFilter(p1)
\family roman

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  if p2(y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  z = g(x, y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  if q(x, y, z)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
} yield 
\family roman
\color darkgray
//  for all 
\family default
x
\family roman
 in list, such that conditions hold, compute this:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  k(x, y, z)
\end_layout

\end_deeper
\begin_layout Itemize
What we intuitively expect to be true about such programs:
\end_layout

\begin_deeper
\begin_layout Enumerate

\family typewriter
\size footnotesize
\color blue
y = f(x); if p(y);
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size footnotesize
\color blue
if p(f(x)); y = f(x);
\end_layout

\begin_layout Enumerate

\family typewriter
\size footnotesize
\color blue
if p1(y); if p2(y);
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size footnotesize
\color blue
if p1(y) && p2(y)
\end_layout

\begin_layout Enumerate
When a filter predicate 
\family typewriter
\size footnotesize
\color blue
p(x)
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
true
\family default
\size default
\color inherit
 for 
\emph on
all
\emph default
 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
, we can delete the line 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size footnotesize
\color blue
if p(x)
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 from the program with no change to the results
\end_layout

\begin_layout Enumerate
When a filter predicate 
\family typewriter
\size footnotesize
\color blue
p(x)
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
false
\family default
\size default
\color inherit
 for some 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
 then we must exclude
\emph on
 that
\emph default
 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
 from computations performed after 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size footnotesize
\color blue
if p(x)
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of filterable functors I: Checking the laws
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Properties 1 – 4 are equivalent to laws for 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit

\begin_inset Formula $^{(p\Rightarrow\text{Boolean})\Rightarrow F^{A}\Rightarrow F^{A}}$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\text{fmap}\left(f^{A\Rightarrow B}\right)\circ\text{filter}\left(p^{B\Rightarrow\text{Boolean}}\right)=\text{filter}\left(f\circ p\right)\circ\text{fmap}\left(f^{A\Rightarrow B}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\text{filter}\left(p_{1}^{A\Rightarrow\text{Boolean}}\right)\circ\text{filter}\left(p_{2}^{A\Rightarrow\text{Boolean}}\right)=\text{filter}\left(x\Rightarrow p_{1}(x)\text{ and }p_{2}(x)\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\text{filter}\left(x^{A}\Rightarrow\text{true}\right)=\text{id}$
\end_inset

 where the identity is of type 
\begin_inset Formula $F^{A}\Rightarrow F^{A}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\text{filter}\left(x^{A}\Rightarrow\text{false}\right)\circ\text{fmap}\left(f^{A\Rightarrow B}\right)=\text{fmap}\left(g^{A\Rightarrow B}\right)\circ\text{filter}\left(y^{B}\Rightarrow\text{false}\right)$
\end_inset

 
\emph on
for
\emph default
 
\emph on
all
\emph default
 
\begin_inset Formula $f^{A\Rightarrow B}$
\end_inset

 
\emph on
and
\emph default
 
\begin_inset Formula $g^{A\Rightarrow B}$
\end_inset

, showing that 
\begin_inset Quotes eld
\end_inset

computations do not use 
\begin_inset Formula $x$
\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Check the laws for Example I (
\begin_inset Quotes eld
\end_inset

Orders
\begin_inset Quotes erd
\end_inset

 with various business rules)
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Orders
\begin_inset Quotes erd
\end_inset

 with additional business rule (a) satisfies the laws
\end_layout

\begin_layout Itemize
See example code
\end_layout

\end_deeper
\begin_layout Itemize
Other constructions of filterable functors (to be checked later): 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $F^{A}\equiv1+H^{A}+A\times G^{A}$
\end_inset

 for any functors 
\begin_inset Formula $G^{A}$
\end_inset

 and 
\begin_inset Formula $H^{A}$
\end_inset

 (with 
\begin_inset Formula $G^{A}\neq0$
\end_inset

)
\end_layout

\begin_layout Itemize
\begin_inset Formula $F^{A}\equiv G^{H^{A}}$
\end_inset

 for any functor 
\begin_inset Formula $G^{A}$
\end_inset

 and any filtered functor 
\begin_inset Formula $H^{A}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $F^{A}\equiv H^{A}+A\times G^{A}$
\end_inset

 for any functor 
\begin_inset Formula $G^{A}$
\end_inset

 and any filtered functor 
\begin_inset Formula $H^{A}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $F^{A}\equiv G^{A}\Rightarrow H^{A}$
\end_inset

 for any 
\emph on
contrafunctor
\emph default
 
\begin_inset Formula $G^{A}$
\end_inset

 and any filtered functor 
\begin_inset Formula $H^{A}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
What are examples of functors that are 
\emph on
not
\emph default
 filterable?
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Orders
\begin_inset Quotes erd
\end_inset

 with additional business rule (b) violates law 2 for some 
\begin_inset Formula $p_{1,2}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $F^{A}\equiv A$
\end_inset

 – must define 
\begin_inset Formula $\text{filter}\left(p^{A\Rightarrow\text{Boolean}}\right)\left(x^{A}\right)=x$
\end_inset

, violating law 4
\end_layout

\begin_layout Itemize
\begin_inset Formula $F^{A}\equiv A\times\left(1+A\right)$
\end_inset

 – not able to remove the first 
\begin_inset Formula $A$
\end_inset

, violating law 4
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Filterable functors: The laws in depth I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Is there a more elegant formulation of the laws, easier to conceptualize?
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Note: the 
\begin_inset Formula $\text{Boolean}$
\end_inset

 type is isomorphic to 
\begin_inset Formula $1+1$
\end_inset

 or 
\family typewriter
\size footnotesize
\color blue
Option[Unit]
\family default
\size default
\color inherit
 
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Main intuition: When 
\family typewriter
\size footnotesize
\color blue
p(x) = false
\family default
\size default
\color inherit
, replace 
\family typewriter
\size footnotesize
\color blue
x:
\begin_inset space \space{}
\end_inset

A
\family default
\size default
\color inherit
 by 
\family typewriter
\size footnotesize
\color blue
1:
\begin_inset space \space{}
\end_inset

Unit
\family default
\size default
\color inherit
 in 
\family typewriter
\size footnotesize
\color blue
F[A]
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
(1) How to replace 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
 by 
\family typewriter
\size footnotesize
\color blue
1
\family default
\size default
\color inherit
 in 
\family typewriter
\size footnotesize
\color blue
F[A]
\family default
\size default
\color inherit
 without breaking the types?
\end_layout

\begin_layout Itemize
(2) How to transform the resulting type back to 
\family typewriter
\size footnotesize
\color blue
F[A]
\family default
\size default
\color inherit
?
\end_layout

\end_deeper
\begin_layout Itemize
We could do (1) if instead of the type 
\family typewriter
\size footnotesize
\color blue
F[A]
\family default
\size default
\color inherit
 we had 
\family typewriter
\size footnotesize
\color blue
F[Option[A]]
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
Map 
\begin_inset Formula $F^{A}$
\end_inset

 to 
\begin_inset Formula $F^{1+A}$
\end_inset

 using 
\begin_inset Formula $\text{fmap}\,(\text{Some}^{A\Rightarrow1+A}):F^{A}\Rightarrow F^{1+A}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
Doing (2) means defining a function 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 of type 
\begin_inset Formula $F^{1+A}\Rightarrow F^{A}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
standard library has 
\family typewriter
\size footnotesize
\color blue
flatten[T]:
\begin_inset space \space{}
\end_inset

Seq[Option[T]] 
\begin_inset Formula $\Rightarrow$
\end_inset

 Seq[T]
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Itemize
Express 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 through 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\text{filter}\left(p\right)=c^{F^{A}}\Rightarrow\text{flatten}\left(\text{fmap}(\text{optB}(p)(c)\right)$
\end_inset

 where we defined 
\family typewriter
\size footnotesize
\color blue
optB
\family default
\size default
\color inherit
 as
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def optB[T](p: T
\begin_inset Formula $\Rightarrow$
\end_inset

Boolean)(x: T): Option[T] = Some(x).filter(p)
\end_layout

\begin_layout Itemize
Law 4 is satisfied 
\emph on
automatically
\emph default
 if 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 is defined via 
\family typewriter
\size footnotesize
\color blue
flatten
\family default
\size default
\color inherit
!
\end_layout

\begin_deeper
\begin_layout Itemize
Seems like 
\begin_inset Formula $\text{flatten}\left(\text{fmap}(...)\right)$
\end_inset

 would be easier to handle than 
\family typewriter
\size footnotesize
\color blue
flatten
\end_layout

\begin_deeper
\begin_layout Standard
Define 
\family typewriter
\size footnotesize
\color blue
fmapOpt[F[_],A,B]
\family default
\size default
\color inherit

\begin_inset Formula $:\left(A\Rightarrow1+B\right)\Rightarrow F^{A}\Rightarrow F^{B}$
\end_inset

 as 
\begin_inset Formula $\text{fmapOpt}^{F,A,B}=f^{A\Rightarrow1+B}\Rightarrow q^{F^{A}}\Rightarrow\text{flatten}\left(\text{fmap}(f)(q)\right)$
\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Filterable functors: The laws in depth II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Define 
\family typewriter
\size footnotesize
\color blue
fmapOpt[F[_],A,B]
\family default
\size default
\color inherit

\begin_inset Formula $:\left(A\Rightarrow1+B\right)\Rightarrow F^{A}\Rightarrow F^{B}$
\end_inset

 as 
\begin_inset Formula 
\[
\text{fmapOpt}^{F,A,B}=f^{A\Rightarrow1+B}\Rightarrow q^{F^{A}}\Rightarrow\text{flatten}\left(\text{fmap}(f)(q)\right)
\]

\end_inset


\end_layout

\begin_layout Itemize
Express laws 1 – 3 in terms of 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
 and 
\begin_inset Formula $\psi^{A\Rightarrow1+A}\equiv\text{optB}\left(p\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Express 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 through 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
: 
\begin_inset Formula $\text{filter}\left(p\right)=\text{fmapOpt}^{F,A,A}\left(\psi\right)$
\end_inset


\end_layout

\begin_layout Itemize
Consider the expression needed for law 2: 
\begin_inset Formula $x\Rightarrow p_{1}(x)\text{ and }p_{2}(x)$
\end_inset


\end_layout

\begin_layout Itemize
Written in terms of 
\begin_inset Formula $\psi_{1}$
\end_inset

 and 
\begin_inset Formula $\psi_{2}$
\end_inset

, this is 
\begin_inset Formula $x^{A}\Rightarrow\psi_{1}(x)\text{.flatMap}\left(\psi_{2}\right)$
\end_inset


\end_layout

\begin_layout Itemize
Similar to composition of functions, except types are 
\begin_inset Formula $A\Rightarrow1+B$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is a particular case of 
\series bold
Kleisli composition
\series default
; the general case: 
\begin_inset Formula $\triangleright:\left(A\Rightarrow M^{B}\right)\Rightarrow\left(B\Rightarrow M^{C}\right)\Rightarrow\left(A\Rightarrow M^{C}\right)$
\end_inset

 ; we set 
\begin_inset Formula $M^{A}\equiv1+A$
\end_inset


\end_layout

\begin_layout Itemize
The 
\series bold
Kleisli identity
\series default
 function: 
\begin_inset Formula $\text{id}_{\triangleright}^{A\Rightarrow1+A}\equiv x\Rightarrow\text{Some}\left(x\right)$
\end_inset


\end_layout

\begin_layout Itemize
Kleisli composition is associative and respects the Kleisli identity!
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
 lifts a Kleisli function 
\begin_inset Formula $\psi^{A\Rightarrow1+B}$
\end_inset

 into the functor 
\begin_inset Formula $F$
\end_inset


\end_layout

\begin_layout Itemize
Only 2 laws are necessary for 
\family typewriter
\size footnotesize
\color blue
fmapOpt
\family default
\size default
\color inherit
:
\end_layout

\begin_deeper
\begin_layout Enumerate
Identity law 
\begin_inset Formula $\text{fmapOpt}\,(\text{id}_{\triangleright}^{A\Rightarrow1+A})=\text{id}^{F^{A}\Rightarrow F^{A}}$
\end_inset

 (covers old law 3)
\end_layout

\begin_layout Enumerate
Composition law: 
\begin_inset Formula $\text{fmapOpt}\left(f\right)\circ\text{fmapOpt}\left(g\right)=\text{fmapOpt}\left(f\triangleright g\right)$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples II: Checking the laws for filterable functor
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is the only way to implement 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 that satisfies the functor laws!
\end_layout

\begin_layout Standard
See test code for checking the functor laws
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples III: Filtered functors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is the only way to implement 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 that satisfies the functor laws!
\end_layout

\begin_layout Standard
See test code for checking the functor laws
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked examples: Checking the functor laws
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
To check that the 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 laws hold for 
\begin_inset Formula $F^{A}+G^{A}$
\end_inset

 if they hold for 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset


\end_layout

\begin_layout Itemize
From 
\begin_inset Formula $f:A\Rightarrow B$
\end_inset

, get 
\begin_inset Formula $\text{fmap}_{F}(f):F^{A}\Rightarrow F^{B}$
\end_inset

 and 
\begin_inset Formula $\text{fmap}_{G}(f):G^{A}\Rightarrow G^{B}$
\end_inset


\end_layout

\begin_layout Itemize
Define 
\begin_inset Formula $\text{fmap}_{F+G}(f)=(p^{F^{A}}+q^{G^{A}})\Rightarrow\text{fmap}_{F}(f)(p)+\text{fmap}_{G}(f)(q)$
\end_inset


\end_layout

\begin_layout Itemize
Identity law: 
\begin_inset Formula $f=id$
\end_inset

, so 
\begin_inset Formula $\text{fmap}_{F}(f)=id$
\end_inset

 and 
\begin_inset Formula $\text{fmap}_{G}(f)=id$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Hence we get 
\begin_inset Formula $\text{fmap}_{F+G}(id)(p+q)=id(p)+id(q)=p+q$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Composition law: 
\begin_inset Formula 
\begin{align*}
 & (\text{fmap}_{F+G}(f_{1})\circ\text{fmap}_{F+G}(f_{2}))(p+q)\\
=\  & \text{fmap}_{F+G}(f_{2})\left(\text{fmap}_{F}(f_{1})(p)+\text{fmap}_{G}(f_{1})(q)\right)\\
=\  & (\text{fmap}_{F}(f_{1})\circ\text{fmap}_{F}(f_{2}))(p)+\left(\text{fmap}_{G}(f_{1})\circ\text{fmap}_{G}(f_{2})\right)(q)\\
=\  & \text{fmap}_{F}(f_{1}\circ f_{2})(p)+\text{fmap}_{G}(f_{1}\circ f_{2})(q)\\
=\  & \text{fmap}_{F+G}(f_{1}\circ f_{2})(p+q)
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
Note how 
\begin_inset Formula $\text{fmap}_{F+G}(f)$
\end_inset

 works on each side of 
\begin_inset Formula $\left(p+q\right)$
\end_inset

 separately
\end_layout

\begin_layout Itemize
The laws would not hold if we mixed up some parts of 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Check that the 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 laws hold for 
\begin_inset Formula $F^{A}\times G^{A}$
\end_inset

 if they hold for 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset


\end_layout

\begin_layout Enumerate
Show that 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 is, in general, neither a functor nor a contrafunctor when both 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset

 are functors or both are contrafunctors (an example of suitable 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset

 will be sufficient)
\end_layout

\begin_layout Enumerate
Show that 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 is a contrafunctor if 
\begin_inset Formula $F^{A}$
\end_inset

 is a functor and 
\begin_inset Formula $G^{A}$
\end_inset

 is a contrafunctor, by checking the 
\family typewriter
\size footnotesize
\color blue
contrafmap
\family default
\size default
\color inherit
 laws for 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Other topics:
\end_layout

\begin_layout Itemize
Implementing Functor instance using Cats and Scalaz
\end_layout

\begin_layout Itemize
Implementing Functor instance for recursive types 
\end_layout

\begin_layout Itemize
Functor typeclass derivation using Shapeless
\end_layout

\begin_layout Itemize
Functions that are parameterized by a Functor type constructor
\end_layout

\begin_layout Itemize
Examples of APIs that consume a functor, with type class constraint
\end_layout

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
