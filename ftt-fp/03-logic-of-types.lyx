#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 3: Logic of Types]{Chapter 3: The Logic of Types}
\author{Sergei Winitzki}
\date{November 22, 2017}
\institute[ABTB]{Academy by the Bay}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Tuples with names, or 
\begin_inset Quotes eld
\end_inset

case classes
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Pair of values: 
\family typewriter
\size footnotesize
\color blue
val a:
\begin_inset space \space{}
\end_inset

(Int, String) = (123, "xyz")
\end_layout

\begin_layout Itemize
For 
\emph on
convenience
\emph default
, we can define a name for this type:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size footnotesize
\color blue
type MyPair = (Int, String); val a:
\begin_inset space \space{}
\end_inset

MyPair = (123, "xyz")
\end_layout

\begin_layout Itemize
We can define a name for each value and also for the type:
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

case class MySocks(size:
\begin_inset space \space{}
\end_inset

Double, color:
\begin_inset space \space{}
\end_inset

String)
\begin_inset Newline newline
\end_inset

val a:
\begin_inset space \space{}
\end_inset

MySocks = MySocks(10.5, "white")
\end_layout

\begin_layout Itemize
Case classes can be nested: 
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

case class BagOfSocks(socks:
\begin_inset space \space{}
\end_inset

MySocks, count:
\begin_inset space \space{}
\end_inset

Int)
\begin_inset Newline newline
\end_inset

val bag = BagOfSocks(MySocks(10.5, "white"), 6)
\end_layout

\begin_layout Itemize
Parts of the case class can be accessed by name: 
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

val c:
\begin_inset space \space{}
\end_inset

String = bag.socks.color
\end_layout

\begin_layout Itemize
Parts can be given in any order by using names:
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

val y = MySocks(color = "black", size = 11.0) 
\end_layout

\begin_layout Itemize
Default values can be defined for parts: 
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

case class Shirt(color:
\begin_inset space \space{}
\end_inset

String = "blue", hasHoles:
\begin_inset space \space{}
\end_inset

Boolean = false)
\begin_inset Newline newline
\end_inset

val sock = Shirt(hasHoles = true)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Tuples with one element and with zero elements
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A tuple type expression 
\family typewriter
\size footnotesize
\color blue
(Int, String)
\family default
\size default
\color inherit
 is special syntax for parameterized type 
\family typewriter
\size footnotesize
\color blue
Tuple2[Int, String]
\end_layout

\begin_layout Itemize
Case class with no parts is called a 
\begin_inset Quotes eld
\end_inset

case object
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
What are tuples with one element or with zero elements?
\end_layout

\begin_deeper
\begin_layout Itemize
There is no 
\family typewriter
\size footnotesize
\color blue
Tuple0
\family default
\size default
\color inherit
 â€“ it is a special type called 
\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tuples
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Case classes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(123, "xyz"):
\begin_inset space \space{}
\end_inset

Tuple2[Int, String]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
case class A(x:
\begin_inset space \space{}
\end_inset

Int, y:
\begin_inset space \space{}
\end_inset

String)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(123,):
\begin_inset space \space{}
\end_inset

Tuple1[Int]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
case class B(z:
\begin_inset space \space{}
\end_inset

Int)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(): Unit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
case object C
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Case classes can have one or more type parameters: 
\begin_inset Newline newline
\end_inset


\family typewriter
\size footnotesize
\color blue
case class Pairs[A, B](left:
\begin_inset space \space{}
\end_inset

A, right:
\begin_inset space \space{}
\end_inset

B, count:
\begin_inset space \space{}
\end_inset

Int)
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size footnotesize
\color blue
Tuple
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 types could be defined by this code:
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

case class Tuple2[A, B](_1:
\begin_inset space \space{}
\end_inset

A, _2:
\begin_inset space \space{}
\end_inset

B)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Pattern-matching syntax for case classes
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Scala allows pattern matching in two places:
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
val 
\family default
\emph on
pattern
\family typewriter
\emph default
 = ...

\family default
\size default
\color inherit
 (value assignment)
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
case 
\family default
\emph on
pattern
\family typewriter
\emph default
 
\family default

\begin_inset Formula $\Rightarrow$
\end_inset


\family typewriter
 ...

\family default
\size default
\color inherit
 (partial function)
\end_layout

\begin_layout Standard
Examples with case classes:
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
val a = MySocks(10.5, "white")
\begin_inset Newline newline
\end_inset

val MySocks(x, y) = a
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
val f:
\begin_inset space \space{}
\end_inset

BagOfSocks
\begin_inset Formula $\Rightarrow$
\end_inset

Int = { case BagOfSocks(MySocks(s, c), z)
\begin_inset Formula $\Rightarrow$
\end_inset

...}
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
def f(b:
\begin_inset space \space{}
\end_inset

BagOfSocks):
\begin_inset space \space{}
\end_inset

String = b match { 
\begin_inset Newline newline
\end_inset


\begin_inset space \space{}
\end_inset

 
\begin_inset space \space{}
\end_inset

case BagOfSocks(MySocks(s, c), z) 
\begin_inset Formula $\Rightarrow$
\end_inset

 c
\begin_inset Newline newline
\end_inset

}
\end_layout

\begin_layout Itemize
Note: 
\family typewriter
\size footnotesize
\color blue
s
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
c
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
z
\family default
\size default
\color inherit
 are defined as 
\series bold
pattern variables
\series default
 of correct types
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Disjunction type: 
\family typewriter
Either[A, B]
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Example: 
\family typewriter
\size footnotesize
\color blue
Either[String, Int]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Represents a value that is 
\emph on
either
\emph default
 a 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 or an 
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
 (but not both)
\end_layout

\begin_layout Itemize
Example values: 
\family typewriter
\size footnotesize
\color blue
Left("blah")
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
Right(123)
\end_layout

\begin_layout Itemize
Use pattern matching to distinguish 
\begin_inset Quotes eld
\end_inset

left
\begin_inset Quotes erd
\end_inset

 from 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def logError(x:
\begin_inset space \space{}
\end_inset

Either[String, Int]):
\begin_inset space \space{}
\end_inset

Int = x match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Left(error) 
\begin_inset Formula $\Rightarrow$
\end_inset

 println(s"Got error: $error"); -1
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Right(res) 
\begin_inset Formula $\Rightarrow$
\end_inset

 res
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\family sans
\color gray
 // Left(
\begin_inset Quotes eld
\end_inset

blah
\begin_inset Quotes erd
\end_inset

) and Right(123) are possible values of type Either[String, Int]
\end_layout

\begin_layout Itemize
Now 
\family typewriter
\size footnotesize
\color blue
logError(Right(123))
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
123
\family default
\size default
\color inherit
 while 
\family typewriter
\size footnotesize
\color blue
logError(Left("bad result"))
\family default
\size default
\color inherit
 prints the error and returns 
\family typewriter
\size footnotesize
\color blue
-1
\end_layout

\begin_layout Itemize
The 
\family typewriter
\size footnotesize
\color blue
case
\family default
\size default
\color inherit
 expression chooses among possible values of a given type
\end_layout

\begin_deeper
\begin_layout Itemize
Note the similarity with this code:
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f(x: Int): Int = x match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case 0 
\begin_inset Formula $\Rightarrow$
\end_inset

 println(s"error: must be nonzero"); -1
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case 1 
\begin_inset Formula $\Rightarrow$
\end_inset

 println(s"error: must be greater than 1"); -1
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case res 
\begin_inset Formula $\Rightarrow$
\end_inset

 res
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\family sans
\color gray
 //0 and 1 are possible values of type Int
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
More general disjunction types: using case classes
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
In a future version of Scala 3, there is a short syntax for disjunction
 types:
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
type MyIntOrStr = Int | String
\end_layout

\begin_layout Itemize
more generally, 
\family typewriter
\size footnotesize
\color blue
type MyType = List[Int] | Boolean | MySocks
\end_layout

\begin_layout Standard
For now, in Scala 2, we use the 
\begin_inset Quotes eld
\end_inset

long syntax
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait MyType
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class HaveListInt(x: List[Int]) extends MyType
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class HaveBool(b: Boolean) extends MyType
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class HaveSocks(socks: MySocks) extends MyType
\end_layout

\begin_layout Standard
Pattern-matching example:
\family typewriter
\size footnotesize
\color blue
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
exa***
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Types and propositional logic
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Tuple of functions:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size footnotesize
\color blue
val q:
\begin_inset space \space{}
\end_inset

(Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int, Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int) = (x 
\begin_inset Formula $\Rightarrow$
\end_inset

 x + 1, x 
\begin_inset Formula $\Rightarrow$
\end_inset

 x - 1)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Summary
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
What problems can we solve now?
\end_layout

\begin_deeper
\begin_layout Itemize
Compute mathematical expressions involving sums, products, and quantifiers,
 based on integer ranges (such as 
\begin_inset Formula $\sum_{k=1}^{n}f(k)$
\end_inset

 etc.)
\end_layout

\begin_layout Itemize
Implement functions that take or return other functions
\end_layout

\begin_layout Itemize
Work on collections using 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 and other library methods
\end_layout

\end_deeper
\begin_layout Itemize
What kinds of problems are not solved with these tools?
\end_layout

\begin_deeper
\begin_layout Itemize
Compute the smallest 
\begin_inset Formula $n$
\end_inset

 such that 
\begin_inset Formula $f(f(f(...f(1)...)>1000$
\end_inset

, where the function 
\begin_inset Formula $f$
\end_inset

 is applied 
\begin_inset Formula $n$
\end_inset

 times.
\end_layout

\begin_layout Itemize
Find the 
\begin_inset Formula $k$
\end_inset

-th largest element in an (unsorted) array of integers.
\end_layout

\begin_layout Itemize
Perform binary search over a sorted array.
\end_layout

\end_deeper
\begin_layout Itemize
Why can't we solve such problems yet?
\end_layout

\begin_deeper
\begin_layout Itemize
Because we can't yet put 
\emph on
mathematical induction
\emph default
 into code
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Define a function of type 
\family typewriter
\size footnotesize
\color blue
Seq[Double] => Seq[Double]
\family default
\size default
\color inherit
 that 
\begin_inset Quotes eld
\end_inset

normalizes
\begin_inset Quotes erd
\end_inset

 the sequence: it finds the element having the max.
\begin_inset space ~
\end_inset

absolute value and, if that value is nonzero, divides all elements by that
 factor.
\end_layout

\begin_layout Enumerate
Define a function of type 
\family typewriter
\size footnotesize
\color blue
Seq[Seq[Int]] => Seq[Seq[Int]]
\family default
\size default
\color inherit
 that adds 20 to every element of every inner sequence.
\end_layout

\begin_layout Enumerate
An integer 
\begin_inset Formula $n$
\end_inset

 is called 
\begin_inset Quotes eld
\end_inset

3-factor
\begin_inset Quotes erd
\end_inset

 if it is divisible by only three different integers 
\begin_inset Formula $j$
\end_inset

 such that 
\begin_inset Formula $2\leq j<n$
\end_inset

.
 Compute the set of all 
\begin_inset Quotes eld
\end_inset

3-factor
\begin_inset Quotes erd
\end_inset

 integers 
\begin_inset Formula $n$
\end_inset

 among 
\begin_inset Formula $n\in[1,...,1000]$
\end_inset

 .
\end_layout

\begin_layout Enumerate
Given a function 
\begin_inset Formula $f$
\end_inset

 of type 
\family typewriter
\size footnotesize
\color blue
Int => Boolean
\family default
\size default
\color inherit
, an integer 
\begin_inset Formula $n$
\end_inset

 is called 
\begin_inset Quotes eld
\end_inset

3-
\begin_inset Formula $f$
\end_inset


\begin_inset Quotes erd
\end_inset

 if there are only three different integers 
\begin_inset Formula $j\in[1,...,n]$
\end_inset

 such that 
\begin_inset Formula $f(j)$
\end_inset

 returns 
\family typewriter
\size footnotesize
\color blue
true
\family default
\size default
\color inherit
.
 Define a function that takes 
\begin_inset Formula $f$
\end_inset

 as an argument and returns a sequence of all 
\begin_inset Quotes eld
\end_inset

3-
\begin_inset Formula $f$
\end_inset


\begin_inset Quotes erd
\end_inset

 integers among 
\begin_inset Formula $n\in[1,...,1000]$
\end_inset

.
 What is the type of that function? Rewrite Exercise
\begin_inset space ~
\end_inset

3 using that function.
\end_layout

\begin_layout Enumerate
Define a function that takes two functions 
\family typewriter
\size footnotesize
\color blue
f:
\begin_inset space ~
\end_inset

Int => Double
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
g:
\begin_inset space ~
\end_inset

Double => String
\family default
\size default
\color inherit
 as arguments, and returns a new function that computes the functional compositi
on of 
\family typewriter
\size footnotesize
\color blue
f
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
g
\family default
\size default
\color inherit
.
\end_layout

\end_deeper
\begin_layout Frame

\end_layout

\end_body
\end_document
