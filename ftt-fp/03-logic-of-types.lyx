#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 3: Logic of Types]{Chapter 3: The Logic of Types}
\author{Sergei Winitzki}
\date{November 22, 2017}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{navigation symbols}{}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Types and syntax of functions returning functions
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
\begin_inset Quotes eld
\end_inset

Curried functions
\begin_inset Quotes erd
\end_inset

 in Scala
\end_layout

\begin_layout Itemize
A function that returns a function:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def logWith(topic: String): (String 
\begin_inset Formula $\Rightarrow$
\end_inset

 Unit) = {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   x 
\begin_inset Formula $\Rightarrow$
\end_inset

 println(s"$topic: $x")
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize
Calling this function:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val statusLogger: (String 
\begin_inset Formula $\Rightarrow$
\end_inset

 Unit) = logWith("Result status")
\begin_inset Newline newline
\end_inset

 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
primaryLogger("success")
\end_layout

\begin_layout Itemize
One-line syntax for calling: 
\family typewriter
\size footnotesize
\color blue
logWith("Result status")("success")
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Alternative syntax (
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Curried"
target "https://en.wikipedia.org/wiki/Currying"

\end_inset


\begin_inset Quotes erd
\end_inset

 function): 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val logWith: String 
\begin_inset Formula $\Rightarrow$
\end_inset

 String 
\begin_inset Formula $\Rightarrow$
\end_inset

 Unit = 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  topic 
\begin_inset Formula $\Rightarrow$
\end_inset

 x 
\begin_inset Formula $\Rightarrow$
\end_inset

 println(s"$topic: $x")
\end_layout

\begin_layout Itemize
Syntax convention: 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue

\begin_inset Formula $\Rightarrow$
\end_inset

 y
\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue

\begin_inset Formula $\Rightarrow$
\end_inset


\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue
z
\family default
\size default
\color inherit
 means 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue

\begin_inset Formula $\Rightarrow$
\end_inset

 (y
\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue

\begin_inset Formula $\Rightarrow$
\end_inset


\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue
z)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Functions with fully parametric types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
\begin_inset Quotes eld
\end_inset

No argument type left non-parametric
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Compare these two functions (note tuple type syntax):
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def hypothenuse = (x: Double, y: Double) 
\begin_inset Formula $\Rightarrow$
\end_inset

 math.sqrt(x*x + y*y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def swap: ((Double, Double)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (Double, Double) =
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  { case (x, y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (y, x) } 
\end_layout

\begin_layout Itemize
We can fully parameterize the argument types for 
\family typewriter
\size footnotesize
\color blue
swap
\family default
\size default
\color inherit
:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def swap[X, Y]: ((X, Y)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (Y, X) = { case (x, y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (y, x) } 
\end_layout

\begin_layout Itemize
(The first function is too specific to generalize the argument types.)
\end_layout

\begin_layout Itemize
Note: Scala does not support a 
\family typewriter
\size footnotesize
\color blue
val
\family default
\size default
\color inherit
 with a parametric type
\end_layout

\begin_deeper
\begin_layout Itemize
Instead we can use 
\family typewriter
\size footnotesize
\color blue
def
\family default
\size default
\color inherit
 or parametric classes/traits
\end_layout

\end_deeper
\begin_layout Itemize
More examples:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def identity[T]: (T 
\begin_inset Formula $\Rightarrow$
\end_inset

 T) = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 x
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def const[C, X]: (C 
\begin_inset Formula $\Rightarrow$
\end_inset

 X 
\begin_inset Formula $\Rightarrow$
\end_inset

 C) = c 
\begin_inset Formula $\Rightarrow$
\end_inset

 x 
\begin_inset Formula $\Rightarrow$
\end_inset

 c
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def compose[X, Y, Z](f: X 
\begin_inset Formula $\Rightarrow$
\end_inset

 Y, g: Y 
\begin_inset Formula $\Rightarrow$
\end_inset

 Z): X 
\begin_inset Formula $\Rightarrow$
\end_inset

 Z = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 g(f(x))
\end_layout

\begin_layout Itemize
Functions with fully parametric types 
\emph on
are
\emph default
 actually useful!
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked examples
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
For the functions 
\family typewriter
\size footnotesize
\color blue
const
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
identity
\family default
\size default
\color inherit
 defined above, what is 
\family typewriter
\size footnotesize
\color blue
const(identity)
\family default
\size default
\color inherit
 and what is its type? Write out the type parameters.
\end_layout

\begin_layout Itemize
Define a function 
\family typewriter
\size footnotesize
\color blue
twice
\family default
\size default
\color inherit
 that takes a function 
\begin_inset Formula $f$
\end_inset

 as its argument and returns a 
\emph on
function
\emph default
 that applies 
\begin_inset Formula $f$
\end_inset

 twice.
 For example, 
\family typewriter
\size footnotesize
\color blue
twice(x
\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue

\begin_inset Formula $\Rightarrow$
\end_inset


\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue
x+3)
\family default
\size default
\color inherit
 should return a function equivalent to 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue

\begin_inset Formula $\Rightarrow$
\end_inset


\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue
x+6
\family default
\size default
\color inherit
.
 Find the type of 
\family typewriter
\size footnotesize
\color blue
twice.
\end_layout

\begin_layout Itemize
What does 
\family typewriter
\size footnotesize
\color blue
twice(twice)
\family default
\size default
\color inherit
 do? Test your answer on the expression 
\family typewriter
\size footnotesize
\color blue
twice(twice[Int])(x
\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue

\begin_inset Formula $\Rightarrow$
\end_inset


\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue
x+3)(10)
\family default
\size default
\color inherit
.
 What are the type parameters here?
\end_layout

\begin_layout Itemize
Implement a function that applies a given function 
\begin_inset Formula $f$
\end_inset

 repeatedly to an initial value 
\begin_inset Formula $x_{0}$
\end_inset

, until a given condition function 
\family typewriter
\size footnotesize
\color blue
cond
\family default
\size default
\color inherit
 returns true:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def converge[X](f: X 
\begin_inset Formula $\Rightarrow$
\end_inset

 X, x0: X, cond: X 
\begin_inset Formula $\Rightarrow$
\end_inset

 Boolean): X = ???
\end_layout

\begin_layout Itemize
Take a function with two arguments, fix the value of the first argument,
 and return the function of the remaining one argument.
 Define this operation as a function with fully parametric types:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def firstArg[X, Y, Z](f: (X, Y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Z, x0: X): Y 
\begin_inset Formula $\Rightarrow$
\end_inset

 Z = ???
\end_layout

\begin_layout Itemize
Infer missing types: 
\family typewriter
\size footnotesize
\color blue
def p[
\family default
\size default
\color inherit
...
\family typewriter
\size footnotesize
\color blue
]:
\family default
\size default
\color inherit
...

\family typewriter
\size footnotesize
\color blue
 = f 
\begin_inset Formula $\Rightarrow$
\end_inset

 f(2)
\family default
\size default
\color inherit
.
 Does 
\family typewriter
\size footnotesize
\color blue
f(f)
\family default
\size default
\color inherit
 compile?
\end_layout

\begin_layout Itemize
Infer missing types: 
\family typewriter
\size footnotesize
\color blue
def p[
\family default
\size default
\color inherit
...
\family typewriter
\size footnotesize
\color blue
]:
\family default
\size default
\color inherit
...

\family typewriter
\size footnotesize
\color blue
 = f 
\begin_inset Formula $\Rightarrow$
\end_inset

 g 
\begin_inset Formula $\Rightarrow$
\end_inset

 g(f)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
For the function 
\family typewriter
\size footnotesize
\color blue
identity
\family default
\size default
\color inherit
 defined above, what is 
\family typewriter
\size footnotesize
\color blue
identity(identity)
\family default
\size default
\color inherit
 and what is its type? Same question for 
\family typewriter
\size footnotesize
\color blue
identity(const)
\family default
\size default
\color inherit
.
 
\end_layout

\begin_layout Itemize
For the function 
\family typewriter
\size footnotesize
\color blue
const
\family default
\size default
\color inherit
 above, what is 
\family typewriter
\size footnotesize
\color blue
const(const)
\family default
\size default
\color inherit
, what is its type?
\end_layout

\begin_layout Itemize
For the function 
\family typewriter
\size footnotesize
\color blue
twice
\family default
\size default
\color inherit
 above, what does 
\family typewriter
\size footnotesize
\color blue
twice(twice(twice)))
\family default
\size default
\color inherit
 do? Test your answer on an example.
\end_layout

\begin_layout Itemize
Define a function 
\family typewriter
\size footnotesize
\color blue
thrice
\family default
\size default
\color inherit
 that applies its argument function 3 times, similarly to 
\family typewriter
\size footnotesize
\color blue
twice
\family default
\size default
\color inherit
.
 What does 
\family typewriter
\size footnotesize
\color blue
thrice(thrice(thrice)))
\family default
\size default
\color inherit
 do?
\end_layout

\begin_layout Itemize
Define a function 
\family typewriter
\size footnotesize
\color blue
ence
\family default
\size default
\color inherit
 that applies a given function 
\begin_inset Formula $n$
\end_inset

 times.
\end_layout

\begin_layout Itemize
Take a function with two arguments, and define a function of these two arguments
 swapped.
 Package this functionality as a function 
\family typewriter
\size footnotesize
\color blue
swapFunc
\family default
\size default
\color inherit
 with fully parametric types.
 To test: 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f(x: Int, y: Int) = x - y
\family sans
\color gray
 // check that f(10, 2) gives 8
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val g = swapFunc(f)
\family sans
\color gray
  // now check that g(10, 2) gives – 8
\end_layout

\begin_layout Itemize
Infer missing types: 
\family typewriter
\size footnotesize
\color blue
def r[
\family default
\size default
\color inherit
...
\family typewriter
\size footnotesize
\color blue
]:
\family default
\size default
\color inherit
...

\family typewriter
\size footnotesize
\color blue
 = f 
\begin_inset Formula $\Rightarrow$
\end_inset

 f(g 
\begin_inset Formula $\Rightarrow$
\end_inset

 g(f))
\end_layout

\begin_layout Itemize
Infer missing types: 
\family typewriter
\size footnotesize
\color blue
def s[
\family default
\size default
\color inherit
...
\family typewriter
\size footnotesize
\color blue
]:
\family default
\size default
\color inherit
...

\family typewriter
\size footnotesize
\color blue
 = f 
\begin_inset Formula $\Rightarrow$
\end_inset

 g 
\begin_inset Formula $\Rightarrow$
\end_inset

 g(x 
\begin_inset Formula $\Rightarrow$
\end_inset

 f(g(x)))
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Tuples with names: 
\begin_inset Quotes eld
\end_inset

case classes
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Pair of values: 
\family typewriter
\size footnotesize
\color blue
val a:
\begin_inset space \space{}
\end_inset

(Int, String) = (123, "xyz")
\end_layout

\begin_layout Itemize
For convenience, we can define a name for this type:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size footnotesize
\color blue
type MyPair = (Int, String); val a:
\begin_inset space \space{}
\end_inset

MyPair = (123, "xyz")
\end_layout

\begin_layout Itemize
We can define a name for each value and also for the type:
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

case class MySocks(size:
\begin_inset space \space{}
\end_inset

Double, color:
\begin_inset space \space{}
\end_inset

String)
\begin_inset Newline newline
\end_inset

val a:
\begin_inset space \space{}
\end_inset

MySocks = MySocks(10.5, "white")
\end_layout

\begin_layout Itemize
Case classes can be nested: 
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

case class BagOfSocks(socks:
\begin_inset space \space{}
\end_inset

MySocks, count:
\begin_inset space \space{}
\end_inset

Int)
\begin_inset Newline newline
\end_inset

val bag = BagOfSocks(MySocks(10.5, "white"), 6)
\end_layout

\begin_layout Itemize
Parts of the case class can be accessed by name: 
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

val c:
\begin_inset space \space{}
\end_inset

String = bag.socks.color
\end_layout

\begin_layout Itemize
Parts can be given in any order by using names:
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

val y = MySocks(color = "black", size = 11.0) 
\end_layout

\begin_layout Itemize
Default values can be defined for parts: 
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

case class Shirt(color:
\begin_inset space \space{}
\end_inset

String = "blue", hasHoles:
\begin_inset space \space{}
\end_inset

Boolean = false)
\begin_inset Newline newline
\end_inset

val sock = Shirt(hasHoles = true)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Tuples with one element and with zero elements
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A tuple type expression 
\family typewriter
\size footnotesize
\color blue
(Int, String)
\family default
\size default
\color inherit
 is special syntax for parameterized type 
\family typewriter
\size footnotesize
\color blue
Tuple2[Int, String]
\end_layout

\begin_layout Itemize
Case class with no parts is called a 
\begin_inset Quotes eld
\end_inset

case object
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
What are tuples with one element or with zero elements?
\end_layout

\begin_deeper
\begin_layout Itemize
There is no 
\family typewriter
\size footnotesize
\color blue
Tuple0
\family default
\size default
\color inherit
 – it is a special type called 
\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tuples
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Case classes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(123, "xyz"):
\begin_inset space \space{}
\end_inset

Tuple2[Int, String]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
case class A(x:
\begin_inset space \space{}
\end_inset

Int, y:
\begin_inset space \space{}
\end_inset

String)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(123,):
\begin_inset space \space{}
\end_inset

Tuple1[Int]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
case class B(z:
\begin_inset space \space{}
\end_inset

Int)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(): Unit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
case object C
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Case classes can have one or more type parameters: 
\begin_inset Newline newline
\end_inset


\family typewriter
\size footnotesize
\color blue
case class Pairs[A, B](left:
\begin_inset space \space{}
\end_inset

A, right:
\begin_inset space \space{}
\end_inset

B, count:
\begin_inset space \space{}
\end_inset

Int)
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size footnotesize
\color blue
Tuple
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 types could be defined by this code:
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

case class Tuple2[A, B](_1:
\begin_inset space \space{}
\end_inset

A, _2:
\begin_inset space \space{}
\end_inset

B)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Pattern-matching syntax for case classes
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Scala allows pattern matching in two places:
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
val 
\family default
\emph on
pattern
\family typewriter
\emph default
 = ...

\family default
\size default
\color inherit
 (value assignment)
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
case 
\family default
\emph on
pattern
\family typewriter
\emph default
 
\family default

\begin_inset Formula $\Rightarrow$
\end_inset


\family typewriter
 ...

\family default
\size default
\color inherit
 (partial function)
\end_layout

\begin_layout Standard
Examples with case classes:
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
val a = MySocks(10.5, "white")
\begin_inset Newline newline
\end_inset

val MySocks(x, y) = a
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
val f:
\begin_inset space \space{}
\end_inset

BagOfSocks
\begin_inset Formula $\Rightarrow$
\end_inset

Int = { case BagOfSocks(MySocks(s, c), z)
\begin_inset Formula $\Rightarrow$
\end_inset

...}
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
def f(b:
\begin_inset space \space{}
\end_inset

BagOfSocks):
\begin_inset space \space{}
\end_inset

String = b match { 
\begin_inset Newline newline
\end_inset


\begin_inset space \space{}
\end_inset

 
\begin_inset space \space{}
\end_inset

case BagOfSocks(MySocks(s, c), z) 
\begin_inset Formula $\Rightarrow$
\end_inset

 c
\begin_inset Newline newline
\end_inset

}
\end_layout

\begin_layout Itemize
Note: 
\family typewriter
\size footnotesize
\color blue
s
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
c
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
z
\family default
\size default
\color inherit
 are defined as 
\series bold
pattern variables
\series default
 of correct types
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Disjunction types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Motivational examples:
\end_layout

\begin_deeper
\begin_layout Itemize
The roots of a quadratic equation are either a pair, or one, or none
\end_layout

\begin_layout Itemize
Binary search gives either a found value and an index, or nothing
\end_layout

\begin_layout Itemize
Computations that give a value or an error with a text message
\end_layout

\begin_layout Itemize
Computer game states: several kinds of rooms, types players, etc.
\end_layout

\begin_deeper
\begin_layout Itemize
Each kind of room may have different sets of properties
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
We would like to be able to represent 
\emph on
disjunctions
\emph default
 of sets
\end_layout

\begin_deeper
\begin_layout Itemize
A value that is 
\emph on
either
\emph default
 
\family typewriter
\size footnotesize
\color blue
(Complex, Complex)
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
Complex
\family default
\size default
\color inherit
 or empty 
\family typewriter
\size footnotesize
\color blue
()
\end_layout

\begin_layout Itemize
A value that is 
\emph on
either
\emph default
 
\family typewriter
\size footnotesize
\color blue
(Int, Int)
\family default
\size default
\color inherit
 or empty 
\family typewriter
\size footnotesize
\color blue
()
\end_layout

\begin_layout Itemize
A value that is 
\emph on
either
\emph default
 an 
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
 value or a 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 error message
\end_layout

\begin_layout Itemize
A value that is one case class out of a number of case classes
\end_layout

\end_deeper
\begin_layout Itemize
Disjunction types represent such values as types
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Disjunction type: 
\family typewriter
Either[A, B]
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Example: 
\family typewriter
\size footnotesize
\color blue
Either[String, Int]
\family default
\size default
\color inherit
 (may be used for error reporting)
\end_layout

\begin_layout Itemize
Represents a value that is 
\emph on
either
\emph default
 a 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 or an 
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
 (but not both)
\end_layout

\begin_layout Itemize
Example values: 
\family typewriter
\size footnotesize
\color blue
Left("blah")
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
Right(123)
\end_layout

\begin_layout Itemize
Use pattern matching to distinguish 
\begin_inset Quotes eld
\end_inset

left
\begin_inset Quotes erd
\end_inset

 from 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def logError(x: Either[String, Int]): Int = x match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Left(error) 
\begin_inset Formula $\Rightarrow$
\end_inset

 println(s"Got error: $error"); -1
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Right(res) 
\begin_inset Formula $\Rightarrow$
\end_inset

 res
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\family sans
\color gray
 // Left(
\begin_inset Quotes eld
\end_inset

blah
\begin_inset Quotes erd
\end_inset

) and Right(123) are possible values of type Either[String, Int]
\end_layout

\begin_layout Itemize
Now 
\family typewriter
\size footnotesize
\color blue
logError(Right(123))
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
123
\family default
\size default
\color inherit
 while 
\family typewriter
\size footnotesize
\color blue
logError(Left("bad result"))
\family default
\size default
\color inherit
 prints the error and returns 
\family typewriter
\size footnotesize
\color blue
-1
\end_layout

\begin_layout Itemize
The 
\family typewriter
\size footnotesize
\color blue
case
\family default
\size default
\color inherit
 expression chooses among possible values of a given type
\end_layout

\begin_deeper
\begin_layout Itemize
Note the similarity with this code:
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f(x: Int): Int = x match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case 0 
\begin_inset Formula $\Rightarrow$
\end_inset

 println(s"error: must be nonzero"); -1
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case 1 
\begin_inset Formula $\Rightarrow$
\end_inset

 println(s"error: must be greater than 1"); -1
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case res 
\begin_inset Formula $\Rightarrow$
\end_inset

 res
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\family sans
\color gray
 // 0 and 1 are possible values of type Int
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
More general disjunction types: using case classes
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
A future version of Scala 3 has a short syntax for disjunction types:
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
type MyIntOrStr = Int | String
\end_layout

\begin_layout Itemize
more generally, 
\family typewriter
\size footnotesize
\color blue
type MyType = List[Int] | (Int, Boolean) | MySocks
\end_layout

\begin_deeper
\begin_layout Itemize
Some libraries (scalaz, cats, shapeless) also provide shorter syntax
\end_layout

\end_deeper
\begin_layout Standard
For now, in Scala 2, we use the 
\begin_inset Quotes eld
\end_inset

long syntax
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
(specify names for each case and for each part, use 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size footnotesize
\color blue
trait
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 / 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size footnotesize
\color blue
extends
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait MyType
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class HaveListInt(x: List[Int]) extends MyType
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class HaveIntBool(s: Int, b: Boolean) extends MyType
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class HaveSocks(socks: MySocks) extends MyType
\end_layout

\begin_layout Standard
Pattern-matching example:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val x: MyType = if (...) HaveSocks(...) else HaveListInt(...)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
...
 
\family sans
\color gray
// some other code here
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
x match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case HaveListInt(lst) 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case HaveIntBool(p, q) 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case HaveSocks(s) 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The most used disjunction type: 
\family typewriter
Option[T]
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
A simple implementation: 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Option[T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class Some[T](t: T) extends Option[T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case object None extends Option[Nothing]
\end_layout

\begin_layout Standard
Pattern-matching example:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def saveDivide(x: Double, y: Double): Option[Double] = {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  if (y == 0) None else Some(x / y)
\end_layout

\begin_layout LyX-Code

\family sans
\size footnotesize
\color gray
// Example usage:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val result = safeDivide(1.0, q) match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Some(x) 
\begin_inset Formula $\Rightarrow$
\end_inset

 previousResult * x
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case None 
\begin_inset Formula $\Rightarrow$
\end_inset

 previousResult 
\family sans
\color gray
// provide a default value
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Standard
Many Scala library functions return an 
\family typewriter
\size footnotesize
\color blue
Option[T]
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
find, headOption, reduceOption, get
\family default
\size default
\color inherit
 (for
\family typewriter
\size footnotesize
\color blue
 Map[K, V]
\family default
\size default
\color inherit
), etc.
\end_layout

\begin_deeper
\begin_layout Itemize
Note: 
\family typewriter
\size footnotesize
\color blue
Option[T]
\family default
\size default
\color inherit
 is 
\begin_inset Quotes eld
\end_inset

collection-like
\begin_inset Quotes erd
\end_inset

: has 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
exists
\family default
\size default
\color inherit
...
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked examples
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
What problems can we solve now?
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
a
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Types and propositional logic
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
The Curry-Howard correspondence
\end_layout

\begin_layout Standard
This code:
\family typewriter
\size footnotesize
\color blue
 val x:
\begin_inset space \space{}
\end_inset

T = ...

\family default
\size default
\color inherit
 means that 
\emph on
we can compute a value
\emph default
 of type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 as part of our program
\end_layout

\begin_layout Itemize
Let's denote this 
\emph on
proposition
\emph default
 by 
\begin_inset Formula ${\cal CH}(T)$
\end_inset

 – 
\begin_inset Quotes eld
\end_inset

Code Has a value of type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
We have the following correspondence:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Short notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(T)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(A, B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
and
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Either[A, B]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
or
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\oplus B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
implies
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\Rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Nothing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
type parameter 
\family typewriter
\size footnotesize
\color blue
[T]
\family default
\size default
\color inherit
 means 
\begin_inset Formula $\forall T$
\end_inset

, for example the type of the function
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

def dupl[A](x:
\begin_inset space \space{}
\end_inset

A):
\begin_inset space \space{}
\end_inset

(A, A)
\family default
\size default
\color inherit
 corresponds to the (valid) proposition:
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\forall A:A\Rightarrow A\times A$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Example 1:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait UserAction
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class SetName(first: String, last: String) extends UserAction
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class SetEmail(email: String) extends UserAction
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class SetUserId(id: Long) extends UserAction
\end_layout

\begin_layout Itemize
Short notation: 
\family typewriter
\size footnotesize
\color blue
UserAction
\family default
\size default
\color inherit
 
\begin_inset Formula $=$
\end_inset

 (
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 
\begin_inset Formula $\times$
\end_inset

 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
)
\family typewriter
\size footnotesize
\color blue
 
\begin_inset Formula $\oplus$
\end_inset


\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue

\begin_inset Formula $\oplus$
\end_inset


\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue
Long
\end_layout

\begin_layout Itemize
Example 2: parametric type
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Either3[A, B, C]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Left[A, B, C](x: A) extends Either3[A, B, C]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Middle[A, B, C](x: B) extends Either3[A, B, C]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Right[A, B, C](x: C) extends Either3[A, B, C]
\end_layout

\begin_layout Itemize
Short notation: 
\begin_inset Formula $\forall A\forall B\forall C:$
\end_inset

 Either3
\begin_inset Formula $[A,B,C]=A\oplus B\oplus C$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Using known properties of propositional logic
\end_layout

\begin_layout Itemize
Some standard identities in logic:
\begin_inset Formula 
\begin{align*}
A\times1 & =A\\
A+1 & =1\\
(A\times B)\times C & =A\times(B\times C)\\
(A\oplus B)\oplus C & =A\oplus(B\oplus C)\\
A\times(B\oplus C) & =(A\times B)\oplus(A\times C)\\
A\oplus(B\times C) & =(A\oplus B)\times(A\oplus C)
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
Each identity gives functions that map both ways
\end_layout

\begin_layout Itemize
Some of these identities yield
\emph on
 isomorphisms of types
\end_layout

\begin_deeper
\begin_layout Itemize
Which ones do 
\emph on
not
\emph default
 yield isomorphisms, and why?
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Algebraic computations with types
\end_layout

\begin_layout Itemize
Example 3: Recursive type
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait IntList
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case object Empty extends IntList
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class Nonempty(head: Int, tail: IntList) extends IntList
\end_layout

\begin_layout Itemize
Short notation: (the sign 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\equiv$
\end_inset


\begin_inset Quotes erd
\end_inset

 means type isomorphism)
\family typewriter
\size footnotesize
\color blue

\begin_inset Formula 
\begin{align*}
\text{IntList} & \equiv1\oplus\text{Int}\times\text{IntList}\equiv1\oplus\text{Int}\times(1\oplus\text{Int}\times(1\oplus\text{Int}\times(...)...)\\
 & \equiv1\oplus\text{Int}\oplus\text{Int}\times\text{Int}\oplus\text{Int}\times\text{Int}\times\text{Int}\oplus...
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
Recursive list of integers 
\begin_inset Formula $\equiv$
\end_inset

 disjunction of empty, list of 1 integer, list of 2 integers, etc.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Any valid proposition can be implemented in code
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def identity[A](x:A):A = x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\Rightarrow1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def toUnit[A](x:A): Unit = ()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\Rightarrow A\oplus B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def inLeft[A,B](x:A):
\begin_inset space \space{}
\end_inset

Either[A,B] = Left(x)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\times B\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def first[A,B](p:(A,B)):A = p._1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\Rightarrow(B\Rightarrow A)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def const[A,B](x:A):B
\begin_inset Formula $\Rightarrow$
\end_inset

A = (y:B)
\begin_inset Formula $\Rightarrow$
\end_inset

x
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Invalid propositions 
\emph on
cannot be implemented
\emph default
 in code 
\end_layout

\begin_deeper
\begin_layout Itemize
Examples:
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $\forall A:1\Rightarrow A$
\end_inset

; 
\begin_inset Formula $\forall A\forall B:A\oplus B\Rightarrow A$
\end_inset

; 
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\forall A\forall B:A\Rightarrow A\times B$
\end_inset

; 
\begin_inset space \space{}
\end_inset

 
\begin_inset Formula $\quad\forall A\forall B:(A\Rightarrow B)\Rightarrow A$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Given a type, can we decide whether it is implementable?
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $\forall A\forall B:((((A\Rightarrow B)\Rightarrow B)\Rightarrow A)\Rightarrow B)\Rightarrow B$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Pure propositional logic has a decision algorithm
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked examples
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
What problems can we solve now?
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises III
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
a
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Implications for designing new programming languages
\end_layout

\begin_layout Itemize
The CH correspondence maps the type system of each programming language
 into a certain system of logical propositions 
\end_layout

\begin_layout Itemize
Scala, Haskell, OCaml, F#, Swift, Rust, etc.
\begin_inset space ~
\end_inset

are mapped into the full constructive logic (all logical operations are
 available)
\end_layout

\begin_deeper
\begin_layout Itemize
C, C++, Java, C#, etc.
\begin_inset space ~
\end_inset

are mapped to 
\emph on
incomplete
\emph default
 
\emph on
logics
\emph default
 – without 
\begin_inset Quotes eld
\end_inset

or
\begin_inset Quotes erd
\end_inset

 and without 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 / 
\begin_inset Quotes eld
\end_inset

false
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Python, JavaScript, Ruby, Clojure, etc.
\begin_inset space ~
\end_inset

have only one type (
\begin_inset Quotes eld
\end_inset

any value
\begin_inset Quotes erd
\end_inset

) and are mapped to logics with only one proposition
\end_layout

\end_deeper
\begin_layout Itemize
The CH correspondence is a principle for designing type systems:
\end_layout

\begin_deeper
\begin_layout Itemize
Choose a complete logic, free of inconsistency
\end_layout

\begin_deeper
\begin_layout Itemize
Mathematicians have studied all kinds of logics and determined which ones
 are interesting, and found the minimal sets of axioms for them
\end_layout

\end_deeper
\begin_layout Itemize
Provide a type constructor for each basic operation (e.g.
\begin_inset space ~
\end_inset


\begin_inset Quotes eld
\end_inset


\emph on
or
\emph default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\emph on
and
\emph default

\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Implications for actually writing code
\end_layout

\begin_layout Standard
What problems can we solve now?
\end_layout

\begin_layout Itemize
Given a fully parametric type, decide whether it can be implemented in code
 (
\begin_inset Quotes eld
\end_inset

type is inhabited
\begin_inset Quotes erd
\end_inset

); if so, 
\emph on
generate
\emph default
 the code
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset CommandInset href
LatexCommand href
name "Gentzen-Vorobiev-Hudelmaier algorithms"
target "http://apt13.unibe.ch/slides/Dyckhoff.pdf"

\end_inset

 and generalizations
\end_layout

\end_deeper
\begin_layout Itemize
Given some code, infer the most general type it can have
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset CommandInset href
LatexCommand href
name "Damas-Hindley-Milner algorithm"
target "https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system"

\end_inset

 (
\begin_inset CommandInset href
LatexCommand href
name "Scala code"
target "http://dysphoria.net/2009/06/28/hindley-milner-type-inference-in-scala/"

\end_inset

) and generalizations
\end_layout

\end_deeper
\end_deeper
\end_body
\end_document
