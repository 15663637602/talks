#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title{Concurrent Join Calculus in Scala}
\author{Sergei Winitzki}
\date{November 11, 2016}
\institute[Workday, Inc.]{Scala by the Bay 2016}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Motivation
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Concurrency vs.
 Parallelism
\end_layout

\begin_layout Itemize
parallelism = a sequential computation made faster
\end_layout

\begin_deeper
\begin_layout Itemize
main problem: to 
\begin_inset Quotes eld
\end_inset

parallelize
\begin_inset Quotes erd
\end_inset

 a sequential computation
\end_layout

\end_deeper
\begin_layout Itemize
concurrency = interacting computations running in unknown order
\end_layout

\begin_deeper
\begin_layout Itemize
main problem: to decide when to run a process (or to wait)
\end_layout

\end_deeper
\begin_layout Standard
Imperative concurrency is difficult:
\end_layout

\begin_layout Itemize
callbacks, semaphores, threads, shared mutable state
\end_layout

\begin_layout Itemize
testing is hard – race conditions, deadlocks, livelocks
\end_layout

\begin_layout Standard
Better models of concurrency:
\end_layout

\begin_layout Itemize
STM
\end_layout

\begin_layout Itemize
futures/promises = 
\begin_inset Quotes eld
\end_inset

async monads
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Erlang's message-passing 
\begin_inset Formula $\approx$
\end_inset

 Akka's 
\begin_inset Quotes eld
\end_inset

actors
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
CSP, 
\begin_inset Formula $\pi$
\end_inset

-calculus, join calculus (academic so far)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Join Calculus
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Join Calculus = stateless, type-safe, channel-driven actors
\end_layout

\begin_deeper
\begin_layout Itemize
Declarative language for concurrent computations
\end_layout

\begin_layout Itemize
No threads/semaphores/locks/forks, no shared mutable state
\end_layout

\end_deeper
\begin_layout Itemize
Implementations:
\end_layout

\begin_deeper
\begin_layout Itemize
Joinads (F#, Haskell) [
\begin_inset CommandInset href
LatexCommand href
name "Petricek and Syme 2011"
target "https://www.microsoft.com/en-us/research/publication/joinads-a-retargetable-control-flow-construct-for-reactive-parallel-and-concurrent-programming/"

\end_inset

]
\end_layout

\begin_layout Itemize
JoCaml (
\begin_inset CommandInset href
LatexCommand href
name "jocaml.inria.fr"
target "http://jocaml.inria.fr"

\end_inset

) [
\begin_inset CommandInset href
LatexCommand href
name "Fournet et al. 2003"
target "http://research.microsoft.com/en-us/um/people/fournet/papers/jocaml-afp4-summer-school-02.pdf"

\end_inset

]
\end_layout

\begin_layout Itemize
ScalaJoins [
\begin_inset CommandInset href
LatexCommand href
name "P. Haller 2008"
target "http://lampwww.epfl.ch/~phaller/joins/index.html"

\end_inset

] [
\begin_inset CommandInset href
LatexCommand href
name "J. He 2011"
target "https://github.com/Jiansen/ScalaJoin"

\end_inset

]
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "JoinRun"
target "https://github.com/winitzki/joinrun-scala"

\end_inset

 -- a new Scala implementation (this talk)
\end_layout

\begin_deeper
\begin_layout Itemize
Can use threads or Akka actors
\end_layout

\begin_layout Itemize
More composability in architecting concurrency
\end_layout

\begin_layout Itemize
Better syntax, more checks of code sanity
\end_layout

\begin_layout Itemize
Automatic fault tolerance
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Join Calculus in a nutshell
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
a.k.a.
 the 
\begin_inset Quotes eld
\end_inset

Chemical Abstract Machine
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Abstract chemistry: 
\begin_inset Quotes eld
\end_inset

molecules
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

reactions
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Chemical 
\begin_inset Quotes eld
\end_inset

soup
\begin_inset Quotes erd
\end_inset

 contains many 
\begin_inset Quotes eld
\end_inset

molecules
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
A combination of certain molecules starts a 
\begin_inset Quotes eld
\end_inset

chemical reaction
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
\size scriptsize
\color blue
jocaml> 
\begin_inset space ~
\end_inset

 def
\begin_inset space ~
\end_inset

 a() & b() = c()
\color black

\begin_inset Newline newline
\end_inset


\color blue

\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset

 and 
\begin_inset space ~
\end_inset

a() & c() = 0;;
\end_layout

\begin_layout Plain Layout

\family typewriter
\size scriptsize
\color black
val a : unit Join.chan = <abstr>
\end_layout

\begin_layout Plain Layout

\family typewriter
\size scriptsize
\color black
val b : unit Join.chan = <abstr>
\end_layout

\begin_layout Plain Layout

\family typewriter
\size scriptsize
\color black
val c : unit Join.chan = <abstr>
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "30col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename cham1.eps
	width 100col%

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

Using the 
\begin_inset Quotes eld
\end_inset

chemical machine
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize
Define arbitrary 
\begin_inset Quotes eld
\end_inset

chemical laws
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

molecules
\begin_inset Quotes erd
\end_inset

: 
\family typewriter
\size scriptsize
\color blue
a
\family default
\size default
\color inherit
, 
\family typewriter
\size scriptsize
\color blue
b
\family default
\size default
\color inherit
, 
\family typewriter
\size scriptsize
\color blue
c
\family default
\size default
\color inherit
, ...
\end_layout

\begin_layout Itemize
Inject some 
\begin_inset Quotes eld
\end_inset

molecules
\begin_inset Quotes erd
\end_inset

 into the 
\begin_inset Quotes eld
\end_inset

soup
\begin_inset Quotes erd
\end_inset

: 
\family typewriter
\size scriptsize
\color blue
spawn a() & a() & b()
\family default
\size default
\color inherit

\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Note: 
\family typewriter
\size scriptsize
\color blue
a() & a() & b()
\family default
\size default
\color inherit
 is the syntax for 
\begin_inset Quotes eld
\end_inset

molecule-valued
\begin_inset Quotes erd
\end_inset

 expressions
\end_layout

\end_deeper
\begin_layout Itemize
The runtime system evolves the soup 
\emph on
asynchronously
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Join Calculus in a nutshell
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Concurrent computations
\end_layout

\begin_layout Standard
Sequential computation = evaluating an expression
\end_layout

\begin_layout Standard
Concurrent computation = evaluating several expressions at once
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Join Calculus organizes concurrent computations through 
\begin_inset Quotes eld
\end_inset

chemistry
\begin_inset Quotes erd
\end_inset

:
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Itemize
Each molecule carries a 
\series bold
value
\series default
 
\end_layout

\begin_layout Itemize
Each reaction computes a 
\begin_inset Quotes eld
\end_inset

molecule-valued
\begin_inset Quotes erd
\end_inset

 
\series bold
expression
\end_layout

\begin_layout Itemize
Results of computation are injected back into the soup
\end_layout

\begin_layout Itemize
Reactions start concurrently when molecules are available
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename cham2.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout

\family typewriter
\size scriptsize
\color blue
def
\begin_inset space ~
\end_inset

 a(x) & b(y) =
\end_layout

\begin_layout Plain Layout

\family typewriter
\size scriptsize
\color blue
\begin_inset space ~
\end_inset

 let z = (big_function x y) in a(z)
\end_layout

\begin_layout Plain Layout

\family typewriter
\size scriptsize
\color blue
and
\begin_inset space ~
\end_inset

 a(x) & c() = (print_int x; 0);;
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

When reaction starts: input molecules disappear, expression is computed,
 output molecules are injected
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Join Calculus in a nutshell
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
More features of JoCaml
\end_layout

\begin_layout Itemize
Mutual recursion:
\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
def a(x) = a(x+1) & b(x+2) and b(x) & c(y) = a(x+y)
\end_layout

\begin_layout Itemize
Pattern-matching on molecule's payload values:
\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
def a(Some x) & b(y) = b(x+y) or a(None) & b(y) = b(y)
\end_layout

\begin_layout Itemize

\series bold
Instant
\series default
 molecules (same type as function calls):
\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
def a(x) & f() = a(x+1) & reply x to f
\end_layout

\begin_layout Itemize

\series bold
Local
\series default
 molecules and reactions: 
\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
def c(n) = ( if n>0 then c(n-1) else 0 ) in
\begin_inset space ~
\end_inset

 spawn c(10)
\end_layout

\begin_layout Itemize
Injection as side-effect: 
\family typewriter
\size scriptsize
\color blue

\begin_inset space ~
\end_inset

 let x=3 in (spawn a(x); printf 
\begin_inset Quotes eld
\end_inset

%d
\backslash
n
\begin_inset Quotes erd
\end_inset

 x)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize

\series bold
Molecule
\series default
 
\series bold
constructors
\series default
 are defined as values and can be manipulated:
\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
# def a(x) = Printf.printf 
\begin_inset Quotes eld
\end_inset

%d
\backslash
n
\begin_inset Quotes erd
\end_inset

 x; 0;;
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
val a : int Join.chan = <abstr>
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
# def b(m,y) = Printf.printf 
\begin_inset Quotes eld
\end_inset

injecting m(%d)
\backslash
n
\begin_inset Quotes erd
\end_inset

 y; m(y);;
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
val b: (int Join.chan * int) Join.chan = <abstr>
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Join Calculus: Examples
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Options, Futures, and Map/Reduce
\end_layout

\begin_layout Standard
Future with synchronous poll (
\begin_inset Quotes eld
\end_inset


\family typewriter
\size scriptsize
\color blue
get
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

):
\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
# def fut(f,x) = let res = f x in finished(res)
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue

\begin_inset space ~
\end_inset

 and get() & finished(res) = reply res to get;;
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
val get : unit -> '_a = <fun>
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
val finished : '_a Join.chan = <abstr>
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
val fut : (('a -> '_b) * 'a) Join.chan = <abstr>
\end_layout

\begin_layout Standard
Future with synchronous callback:
\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
def fut(f,x,c) = let res = f x in ( c(res); finished(res) )
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue

\begin_inset space ~
\end_inset

 and get() & finished(res) = reply res to get
\end_layout

\begin_layout Standard
Future with asynchronous callback:
\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
def fut(f,x,m) = let res = f x in ( m(res) & finished(res) )
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue

\begin_inset space ~
\end_inset

 and get() & finished(res) = reply res to get
\end_layout

\begin_layout Itemize
Exercise: implement a 
\begin_inset Quotes eld
\end_inset

future with cancellable callback
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Join Calculus: Examples
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Options, Futures, and Map/Reduce
\end_layout

\begin_layout Standard
Asynchronous counter:
\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
# def inc() & c(n) = c(n+1) 
\end_layout

\begin_layout Standard

\family typewriter
\size scriptsize
\color blue
or get() & c(n) = reply n to get & c(n);; 
\end_layout

\begin_layout Standard

\family typewriter
\size scriptsize
\color blue
val inc : unit Join.chan = <abstr> 
\end_layout

\begin_layout Standard

\family typewriter
\size scriptsize
\color blue
val get : unit -> int = <fun> 
\end_layout

\begin_layout Standard

\family typewriter
\size scriptsize
\color blue
val c : int Join.chan = <abstr> 
\end_layout

\begin_layout Standard

\family typewriter
\size scriptsize
\color blue
# spawn c(0) & inc() & inc() & inc();; 
\end_layout

\begin_layout Standard

\family typewriter
\size scriptsize
\color blue
- : unit = () 
\end_layout

\begin_layout Standard

\family typewriter
\size scriptsize
\color blue
# get();; 
\end_layout

\begin_layout Standard

\family typewriter
\size scriptsize
\color blue
- : int = 3 
\end_layout

\begin_layout Standard
Map/Reduce:
\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
def res(list) & c(s) = res (s::list) or get() & res(list) = reply list to
 get;;
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
spawn res([]);;
\family default
\size default
\color inherit
 
\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
List.map (fun x-> spawn c(x*2)) [1; 2; 3];;
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\size scriptsize
\color blue
get();; (* this returned [4; 6; 2] in one test *)
\end_layout

\begin_layout Itemize
Exercise: implement a concurrent 
\begin_inset Quotes eld
\end_inset

fold
\begin_inset Quotes erd
\end_inset

 (e.g.
 sum of int list)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Join Calculus: Examples
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Five Dining Philosophers
\end_layout

\begin_layout Standard
Philosophers 
\size scriptsize
\color blue
A
\family typewriter
, 
\family default
B
\family typewriter
, 
\family default
C
\family typewriter
, 
\family default
D
\family typewriter
, 
\family default
E
\size default
\color inherit
; forks 
\family typewriter
\size scriptsize
\color blue
fAB, fBC, fCD, fDE, fEA
\family default
\size default
\color inherit
.
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
let report(message) = Printf.printf 
\begin_inset Quotes eld
\end_inset

%s
\backslash
n
\begin_inset Quotes erd
\end_inset

 message;
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
                           Unix.sleep (Random.int 3600) ;;
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
def hA() & fEA() & fAB() = report(
\begin_inset Quotes eld
\end_inset

A is eating
\begin_inset Quotes erd
\end_inset

); tA() & fEA() & fAB() 
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
or  hB() & fAB() & fBC() = report(
\begin_inset Quotes eld
\end_inset

B is eating
\begin_inset Quotes erd
\end_inset

); tB() & fAB() & fBC() 
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
or  hC() & fBC() & fCD() = report(
\begin_inset Quotes eld
\end_inset

C is eating
\begin_inset Quotes erd
\end_inset

); tC() & fBC() & fCD() 
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
or  hD() & fCD() & fDE() = report(
\begin_inset Quotes eld
\end_inset

D is eating
\begin_inset Quotes erd
\end_inset

); tD() & fCD() & fDE() 
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
or  hE() & fDE() & fEA() = report(
\begin_inset Quotes eld
\end_inset

E is eating
\begin_inset Quotes erd
\end_inset

); tE() & fDE() & fEA() 
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
and tA() = report(
\begin_inset Quotes eld
\end_inset

A is thinking
\begin_inset Quotes erd
\end_inset

); hA() 
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
and tB() = report(
\begin_inset Quotes eld
\end_inset

B is thinking
\begin_inset Quotes erd
\end_inset

); hB() 
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
and tC() = report(
\begin_inset Quotes eld
\end_inset

C is thinking
\begin_inset Quotes erd
\end_inset

); hC() 
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
and tD() = report(
\begin_inset Quotes eld
\end_inset

D is thinking
\begin_inset Quotes erd
\end_inset

); hD() 
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
and tE() = report(
\begin_inset Quotes eld
\end_inset

E is thinking
\begin_inset Quotes erd
\end_inset

); hE() ;; 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
spawn fAB() & fBC() & fCD() & fDE() & fEA()
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
     & tA() & tB() & tC() & tD() & tE() ;; 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Limitations and restrictions of Join Calculus
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Less is more!
\end_layout

\begin_layout Itemize
Reactions are defined 
\series bold
statically
\series default
 and with 
\series bold
local scope
\series default
:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
no molecules with computed names: 
\family typewriter
\size scriptsize
\color blue

\begin_inset Newline newline
\end_inset

a(x) & molecule_named(
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

)(x) = (not allowed!)
\end_layout

\begin_layout Itemize
cannot dynamically add a new reaction to a previously defined molecule:
\family typewriter
\size scriptsize
\color blue

\begin_inset Newline newline
\end_inset

def a(x) & b(y) = ...
 ;;
\begin_inset Newline newline
\end_inset

def b(y) & c(z) = ...
 shadows the old definition of b()!
\end_layout

\end_deeper
\begin_layout Itemize
No 
\begin_inset Quotes eld
\end_inset

guard conditions
\begin_inset Quotes erd
\end_inset

 for reactions:
\end_layout

\begin_layout Standard

\family typewriter
\size scriptsize
\color blue
def a(x) & b(y) & start_if (x==y) = ...
 (not allowed!)
\end_layout

\begin_layout Itemize
No duplicated input values: 
\family typewriter
\size scriptsize
\color blue
a(x) & b(x) = (not allowed!)
\end_layout

\begin_layout Itemize
No duplicated input molecules: 
\family typewriter
\size scriptsize
\color blue
a(x) & a(y) = (not allowed!)
\end_layout

\begin_layout Itemize
No way to test dynamically for the presence/absence of a molecule!
\end_layout

\begin_layout Standard

\family typewriter
\size scriptsize
\color blue
def a(x) & b(y) = if have_molecules(c & d) then ...
 else ...
 (not allowed!)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Limitations and restrictions of Join Calculus
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
It seems they do not limit the expressive power!
\end_layout

\begin_layout Standard
What if we 
\emph on
need
\emph default
 a reaction with pairs of molecules?
\end_layout

\begin_layout Standard

\family typewriter
\size scriptsize
\color blue
a(x) & a(y) = a(x+y) 
\end_layout

\begin_layout Itemize
Solution: use two "
\family typewriter
\size scriptsize
\color blue
or
\family default
\size default
\color inherit
"-coupled reactions with new molecules 
\family typewriter
\size scriptsize
\color blue
a'
\family default
\size default
\color inherit
 and 
\family typewriter
\size scriptsize
\color blue
b
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Standard

\family typewriter
\size scriptsize
\color blue
def a(x) & b() = a'(x) or a(x) & a'(y) = whatever(x,y) 
\end_layout

\begin_layout Itemize
Make sure that one 
\family typewriter
\size scriptsize
\color blue
b()
\family default
\size default
\color inherit
 is injected together with each 
\family typewriter
\size scriptsize
\color blue
a(x)
\end_layout

\begin_layout Standard
Questions:
\end_layout

\begin_layout Itemize
Can we prevent the error of not injecting 
\family typewriter
\size scriptsize
\color blue
b()
\family default
\size default
\color inherit
?
\end_layout

\begin_layout Itemize
Can we do a reaction with 
\begin_inset Formula $n$
\end_inset

 molecules, where 
\begin_inset Formula $n$
\end_inset

 is dynamic?
\end_layout

\begin_layout Itemize
Can we do 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $n$
\end_inset

 dining philosophers
\begin_inset Quotes erd
\end_inset

?
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Local scope and recursion
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Skeleton code for concurrent merge-sort
\end_layout

\begin_layout Standard
The 
\family typewriter
mergesort
\family default
 molecule:
\end_layout

\begin_layout Itemize
receives the upper-level 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size scriptsize
\color blue
sorted_result
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 molecule
\end_layout

\begin_layout Itemize
defines its own 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size scriptsize
\color blue
sorted
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 molecule in 
\emph on
local scope
\end_layout

\begin_layout Itemize
emits upper-level 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size scriptsize
\color blue
sorted_result
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 when done
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
def mergesort(arr, sorted_result) = 
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
  if Array.length arr <= 1 then sorted_result(arr)
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
  else 
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
   let (part1, part2) = array_split arr
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
   in 
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
   def sorted(x) & sorted'(y) = sorted_result(array_merge x y) 
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
   in 
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color blue
   mergesort(part1, sorted) & mergesort(part2, sorted')
\end_layout

\begin_layout Standard
Note  
\begin_inset Quotes eld
\end_inset


\family typewriter
\size scriptsize
\color blue
sorted(x) & sorted'(y)
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

: need different molecules.
\end_layout

\begin_layout Standard
See tutorial for complete working JoCaml code.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Comparison: Join Calculus vs.
 Actor model
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Reaction 
\begin_inset Formula $\approx$
\end_inset

 actor; molecule 
\begin_inset Formula $\approx$
\end_inset

 message to actor.
\end_layout

\begin_layout Standard
Actors: 
\end_layout

\begin_layout Itemize
need to be created and started explicitly
\end_layout

\begin_layout Itemize
process one message at a time (one actor = one thread)
\end_layout

\begin_layout Itemize
must hold mutable state (e.g.
 for a thread-safe counter)
\end_layout

\begin_layout Itemize
explicitly create and configure other actors 
\end_layout

\begin_layout Standard
Reactions:
\end_layout

\begin_layout Itemize
start when several molecules are available
\end_layout

\begin_layout Itemize
many reactions can start at once, automatically
\end_layout

\begin_layout Itemize
do not need mutable state
\end_layout

\begin_layout Itemize
all reactions are defined statically, but locally scoped
\end_layout

\begin_layout Itemize
simulate actors:
\size scriptsize
\color blue
 def message(m) & actor(state) = actor(compute_new state m)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Implementation of Join Calculus
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
JC = a DSL + run-time library, or just DSL?
\end_layout

\begin_layout Standard
Implement Join Calculus using Actors (Akka)?
\end_layout

\begin_layout Itemize
Each reaction has 
\begin_inset Formula $1$
\end_inset

 
\begin_inset Quotes eld
\end_inset

monitor actor
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Formula $\geq1$
\end_inset

 
\begin_inset Quotes eld
\end_inset

worker actors
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Monitor receives messages for each 
\begin_inset Quotes eld
\end_inset

spawn
\begin_inset Quotes erd
\end_inset

, keeps track of molecules
\end_layout

\begin_layout Itemize
Monitor starts a worker actor when all molecules are present
\end_layout

\begin_layout Itemize
Monitors have to talk to competing monitors - 
\begin_inset Quotes eld
\end_inset

use up
\begin_inset Quotes erd
\end_inset

 molecules
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
but all competitions are statically defined!
\end_layout

\end_deeper
\begin_layout Itemize
Monitors / workers need to be locally scoped!
\end_layout

\begin_layout Itemize
No globally shared state of the 
\begin_inset Quotes eld
\end_inset

soup
\begin_inset Quotes erd
\end_inset

 is needed!
\end_layout

\begin_layout Itemize
Discuss
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Conclusions and outlook
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Join Calculus
\begin_inset Quotes erd
\end_inset

 is concurrent programming in pure functional style
\end_layout

\begin_layout Itemize
Similar to 
\begin_inset Quotes eld
\end_inset

Actors
\begin_inset Quotes erd
\end_inset

, but more concurrent and 
\begin_inset Quotes eld
\end_inset

more pure
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Very little known, and very little used in practice
\end_layout

\begin_layout Itemize
Existing literature is not suitable as introduction to practical programming
\end_layout

\begin_layout Itemize
My tutorial text is in progress (search Google for 
\begin_inset Quotes eld
\end_inset

tutorial on join calculus
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_deeper
\end_body
\end_document
