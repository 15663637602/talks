#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[That scripting language called Prolog]{That scripting language called Prolog}
\author{Sergei Winitzki}
\date{June 16, 2014}
\institute[Versal Group Inc.]{Types, Theorems, and Programming Languages}
\definecolor{mybgcolor}{rgb}{0.96,0.98,1}
\setbeamercolor{background canvas}{bg=mybgcolor}
\end_preamble
\options hyperref
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "That scripting language called Prolog"
\pdf_author "Sergei Winitzki, Ph.D."
\pdf_subject "Prolog programming language"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=black,urlcolor=blue"
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout BeginFrame
The four programming paradigms
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Example
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Programs are...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Difficulty is in...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Best used in...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Imperative
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Fortran
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
lists of commands
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
order of updates
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
numerics
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Functional
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Lisp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
expressions
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
level of abstraction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
compilers
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Logic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Prolog
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
sets of predicates
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
runtime behavior
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
symbolic AI
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Constraint
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
TeX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
data + constraints
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
conflicting modules
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
domain-specific
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Objects, type systems, modules, concurrency, etc., are merely 
\emph on
features
\emph default
 added on top of a 
\emph on
chosen
\emph default
 
\emph on
paradigm
\end_layout

\begin_layout EndFrame

\end_layout

\begin_layout BeginFrame
A definition of 
\begin_inset Quotes eld
\end_inset

declarative
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Programming is 
\begin_inset Quotes eld
\end_inset

declarative
\begin_inset Quotes erd
\end_inset

 when 
\emph on
specifications
\emph default
 
\emph on
are
\emph default
 
\emph on
programs.
\end_layout

\begin_layout Standard
More formally:
\end_layout

\begin_layout Standard
A language 
\begin_inset Formula $L$
\end_inset

 is 
\series bold
declarative for an application domain
\series default
 
\begin_inset Formula $D$
\end_inset

 if: 
\end_layout

\begin_layout Itemize
The domain 
\begin_inset Formula $D$
\end_inset

 has a 
\emph on
good
\emph default
 specification formalism 
\begin_inset Formula $F$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

 = 
\emph on
visual, convenient,
\emph default
 complete for the domain 
\begin_inset Formula $D$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
There is an obvious 
\emph on
syntactic
\emph default
 transformation from 
\begin_inset Formula $F$
\end_inset

 to 
\begin_inset Formula $L$
\end_inset


\end_layout

\begin_layout Itemize
The resulting program 
\emph on
implements the specification
\end_layout

\begin_layout Standard
Less formally:
\end_layout

\begin_layout Standard
A declarative language is a 
\begin_inset Quotes eld
\end_inset

perfect DSL
\begin_inset Quotes erd
\end_inset

 for the given domain
\end_layout

\begin_layout EndFrame

\end_layout

\begin_layout BeginFrame
Example: declarative FORTRAN 77
\end_layout

\begin_layout Itemize
Application domain: numerical mathematical expressions
\end_layout

\begin_layout Itemize
Specification: a mathematical formula involving 
\emph on
numbers 
\emph default
and
\emph on
 functions
\end_layout

\begin_layout Itemize
Example specification: 
\begin_inset Formula 
\[
f(x,p,q)=\frac{\sin px}{x^{2}}-\frac{\sin^{2}qx}{x^{3}}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Implementation: 
\family typewriter
\color blue
F(X,P,Q)=SIN(P*X)/X**2-(SIN(Q*X))**2/X**3
\end_layout

\end_deeper
\begin_layout Itemize
For more complicated tasks, FORTRAN is not declarative
\begin_inset Formula 
\[
\tilde{X}_{k}=Y_{k}-\sum_{j=k+1}^{n}A_{kj}X_{j},\quad\forall k\in\left[1..n\right]
\]

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename fortran1.png
	width 40text%

\end_inset


\begin_inset Formula $\quad$
\end_inset

(example code, 1987)
\end_layout

\begin_layout EndFrame

\end_layout

\begin_layout BeginFrame
Example: declarative Haskell 98
\end_layout

\begin_layout Itemize
Application domain: recursively defined algebraic data structures
\end_layout

\begin_layout Itemize
Specifications: inductive definitions of functions on ADTs
\end_layout

\begin_layout Itemize
Example (from R.
 Sedgewick, 
\emph on
Algorithms in C
\emph default
, 1998)
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename sedgewick-alg-tree.png
	lyxscale 50
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\align left

\family typewriter
\color blue
data BTree 
\begin_inset Formula $\alpha$
\end_inset

 = BTNode 
\begin_inset Formula $\alpha$
\end_inset

 | BTVertex 
\begin_inset Formula $\alpha$
\end_inset

 (BTree 
\begin_inset Formula $\alpha$
\end_inset

) (BTree 
\begin_inset Formula $\alpha$
\end_inset

)
\family default
 
\end_layout

\begin_layout BeginFrame
Example: declarative Haskell 98, continued
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename sedgewick-fun-tree.png
	lyxscale 50
	width 100text%

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color blue
height :: BTree 
\begin_inset Formula $\alpha$
\end_inset

 
\begin_inset Formula $\rightarrow$
\end_inset

 Int
\end_layout

\begin_layout Standard

\family typewriter
\color blue
height (BTNode _) = 0
\end_layout

\begin_layout Standard

\family typewriter
\color blue
height (BTVertex _ t1 t2) = 1 + max (height t1) (height t2) 
\end_layout

\begin_layout EndFrame

\end_layout

\begin_layout BeginFrame
Example: non-declarative Haskell
\end_layout

\begin_layout Standard
For a different application domain, Haskell is 
\emph on
not
\emph default
 declarative!
\end_layout

\begin_layout Itemize
Downloading data from server (from 
\begin_inset Quotes eld
\end_inset


\emph on
Real World Haskell
\emph default

\begin_inset Quotes erd
\end_inset

, 2008)
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename haskell-ugly-download.png
	lyxscale 50
	width 100text%

\end_inset


\end_layout

\begin_layout EndFrame

\end_layout

\begin_layout BeginFrame
Prolog as a DSL for logic puzzles
\end_layout

\begin_layout Standard

\emph on
\color magenta
All jumping creatures are green.
 All small jumping creatures are martians.
 All green martians are intelligent.
 
\end_layout

\begin_layout Standard

\emph on
\color magenta
Ngtrks is small and green.
 Pgvdrk is a jumping martian.
 
\end_layout

\begin_layout Standard

\emph on
\color magenta
Who is intelligent?
\emph default
\color inherit
 
\size footnotesize
(inpired by S.
 Lem, 
\begin_inset Quotes eld
\end_inset

Invasion from Aldebaran
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code

\color blue
small(ngtrks).
 green(ngtrks).
\end_layout

\begin_layout LyX-Code

\color blue
martian(pgvdrk).
 jumping(pgvdrk).
\end_layout

\begin_layout LyX-Code

\color blue
green(X) :- jumping(X).
 
\end_layout

\begin_layout LyX-Code

\color blue
martian(X) :- small(X), jumping(X).
 
\end_layout

\begin_layout LyX-Code

\color blue
intelligent(X) :- green(X), martian(X).
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\color blue
main :- 
\end_layout

\begin_layout LyX-Code

\color blue
  intelligent(X), format('~w is intelligent.~n', X), halt.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename e_martians_out.png
	width 7cm

\end_inset


\end_layout

\begin_layout EndFrame

\end_layout

\begin_layout BeginFrame
Prolog in a nutshell 1: predicates 
\end_layout

\begin_layout Itemize
Outer-level lower symbols are 
\series bold
logical
\series default
 
\series bold
predicates
\end_layout

\begin_deeper
\begin_layout Itemize
All other lowercase symbols are symbolic constants
\end_layout

\end_deeper
\begin_layout Itemize
All capitalized symbols are 
\series bold
quantified logical variables
\series default
 (LVs)
\end_layout

\begin_layout Itemize
LVs on the left imply 
\begin_inset Formula $\forall$
\end_inset

; free LVs on the right imply 
\begin_inset Formula $\exists$
\end_inset


\end_layout

\begin_layout Itemize
The symbol 
\family typewriter
\series bold
\color blue
:-
\family default
\series default
\color inherit
 means implication 
\begin_inset Formula $\leftarrow$
\end_inset

, the comma means 
\begin_inset Quotes eld
\end_inset


\emph on
and
\emph default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Examples:
\begin_inset Newline newline
\end_inset


\family typewriter
 
\color blue
green(X) :- jumping(X)
\family default
\color inherit
 means 
\begin_inset Formula $\forall X:green(X)\leftarrow jumping(X)$
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
 
\color blue
path(A,B) :- path(A,C), path(C,B)
\family default
\color inherit
 means
\begin_inset Newline newline
\end_inset

   
\begin_inset Formula $\forall A,B:\left[\exists C:path(A,C)\wedge path(C,B)\rightarrow path(A,B)\right]$
\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
\color blue
main :- intelligent(X)
\family default
\color inherit
 means: prove that 
\begin_inset Formula $\exists$
\end_inset


\family typewriter
X:intelligent(X)
\end_layout

\begin_layout EndFrame

\end_layout

\begin_layout BeginFrame
Prolog in a nutshell 2: variables
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Martians
\begin_inset Quotes erd
\end_inset

 recap:
\end_layout

\begin_layout LyX-Code

\color blue
small(ngtrks).
 green(ngtrks).
\end_layout

\begin_layout LyX-Code

\color blue
martian(pgvdrk).
 jumping(pgvdrk).
 
\end_layout

\begin_layout LyX-Code

\color blue
green(X) :- jumping(X).
 
\end_layout

\begin_layout LyX-Code

\color blue
martian(X) :- small(X), jumping(X).
 
\end_layout

\begin_layout LyX-Code

\color blue
intelligent(X) :- green(X), martian(X).
\end_layout

\begin_layout Itemize

\family typewriter
\color blue
main :- intelligent(X)
\family default
\color inherit
 means: prove that 
\begin_inset Formula $\exists$
\end_inset


\family typewriter
X:intelligent(X)
\end_layout

\begin_layout Itemize
The Prolog engine will 
\emph on
prove existence
\emph default
 of 
\begin_inset Formula $X$
\end_inset

 by backtracking search!
\begin_inset Newline newline
\end_inset

(we can say 
\begin_inset Quotes eld
\end_inset


\family typewriter
trace
\family default

\begin_inset Quotes erd
\end_inset

 and follow the search)
\end_layout

\begin_layout BeginFrame
Prolog in a nutshell 2: backtracking search
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Martians
\begin_inset Quotes erd
\end_inset

 recap:
\end_layout

\begin_layout LyX-Code

\family roman
\size footnotesize
\color blue
small(ngtrks).
 green(ngtrks).
\end_layout

\begin_layout LyX-Code

\family roman
\size footnotesize
\color blue
martian(pgvdrk).
 jumping(pgvdrk).
 
\end_layout

\begin_layout LyX-Code

\family roman
\size footnotesize
\color blue
green(X) :- jumping(X).
 
\end_layout

\begin_layout LyX-Code

\family roman
\size footnotesize
\color blue
martian(X) :- small(X), jumping(X).
 
\end_layout

\begin_layout LyX-Code

\family roman
\size footnotesize
\color blue
intelligent(X) :- green(X), martian(X).
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\family roman
\size footnotesize
\color blue
?- intelligent(X).
\end_layout

\end_inset


\family typewriter

\begin_inset space \hfill{}
\end_inset


\begin_inset Box Shadowbox
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "44col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code

\family roman
\size tiny
\color red
[trace]  ?- intelligent(X).
    
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
  Call: (6) intelligent(_G2442)
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
  Call: (7) green(_G2442)
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
  Exit: (7) green(ngtrks)
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
  Call: (7) martian(ngtrks)
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
  Call: (8) small(ngtrks)
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
  Exit: (8) small(ngtrks)
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
  Call: (8) jumping(ngtrks)
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
  Fail: (8) jumping(ngtrks)
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
  Fail: (7) martian(ngtrks)
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
  Redo: (7) green(_G2442)
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
  Call: (8) jumping(_G2442)
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
  Exit: (8) jumping(pgvdrk)
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
  Exit: (7) green(pgvdrk)
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
  Call: (7) martian(pgvdrk)
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
  Exit: (7) martian(pgvdrk)
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
  Exit: (6) intelligent(pgvdrk)
\end_layout

\begin_layout LyX-Code

\family roman
\size tiny
\color red
X = pgvdrk .

\family default
 
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The proof may fail, or may succeed in more than one way
\end_layout

\begin_layout Itemize
LVs are assigned by unification and unassigned on backtracking
\end_layout

\begin_layout Itemize
Once assigned, a logical variable is 
\emph on
immutable
\end_layout

\begin_deeper
\begin_layout Itemize
This is called 
\begin_inset Quotes eld
\end_inset

resolution of Horn clauses
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

unification
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout EndFrame

\end_layout

\begin_layout BeginFrame
Horn clauses and 
\begin_inset Quotes eld
\end_inset

resolution
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Use a restricted fragment of predicate logic:
\end_layout

\begin_deeper
\begin_layout Itemize
Expressions are conjunctions of 
\begin_inset Quotes eld
\end_inset

Horn clauses
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Formula 
\[
\left(a\wedge b\wedge...\wedge c\rightarrow d\right)\wedge\left(p\wedge q\wedge...\wedge r\rightarrow s\right)\wedge\left(\mbox{True}\rightarrow w\right)\wedge...
\]

\end_inset


\end_layout

\begin_layout Itemize
Disjunction is expressible through Horn clauses: 
\begin_inset Formula 
\[
\left(a\vee b\right)\rightarrow c=\left(a\rightarrow c\right)\wedge\left(b\rightarrow c\right)
\]

\end_inset


\end_layout

\begin_layout Itemize
Only 
\begin_inset Formula $\forall$
\end_inset

 quantifiers are allowed, and only outside: 
\begin_inset Formula 
\[
\forall X\forall Y:a(X,Y)\wedge b(Y)\rightarrow c(X)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Prolog syntax: quantifiers are implicit; implication points leftward
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Resolution
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
\left(c\leftarrow a\wedge p\wedge q\right)\Leftarrow\begin{cases}
b\leftarrow a\wedge p\\
c\leftarrow b\wedge q
\end{cases}
\]

\end_inset


\end_layout

\begin_layout EndFrame

\end_layout

\begin_layout BeginFrame
Examples: recursive predicates
\end_layout

\begin_layout Itemize
Factorial predicate: 
\color blue
fact(N,F)
\color inherit
 holds if 
\begin_inset Formula $F=N!$
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
 
\family default
\color blue
fact(1,1).
\color inherit

\begin_inset Newline newline
\end_inset


\color blue

\begin_inset space ~
\end_inset

 fact(N,F) :- M is N-1, fact(M,E), F is E*N.
\end_layout

\begin_layout Itemize
Fibonacci predicate:
\color blue
 fibo(N,F)
\color inherit
 holds if 
\begin_inset Formula $F$
\end_inset

 is 
\begin_inset Formula $N$
\end_inset

-th Fibonacci number
\begin_inset Newline newline
\end_inset


\color blue
fibo(0,1).
 fibo(1,1).
\color inherit

\begin_inset Newline newline
\end_inset


\color blue
fibo(N,F) :- M1 is N-1, fibo(M1,E1),
\color inherit

\begin_inset Newline newline
\end_inset


\color blue

\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset

 M2 is N-2, fibo(M2,E2),  F is E1+E2.
 
\end_layout

\begin_layout Itemize
Instead of computing 
\begin_inset Formula $F$
\end_inset

 through calling a function, we 
\emph on
prove existence
\emph default
 of a value 
\begin_inset Formula $F$
\end_inset

 such that some predicate holds.
\end_layout

\begin_layout Itemize
Prolog has 
\emph on
only predicates
\emph default
 --- no declarations, expressions, functions, variables, or static types
\end_layout

\begin_deeper
\begin_layout Itemize
Note: 
\family typewriter
\color blue
M is N-1
\family default
\color inherit
 resembles an expression but is actually a predicate!
\end_layout

\end_deeper
\begin_layout EndFrame

\end_layout

\begin_layout BeginFrame
Prolog in a nutshell 2: syntax extensions
\end_layout

\begin_layout Itemize
Syntax for data structures: 
\begin_inset Quotes eld
\end_inset

passive predicates
\begin_inset Quotes erd
\end_inset


\begin_inset Newline newline
\end_inset


\family typewriter
 
\color blue
left(pair(X,Y), X).
 right(pair(X,Y), Y).
\end_layout

\begin_deeper
\begin_layout Itemize
since 
\family typewriter
\color blue
pair(X,Y)
\family default
\color inherit
 is 
\emph on
inside
\emph default
 a predicate, it must be data
\end_layout

\begin_layout Itemize
however, 
\family typewriter
\color blue
pair(X,Y)
\family default
\color inherit
 can contain 
\emph on
free
\emph default
 logical variables
\end_layout

\begin_layout Itemize
and so can contain 
\emph on
any
\emph default
 other structures (no types!): 
\begin_inset Newline newline
\end_inset


\family typewriter
\color blue
pair(pair(X,Y),pair(Y,pair(Z,T)))
\end_layout

\end_deeper
\begin_layout Itemize
Syntax sugar for lists: 
\family typewriter
\color blue
[]
\family default
\color inherit
 or 
\family typewriter
\color blue
[a,b,c]
\family default
\color inherit
 or 
\family typewriter
\color blue
[a,b,c|[]]
\end_layout

\begin_deeper
\begin_layout Itemize
Examples:
\begin_inset Newline newline
\end_inset


\family typewriter
 
\color blue
head([X|Xs], X).
 tail([X|Xs], Xs).
 empty([]).
\family default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\color blue
 length([], 0).
\family default

\begin_inset Newline newline
\end_inset


\family typewriter
 length([X|Xs],N) = length(Xs,M), N is M+1.
\end_layout

\end_deeper
\begin_layout Itemize
User-defined syntax: infix, prefix, postfix
\begin_inset Newline newline
\end_inset


\family typewriter
\color blue
 op(400, xfy, *).
 op(300, yfx, ^).
 op(200, xf, :!).
\end_layout

\begin_layout Itemize
Many more features (metaprogramming, sets, cut/fail, etc.)
\end_layout

\begin_layout EndFrame

\end_layout

\begin_layout BeginFrame
\begin_inset Quotes eld
\end_inset

Pointers made safe
\begin_inset Quotes erd
\end_inset

: lists
\end_layout

\begin_layout Itemize
Append lists: this takes linear time!
\begin_inset Newline newline
\end_inset


\family typewriter
 
\color blue
append_l([], X, X).
\family default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\color blue
 append_l([X|Xs], Y, [X|Zs]) :- append(Xs, Y, Zs).
\end_layout

\begin_layout Itemize
Problem: We want a 
\begin_inset Quotes eld
\end_inset

pointer to the end of the list
\begin_inset Quotes erd
\end_inset

!
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

having a pointer
\begin_inset Quotes erd
\end_inset

 = a part of a data structure is 
\emph on
not yet assigned
\end_layout

\begin_layout Itemize
solution: a free LV is exposed, unified with some part of the data
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Difference lists
\series default
: 
\family typewriter
\color blue
pair([a,b,c|X],X)
\family default
\color inherit
 or 
\family typewriter
\color blue
[a,b,c|X]-X
\family default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
 
\color blue
op(500, xfy, -).
 empty(X-X).
 
\family default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\color blue
 append_dl(X-Y,Y-Z,X-Z).
 /* that's it??? */
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color red
[trace] ?- append( [a,b,c|A]- A, [d,e|B]-B, C).
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color red
Call: (6) append([a, b, c|_G2447]-_G2447, [d, e|_G2456]-_G2456, _G2463)
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color red
Exit: (6) append([a, b, c, d, e|_G2456]-[d, e|_G2456], [d, e|_G2456]-_G2456,
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color red
    [a, b, c, d, e|_G2456]-_G2456)
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color red
A = [d, e|B],   C = [a, b, c, d, e|B]-B.

\size default
\color inherit
 
\end_layout

\begin_layout BeginFrame
\begin_inset Quotes eld
\end_inset

Pointers made safe
\begin_inset Quotes erd
\end_inset

: queues
\end_layout

\begin_layout Itemize
Implement a queue (insertions at end of list)
\begin_inset Newline newline
\end_inset


\family typewriter
 
\color blue
list_to_queue(L,Q-Y) :- append_l(L,Y,Q).
\family default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
 
\color blue
insert_at_end(E, Q-[E|Y], Q-Y).
\family default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\color blue
 head(E, [E|Q]-Y, Q-Y).
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color red
[trace] ?- append( [a,b,c|A]- A, [d,e|B]-B, C).
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color red
Call: (6) append([a, b, c|_G2447]-_G2447, [d, e|_G2456]-_G2456, _G2463)
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color red
Exit: (6) append([a, b, c, d, e|_G2456]-[d, e|_G2456], [d, e|_G2456]-_G2456,
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color red
    [a, b, c, d, e|_G2456]-_G2456)
\end_layout

\begin_layout LyX-Code

\size scriptsize
\color red
A = [d, e|B],   C = [a, b, c, d, e|B]-B.

\size default
\color inherit
 
\end_layout

\begin_layout EndFrame

\end_layout

\begin_layout BeginFrame
Conclusions and outlook
\end_layout

\begin_layout Itemize
Prolog is a forgotten, but its legacy lives on
\end_layout

\begin_layout Itemize
It is quite easy to pick up Prolog, after seeing SQL and Haskell
\end_layout

\begin_layout Itemize
Prolog makes building DSLs easy
\end_layout

\begin_layout Itemize
Mercury = Prolog + types + functions 
\end_layout

\begin_layout Itemize
Curry = Haskell + logical variables + predicates
\end_layout

\begin_layout EndFrame

\end_layout

\begin_layout BeginFrame
Suggested reading 
\end_layout

\begin_layout Standard
Free implementations I used:
\end_layout

\begin_layout Itemize
SWI-Prolog: 
\begin_inset CommandInset href
LatexCommand href
name "http://www.swi-prolog.org/"
target "http://www.swi-prolog.org/"

\end_inset

 
\end_layout

\begin_layout Itemize
The Mercury programming language: 
\begin_inset CommandInset href
LatexCommand href
name "http://www.mercurylang.org/information/features.html"
target "http://www.mercurylang.org/information/features.html"

\end_inset


\end_layout

\begin_layout Standard
Pedagogical introduction to logic programming:
\begin_inset Note Note
status open

\begin_layout Plain Layout
http://f3.tiera.ru/2/Cs_Computer%20science/CsPl_Programming%20languages/Prolog/
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
D.
 Maier, D.S.
 Warren.
 
\emph on
Computing with logic: Logic programming with Prolog
\emph default
.
 Addison-Wesley, 1988
\end_layout

\begin_layout Standard
Advanced core Prolog programming:
\end_layout

\begin_layout Itemize
E.
 Shapiro, L.
 Sterling.
 
\emph on
The art of Prolog
\emph default
.
 MIT, 1999
\end_layout

\begin_layout Itemize
T.
 Van Le.
 
\emph on
Techniques of Prolog programming
\emph default
.
 Wiley, 1993
\end_layout

\begin_layout Itemize
R.
 O'Keefe.
 
\emph on
The craft of Prolog
\emph default
.
 MIT, 1990
\end_layout

\begin_layout Standard
Implementation: (the WAM is still an important source of inspiration)
\end_layout

\begin_layout Itemize
H.
 Ait-Kaci.
 
\emph on

\begin_inset CommandInset href
LatexCommand href
name "Warren's Abstract Machine (WAM). A tutorial.  1991"
target "http://wambook.sourceforge.net/"

\end_inset


\end_layout

\begin_layout EndFrame

\end_layout

\begin_layout BeginFrame
Summary
\end_layout

\begin_layout Itemize
What is "logic programming" and "constraint programming"
\end_layout

\begin_layout Itemize
Prolog in a nutshell
\end_layout

\begin_layout Itemize
How Prolog "makes pointers safe" 
\end_layout

\begin_layout Itemize
Why Prolog was the ultimate scripting language for AI (backtracking search,
 interpreters, and DSLs for free) 
\end_layout

\begin_layout Itemize
What is "functional-logic programming" (a taste of the programming languages
 Mercury and Curry)
\end_layout

\begin_layout EndFrame

\end_layout

\end_body
\end_document
